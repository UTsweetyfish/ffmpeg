Index: ffmpeg/configure
===================================================================
--- ffmpeg.orig/configure
+++ ffmpeg/configure
@@ -2956,6 +2956,7 @@ nvenc_encoder_deps="nvenc"
 
 h263_v4l2m2m_decoder_deps="v4l2_m2m h263_v4l2_m2m"
 h263_v4l2m2m_encoder_deps="v4l2_m2m h263_v4l2_m2m"
+h264_omx_decoder_deps="omx"
 h264_amf_encoder_deps="amf"
 h264_crystalhd_decoder_select="crystalhd h264_mp4toannexb_bsf h264_parser"
 h264_cuvid_decoder_deps="cuvid"
@@ -2974,6 +2975,7 @@ h264_vaapi_encoder_select="cbs_h264 vaap
 h264_v4l2m2m_decoder_deps="v4l2_m2m h264_v4l2_m2m"
 h264_v4l2m2m_decoder_select="h264_mp4toannexb_bsf"
 h264_v4l2m2m_encoder_deps="v4l2_m2m h264_v4l2_m2m"
+hevc_omx_decoder_deps="omx"
 hevc_amf_encoder_deps="amf"
 hevc_cuvid_decoder_deps="cuvid"
 hevc_cuvid_decoder_select="hevc_mp4toannexb_bsf"
@@ -2997,6 +2999,8 @@ mjpeg_vaapi_encoder_deps="VAEncPicturePa
 mjpeg_vaapi_encoder_select="cbs_jpeg jpegtables vaapi_encode"
 mpeg1_cuvid_decoder_deps="cuvid"
 mpeg1_v4l2m2m_decoder_deps="v4l2_m2m mpeg1_v4l2_m2m"
+mpeg2_omx_decoder_deps="omx"
+mpeg1_omx_decoder_deps="omx"
 mpeg2_crystalhd_decoder_select="crystalhd"
 mpeg2_cuvid_decoder_deps="cuvid"
 mpeg2_mmal_decoder_deps="mmal"
@@ -3005,6 +3009,7 @@ mpeg2_qsv_decoder_select="qsvdec mpegvid
 mpeg2_qsv_encoder_select="qsvenc"
 mpeg2_vaapi_encoder_select="cbs_mpeg2 vaapi_encode"
 mpeg2_v4l2m2m_decoder_deps="v4l2_m2m mpeg2_v4l2_m2m"
+mpeg4_omx_decoder_deps="omx"
 mpeg4_crystalhd_decoder_select="crystalhd"
 mpeg4_cuvid_decoder_deps="cuvid"
 mpeg4_mediacodec_decoder_deps="mediacodec"
@@ -3029,6 +3034,7 @@ vp8_vaapi_encoder_deps="VAEncPicturePara
 vp8_vaapi_encoder_select="vaapi_encode"
 vp8_v4l2m2m_decoder_deps="v4l2_m2m vp8_v4l2_m2m"
 vp8_v4l2m2m_encoder_deps="v4l2_m2m vp8_v4l2_m2m"
+vp9_omx_decoder_deps="omx"
 vp9_cuvid_decoder_deps="cuvid"
 vp9_mediacodec_decoder_deps="mediacodec"
 vp9_rkmpp_decoder_deps="rkmpp"
Index: ffmpeg/libavcodec/HW_OMX_AsString.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_AsString.h
@@ -0,0 +1,1067 @@
+/*
+ * Copyright 2014 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/* NOTE: This file contains several sections for individual OMX include files.
+   Each section has its own include guard.  This file should be included AFTER
+   the OMX include files. */
+
+#ifdef ANDROID
+namespace android {
+#endif
+
+#ifdef HW_OMX_Audio_h
+/* asString definitions if media/openmax/HW_OMX_Audio.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_AUDIO_H
+#define AS_STRING_FOR_HW_OMX_AUDIO_H
+
+inline static const char *asString(HW_OMX_AUDIO_CODINGTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_AUDIO_CodingUnused:     return "Unused";      // unused
+        case HW_OMX_AUDIO_CodingAutoDetect: return "AutoDetect";  // unused
+        case HW_OMX_AUDIO_CodingPCM:        return "PCM";
+        case HW_OMX_AUDIO_CodingADPCM:      return "ADPCM";       // unused
+        case HW_OMX_AUDIO_CodingAMR:        return "AMR";
+        case HW_OMX_AUDIO_CodingGSMFR:      return "GSMFR";
+        case HW_OMX_AUDIO_CodingGSMEFR:     return "GSMEFR";      // unused
+        case HW_OMX_AUDIO_CodingGSMHR:      return "GSMHR";       // unused
+        case HW_OMX_AUDIO_CodingPDCFR:      return "PDCFR";       // unused
+        case HW_OMX_AUDIO_CodingPDCEFR:     return "PDCEFR";      // unused
+        case HW_OMX_AUDIO_CodingPDCHR:      return "PDCHR";       // unused
+        case HW_OMX_AUDIO_CodingTDMAFR:     return "TDMAFR";      // unused
+        case HW_OMX_AUDIO_CodingTDMAEFR:    return "TDMAEFR";     // unused
+        case HW_OMX_AUDIO_CodingQCELP8:     return "QCELP8";      // unused
+        case HW_OMX_AUDIO_CodingQCELP13:    return "QCELP13";     // unused
+        case HW_OMX_AUDIO_CodingEVRC:       return "EVRC";        // unused
+        case HW_OMX_AUDIO_CodingSMV:        return "SMV";         // unused
+        case HW_OMX_AUDIO_CodingG711:       return "G711";
+        case HW_OMX_AUDIO_CodingG723:       return "G723";        // unused
+        case HW_OMX_AUDIO_CodingG726:       return "G726";        // unused
+        case HW_OMX_AUDIO_CodingG729:       return "G729";        // unused
+        case HW_OMX_AUDIO_CodingAAC:        return "AAC";
+        case HW_OMX_AUDIO_CodingMP3:        return "MP3";
+        case HW_OMX_AUDIO_CodingSBC:        return "SBC";         // unused
+        case HW_OMX_AUDIO_CodingVORBIS:     return "VORBIS";
+        case HW_OMX_AUDIO_CodingWMA:        return "WMA";         // unused
+        case HW_OMX_AUDIO_CodingRA:         return "RA";          // unused
+        case HW_OMX_AUDIO_CodingMIDI:       return "MIDI";        // unused
+        case HW_OMX_AUDIO_CodingFLAC:       return "FLAC";
+        default:                         return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_AUDIO_PCMMODETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_AUDIO_PCMModeLinear: return "Linear";
+        case HW_OMX_AUDIO_PCMModeALaw:   return "ALaw";
+        case HW_OMX_AUDIO_PCMModeMULaw:  return "MULaw";
+        default:                      return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_AUDIO_CHANNELTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_AUDIO_ChannelNone: return "None";  // unused
+        case HW_OMX_AUDIO_ChannelLF:   return "LF";
+        case HW_OMX_AUDIO_ChannelRF:   return "RF";
+        case HW_OMX_AUDIO_ChannelCF:   return "CF";
+        case HW_OMX_AUDIO_ChannelLS:   return "LS";
+        case HW_OMX_AUDIO_ChannelRS:   return "RS";
+        case HW_OMX_AUDIO_ChannelLFE:  return "LFE";
+        case HW_OMX_AUDIO_ChannelCS:   return "CS";
+        case HW_OMX_AUDIO_ChannelLR:   return "LR";
+        case HW_OMX_AUDIO_ChannelRR:   return "RR";
+        default:                    return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_AUDIO_CHANNELMODETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_AUDIO_ChannelModeStereo:      return "Stereo";
+//      case HW_OMX_AUDIO_ChannelModeJointStereo: return "JointStereo";
+//      case HW_OMX_AUDIO_ChannelModeDual:        return "Dual";
+        case HW_OMX_AUDIO_ChannelModeMono:        return "Mono";
+        default:                               return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_AUDIO_AACPROFILETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_AUDIO_AACObjectNull:     return "Null";
+        case HW_OMX_AUDIO_AACObjectMain:     return "Main";
+        case HW_OMX_AUDIO_AACObjectLC:       return "LC";
+        case HW_OMX_AUDIO_AACObjectSSR:      return "SSR";
+        case HW_OMX_AUDIO_AACObjectLTP:      return "LTP";
+        case HW_OMX_AUDIO_AACObjectHE:       return "HE";
+        case HW_OMX_AUDIO_AACObjectScalable: return "Scalable";
+        case HW_OMX_AUDIO_AACObjectER_Scalable: return "ER_Scalable";
+        case HW_OMX_AUDIO_AACObjectERLC:     return "ERLC";
+        case HW_OMX_AUDIO_AACObjectLD:       return "LD";
+        case HW_OMX_AUDIO_AACObjectHE_PS:    return "HE_PS";
+        default:                          return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_AUDIO_AACSTREAMFORMATTYPE i, const char *def = "??") {
+    switch (i) {
+//      case HW_OMX_AUDIO_AACStreamFormatMP2ADTS: return "MP2ADTS";
+        case HW_OMX_AUDIO_AACStreamFormatMP4ADTS: return "MP4ADTS";
+//      case HW_OMX_AUDIO_AACStreamFormatMP4LOAS: return "MP4LOAS";
+//      case HW_OMX_AUDIO_AACStreamFormatMP4LATM: return "MP4LATM";
+//      case HW_OMX_AUDIO_AACStreamFormatADIF:    return "ADIF";
+        case HW_OMX_AUDIO_AACStreamFormatMP4FF:   return "MP4FF";
+//      case HW_OMX_AUDIO_AACStreamFormatRAW:     return "RAW";
+        default:                               return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_AUDIO_AMRFRAMEFORMATTYPE i, const char *def = "??") {
+    switch (i) {
+//      case HW_OMX_AUDIO_AMRFrameFormatConformance: return "Conformance";
+//      case HW_OMX_AUDIO_AMRFrameFormatIF1:         return "IF1";
+//      case HW_OMX_AUDIO_AMRFrameFormatIF2:         return "IF2";
+        case HW_OMX_AUDIO_AMRFrameFormatFSF:         return "FSF";
+//      case HW_OMX_AUDIO_AMRFrameFormatRTPPayload:  return "RTPPayload";
+//      case HW_OMX_AUDIO_AMRFrameFormatITU:         return "ITU";
+        default:                                  return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_AUDIO_AMRBANDMODETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_AUDIO_AMRBandModeUnused: return "Unused";
+        case HW_OMX_AUDIO_AMRBandModeNB0:    return "NB0";
+        case HW_OMX_AUDIO_AMRBandModeNB1:    return "NB1";
+        case HW_OMX_AUDIO_AMRBandModeNB2:    return "NB2";
+        case HW_OMX_AUDIO_AMRBandModeNB3:    return "NB3";
+        case HW_OMX_AUDIO_AMRBandModeNB4:    return "NB4";
+        case HW_OMX_AUDIO_AMRBandModeNB5:    return "NB5";
+        case HW_OMX_AUDIO_AMRBandModeNB6:    return "NB6";
+        case HW_OMX_AUDIO_AMRBandModeNB7:    return "NB7";
+        case HW_OMX_AUDIO_AMRBandModeWB0:    return "WB0";
+        case HW_OMX_AUDIO_AMRBandModeWB1:    return "WB1";
+        case HW_OMX_AUDIO_AMRBandModeWB2:    return "WB2";
+        case HW_OMX_AUDIO_AMRBandModeWB3:    return "WB3";
+        case HW_OMX_AUDIO_AMRBandModeWB4:    return "WB4";
+        case HW_OMX_AUDIO_AMRBandModeWB5:    return "WB5";
+        case HW_OMX_AUDIO_AMRBandModeWB6:    return "WB6";
+        case HW_OMX_AUDIO_AMRBandModeWB7:    return "WB7";
+        case HW_OMX_AUDIO_AMRBandModeWB8:    return "WB8";
+        default:                          return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_AUDIO_AMRDTXMODETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_AUDIO_AMRDTXModeOff:    return "ModeOff";
+//      case HW_OMX_AUDIO_AMRDTXModeOnVAD1: return "ModeOnVAD1";
+//      case HW_OMX_AUDIO_AMRDTXModeOnVAD2: return "ModeOnVAD2";
+//      case HW_OMX_AUDIO_AMRDTXModeOnAuto: return "ModeOnAuto";
+//      case HW_OMX_AUDIO_AMRDTXasEFR:      return "asEFR";
+        default:                         return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_AUDIO_H
+
+#endif // HW_OMX_Audio_h
+
+#ifdef HW_OMX_AudioExt_h
+/* asString definitions if media/openmax/HW_OMX_AudioExt.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_AUDIOEXT_H
+#define AS_STRING_FOR_HW_OMX_AUDIOEXT_H
+
+inline static const char *asString(HW_OMX_AUDIO_CODINGEXTTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_AUDIO_CodingAndroidAC3:  return "AndroidAC3";
+        case HW_OMX_AUDIO_CodingAndroidEAC3: return "AndroidEAC3";
+        case HW_OMX_AUDIO_CodingAndroidOPUS: return "AndroidOPUS";
+        case HW_OMX_AUDIO_CodingAndroidAC4:  return "AndroidAC4";
+        default:                          return asString((HW_OMX_AUDIO_CODINGTYPE)i, def);
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_AUDIOEXT_H
+
+#endif // HW_OMX_AudioExt_h
+
+#ifdef HW_OMX_Component_h
+/* asString definitions if media/openmax/HW_OMX_Component.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_COMPONENT_H
+#define AS_STRING_FOR_HW_OMX_COMPONENT_H
+
+inline static const char *asString(HW_OMX_PORTDOMAINTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_PortDomainAudio: return "Audio";
+        case HW_OMX_PortDomainVideo: return "Video";
+        case HW_OMX_PortDomainImage: return "Image";
+//      case HW_OMX_PortDomainOther: return "Other";
+        default:                  return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_COMPONENT_H
+
+#endif // HW_OMX_Component_h
+
+#ifdef HW_OMX_Core_h
+/* asString definitions if media/openmax/HW_OMX_Core.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_CORE_H
+#define AS_STRING_FOR_HW_OMX_CORE_H
+
+inline static const char *asString(HW_OMX_COMMANDTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_CommandStateSet:    return "StateSet";
+        case HW_OMX_CommandFlush:       return "Flush";
+        case HW_OMX_CommandPortDisable: return "PortDisable";
+        case HW_OMX_CommandPortEnable:  return "PortEnable";
+//      case HW_OMX_CommandMarkBuffer:  return "MarkBuffer";
+        default:                     return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_STATETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_StateInvalid:          return "Invalid";
+        case HW_OMX_StateLoaded:           return "Loaded";
+        case HW_OMX_StateIdle:             return "Idle";
+        case HW_OMX_StateExecuting:        return "Executing";
+//      case HW_OMX_StatePause:            return "Pause";
+//      case HW_OMX_StateWaitForResources: return "WaitForResources";
+        default:                        return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_ERRORTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_ErrorNone:                               return "None";
+        case HW_OMX_ErrorInsufficientResources:              return "InsufficientResources";
+        case HW_OMX_ErrorUndefined:                          return "Undefined";
+        case HW_OMX_ErrorInvalidComponentName:               return "InvalidComponentName";
+        case HW_OMX_ErrorComponentNotFound:                  return "ComponentNotFound";
+        case HW_OMX_ErrorInvalidComponent:                   return "InvalidComponent";       // unused
+        case HW_OMX_ErrorBadParameter:                       return "BadParameter";
+        case HW_OMX_ErrorNotImplemented:                     return "NotImplemented";
+        case HW_OMX_ErrorUnderflow:                          return "Underflow";              // unused
+        case HW_OMX_ErrorOverflow:                           return "Overflow";               // unused
+        case HW_OMX_ErrorHardware:                           return "Hardware";               // unused
+        case HW_OMX_ErrorInvalidState:                       return "InvalidState";
+        case HW_OMX_ErrorStreamCorrupt:                      return "StreamCorrupt";
+        case HW_OMX_ErrorPortsNotCompatible:                 return "PortsNotCompatible";     // unused
+        case HW_OMX_ErrorResourcesLost:                      return "ResourcesLost";
+        case HW_OMX_ErrorNoMore:                             return "NoMore";
+        case HW_OMX_ErrorVersionMismatch:                    return "VersionMismatch";        // unused
+        case HW_OMX_ErrorNotReady:                           return "NotReady";               // unused
+        case HW_OMX_ErrorTimeout:                            return "Timeout";                // unused
+        case HW_OMX_ErrorSameState:                          return "SameState";              // unused
+        case HW_OMX_ErrorResourcesPreempted:                 return "ResourcesPreempted";     // unused
+        case HW_OMX_ErrorPortUnresponsiveDuringAllocation:
+            return "PortUnresponsiveDuringAllocation";    // unused
+        case HW_OMX_ErrorPortUnresponsiveDuringDeallocation:
+            return "PortUnresponsiveDuringDeallocation";  // unused
+        case HW_OMX_ErrorPortUnresponsiveDuringStop:
+            return "PortUnresponsiveDuringStop";          // unused
+        case HW_OMX_ErrorIncorrectStateTransition:
+            return "IncorrectStateTransition";            // unused
+        case HW_OMX_ErrorIncorrectStateOperation:
+            return "IncorrectStateOperation";             // unused
+        case HW_OMX_ErrorUnsupportedSetting:                 return "UnsupportedSetting";
+        case HW_OMX_ErrorUnsupportedIndex:                   return "UnsupportedIndex";
+        case HW_OMX_ErrorBadPortIndex:                       return "BadPortIndex";
+        case HW_OMX_ErrorPortUnpopulated:                    return "PortUnpopulated";        // unused
+        case HW_OMX_ErrorComponentSuspended:                 return "ComponentSuspended";     // unused
+        case HW_OMX_ErrorDynamicResourcesUnavailable:
+            return "DynamicResourcesUnavailable";         // unused
+        case HW_OMX_ErrorMbErrorsInFrame:                    return "MbErrorsInFrame";        // unused
+        case HW_OMX_ErrorFormatNotDetected:                  return "FormatNotDetected";      // unused
+        case HW_OMX_ErrorContentPipeOpenFailed:              return "ContentPipeOpenFailed";  // unused
+        case HW_OMX_ErrorContentPipeCreationFailed:
+            return "ContentPipeCreationFailed";           // unused
+        case HW_OMX_ErrorSeperateTablesUsed:                 return "SeperateTablesUsed";     // unused
+        case HW_OMX_ErrorTunnelingUnsupported:               return "TunnelingUnsupported";   // unused
+        default:                                          return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_EVENTTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_EventCmdComplete:               return "CmdComplete";
+        case HW_OMX_EventError:                     return "Error";
+//      case HW_OMX_EventMark:                      return "Mark";
+        case HW_OMX_EventPortSettingsChanged:       return "PortSettingsChanged";
+        case HW_OMX_EventBufferFlag:                return "BufferFlag";
+//      case HW_OMX_EventResourcesAcquired:         return "ResourcesAcquired";
+//      case HW_OMX_EventComponentResumed:          return "ComponentResumed";
+//      case HW_OMX_EventDynamicResourcesAvailable: return "DynamicResourcesAvailable";
+//      case HW_OMX_EventPortFormatDetected:        return "PortFormatDetected";
+        case HW_OMX_EventOutputRendered:            return "OutputRendered";
+        case HW_OMX_EventDataSpaceChanged:          return "DataSpaceChanged";
+        default:                                 return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_CORE_H
+
+#endif // HW_OMX_Core_h
+
+#ifdef HW_OMX_Image_h
+/* asString definitions if media/openmax/HW_OMX_Image.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_IMAGE_H
+#define AS_STRING_FOR_HW_OMX_IMAGE_H
+
+inline static const char *asString(HW_OMX_IMAGE_CODINGTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_IMAGE_CodingUnused:     return "Unused";
+        case HW_OMX_IMAGE_CodingAutoDetect: return "AutoDetect";  // unused
+        case HW_OMX_IMAGE_CodingJPEG:       return "JPEG";
+        case HW_OMX_IMAGE_CodingJPEG2K:     return "JPEG2K";      // unused
+        case HW_OMX_IMAGE_CodingEXIF:       return "EXIF";        // unused
+        case HW_OMX_IMAGE_CodingTIFF:       return "TIFF";        // unused
+        case HW_OMX_IMAGE_CodingGIF:        return "GIF";         // unused
+        case HW_OMX_IMAGE_CodingPNG:        return "PNG";         // unused
+        case HW_OMX_IMAGE_CodingLZW:        return "LZW";         // unused
+        case HW_OMX_IMAGE_CodingBMP:        return "BMP";         // unused
+        default:                         return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_IMAGE_H
+
+#endif // HW_OMX_Image_h
+
+#ifdef HW_OMX_Index_h
+/* asString definitions if media/openmax/HW_OMX_Index.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_INDEX_H
+#define AS_STRING_FOR_HW_OMX_INDEX_H
+
+inline static const char *asString(HW_OMX_INDEXTYPE i, const char *def = "??") {
+    switch (i) {
+//      case HW_OMX_IndexParamPriorityMgmt:                    return "ParamPriorityMgmt";
+//      case HW_OMX_IndexParamAudioInit:                       return "ParamAudioInit";
+//      case HW_OMX_IndexParamImageInit:                       return "ParamImageInit";
+//      case HW_OMX_IndexParamVideoInit:                       return "ParamVideoInit";
+//      case HW_OMX_IndexParamOtherInit:                       return "ParamOtherInit";
+//      case HW_OMX_IndexParamNumAvailableStreams:             return "ParamNumAvailableStreams";
+//      case HW_OMX_IndexParamActiveStream:                    return "ParamActiveStream";
+//      case HW_OMX_IndexParamSuspensionPolicy:                return "ParamSuspensionPolicy";
+//      case HW_OMX_IndexParamComponentSuspended:              return "ParamComponentSuspended";
+//      case HW_OMX_IndexConfigCapturing:                      return "ConfigCapturing";
+//      case HW_OMX_IndexConfigCaptureMode:                    return "ConfigCaptureMode";
+//      case HW_OMX_IndexAutoPauseAfterCapture:                return "AutoPauseAfterCapture";
+//      case HW_OMX_IndexParamContentURI:                      return "ParamContentURI";
+//      case HW_OMX_IndexParamCustomContentPipe:               return "ParamCustomContentPipe";
+//      case HW_OMX_IndexParamDisableResourceConcealment:
+//          return "ParamDisableResourceConcealment";
+//      case HW_OMX_IndexConfigMetadataItemCount:              return "ConfigMetadataItemCount";
+//      case HW_OMX_IndexConfigContainerNodeCount:             return "ConfigContainerNodeCount";
+//      case HW_OMX_IndexConfigMetadataItem:                   return "ConfigMetadataItem";
+//      case HW_OMX_IndexConfigCounterNodeID:                  return "ConfigCounterNodeID";
+//      case HW_OMX_IndexParamMetadataFilterType:              return "ParamMetadataFilterType";
+//      case HW_OMX_IndexParamMetadataKeyFilter:               return "ParamMetadataKeyFilter";
+//      case HW_OMX_IndexConfigPriorityMgmt:                   return "ConfigPriorityMgmt";
+        case HW_OMX_IndexParamStandardComponentRole:           return "ParamStandardComponentRole";
+        case HW_OMX_IndexParamPortDefinition:                  return "ParamPortDefinition";
+//      case HW_OMX_IndexParamCompBufferSupplier:              return "ParamCompBufferSupplier";
+        case HW_OMX_IndexParamAudioPortFormat:                 return "ParamAudioPortFormat";
+        case HW_OMX_IndexParamAudioPcm:                        return "ParamAudioPcm";
+        case HW_OMX_IndexParamAudioAac:                        return "ParamAudioAac";
+//      case HW_OMX_IndexParamAudioRa:                         return "ParamAudioRa";
+        case HW_OMX_IndexParamAudioMp3:                        return "ParamAudioMp3";
+//      case HW_OMX_IndexParamAudioAdpcm:                      return "ParamAudioAdpcm";
+//      case HW_OMX_IndexParamAudioG723:                       return "ParamAudioG723";
+//      case HW_OMX_IndexParamAudioG729:                       return "ParamAudioG729";
+        case HW_OMX_IndexParamAudioAmr:                        return "ParamAudioAmr";
+//      case HW_OMX_IndexParamAudioWma:                        return "ParamAudioWma";
+//      case HW_OMX_IndexParamAudioSbc:                        return "ParamAudioSbc";
+//      case HW_OMX_IndexParamAudioMidi:                       return "ParamAudioMidi";
+//      case HW_OMX_IndexParamAudioGsm_FR:                     return "ParamAudioGsm_FR";
+//      case HW_OMX_IndexParamAudioMidiLoadUserSound:          return "ParamAudioMidiLoadUserSound";
+//      case HW_OMX_IndexParamAudioG726:                       return "ParamAudioG726";
+//      case HW_OMX_IndexParamAudioGsm_EFR:                    return "ParamAudioGsm_EFR";
+//      case HW_OMX_IndexParamAudioGsm_HR:                     return "ParamAudioGsm_HR";
+//      case HW_OMX_IndexParamAudioPdc_FR:                     return "ParamAudioPdc_FR";
+//      case HW_OMX_IndexParamAudioPdc_EFR:                    return "ParamAudioPdc_EFR";
+//      case HW_OMX_IndexParamAudioPdc_HR:                     return "ParamAudioPdc_HR";
+//      case HW_OMX_IndexParamAudioTdma_FR:                    return "ParamAudioTdma_FR";
+//      case HW_OMX_IndexParamAudioTdma_EFR:                   return "ParamAudioTdma_EFR";
+//      case HW_OMX_IndexParamAudioQcelp8:                     return "ParamAudioQcelp8";
+//      case HW_OMX_IndexParamAudioQcelp13:                    return "ParamAudioQcelp13";
+//      case HW_OMX_IndexParamAudioEvrc:                       return "ParamAudioEvrc";
+//      case HW_OMX_IndexParamAudioSmv:                        return "ParamAudioSmv";
+        case HW_OMX_IndexParamAudioVorbis:                     return "ParamAudioVorbis";
+        case HW_OMX_IndexParamAudioFlac:                       return "ParamAudioFlac";
+//      case HW_OMX_IndexConfigAudioMidiImmediateEvent:        return "ConfigAudioMidiImmediateEvent";
+//      case HW_OMX_IndexConfigAudioMidiControl:               return "ConfigAudioMidiControl";
+//      case HW_OMX_IndexConfigAudioMidiSoundBankProgram:
+//          return "ConfigAudioMidiSoundBankProgram";
+//      case HW_OMX_IndexConfigAudioMidiStatus:                return "ConfigAudioMidiStatus";
+//      case HW_OMX_IndexConfigAudioMidiMetaEvent:             return "ConfigAudioMidiMetaEvent";
+//      case HW_OMX_IndexConfigAudioMidiMetaEventData:         return "ConfigAudioMidiMetaEventData";
+//      case HW_OMX_IndexConfigAudioVolume:                    return "ConfigAudioVolume";
+//      case HW_OMX_IndexConfigAudioBalance:                   return "ConfigAudioBalance";
+//      case HW_OMX_IndexConfigAudioChannelMute:               return "ConfigAudioChannelMute";
+//      case HW_OMX_IndexConfigAudioMute:                      return "ConfigAudioMute";
+//      case HW_OMX_IndexConfigAudioLoudness:                  return "ConfigAudioLoudness";
+//      case HW_OMX_IndexConfigAudioEchoCancelation:           return "ConfigAudioEchoCancelation";
+//      case HW_OMX_IndexConfigAudioNoiseReduction:            return "ConfigAudioNoiseReduction";
+//      case HW_OMX_IndexConfigAudioBass:                      return "ConfigAudioBass";
+//      case HW_OMX_IndexConfigAudioTreble:                    return "ConfigAudioTreble";
+//      case HW_OMX_IndexConfigAudioStereoWidening:            return "ConfigAudioStereoWidening";
+//      case HW_OMX_IndexConfigAudioChorus:                    return "ConfigAudioChorus";
+//      case HW_OMX_IndexConfigAudioEqualizer:                 return "ConfigAudioEqualizer";
+//      case HW_OMX_IndexConfigAudioReverberation:             return "ConfigAudioReverberation";
+//      case HW_OMX_IndexConfigAudioChannelVolume:             return "ConfigAudioChannelVolume";
+//      case HW_OMX_IndexParamImagePortFormat:                 return "ParamImagePortFormat";
+//      case HW_OMX_IndexParamFlashControl:                    return "ParamFlashControl";
+//      case HW_OMX_IndexConfigFocusControl:                   return "ConfigFocusControl";
+//      case HW_OMX_IndexParamQFactor:                         return "ParamQFactor";
+//      case HW_OMX_IndexParamQuantizationTable:               return "ParamQuantizationTable";
+//      case HW_OMX_IndexParamHuffmanTable:                    return "ParamHuffmanTable";
+//      case HW_OMX_IndexConfigFlashControl:                   return "ConfigFlashControl";
+        case HW_OMX_IndexParamVideoPortFormat:                 return "ParamVideoPortFormat";
+//      case HW_OMX_IndexParamVideoQuantization:               return "ParamVideoQuantization";
+//      case HW_OMX_IndexParamVideoFastUpdate:                 return "ParamVideoFastUpdate";
+        case HW_OMX_IndexParamVideoBitrate:                    return "ParamVideoBitrate";
+//      case HW_OMX_IndexParamVideoMotionVector:               return "ParamVideoMotionVector";
+        case HW_OMX_IndexParamVideoIntraRefresh:               return "ParamVideoIntraRefresh";
+        case HW_OMX_IndexParamVideoErrorCorrection:            return "ParamVideoErrorCorrection";
+//      case HW_OMX_IndexParamVideoVBSMC:                      return "ParamVideoVBSMC";
+//      case HW_OMX_IndexParamVideoMpeg2:                      return "ParamVideoMpeg2";
+        case HW_OMX_IndexParamVideoMpeg4:                      return "ParamVideoMpeg4";
+//      case HW_OMX_IndexParamVideoWmv:                        return "ParamVideoWmv";
+//      case HW_OMX_IndexParamVideoRv:                         return "ParamVideoRv";
+        case HW_OMX_IndexParamVideoAvc:                        return "ParamVideoAvc";
+        case HW_OMX_IndexParamVideoH263:                       return "ParamVideoH263";
+        case HW_OMX_IndexParamVideoProfileLevelQuerySupported:
+            return "ParamVideoProfileLevelQuerySupported";
+        case HW_OMX_IndexParamVideoProfileLevelCurrent:        return "ParamVideoProfileLevelCurrent";
+        case HW_OMX_IndexConfigVideoBitrate:                   return "ConfigVideoBitrate";
+//      case HW_OMX_IndexConfigVideoFramerate:                 return "ConfigVideoFramerate";
+        case HW_OMX_IndexConfigVideoIntraVOPRefresh:           return "ConfigVideoIntraVOPRefresh";
+//      case HW_OMX_IndexConfigVideoIntraMBRefresh:            return "ConfigVideoIntraMBRefresh";
+//      case HW_OMX_IndexConfigVideoMBErrorReporting:          return "ConfigVideoMBErrorReporting";
+//      case HW_OMX_IndexParamVideoMacroblocksPerFrame:        return "ParamVideoMacroblocksPerFrame";
+//      case HW_OMX_IndexConfigVideoMacroBlockErrorMap:        return "ConfigVideoMacroBlockErrorMap";
+//      case HW_OMX_IndexParamVideoSliceFMO:                   return "ParamVideoSliceFMO";
+//      case HW_OMX_IndexConfigVideoAVCIntraPeriod:            return "ConfigVideoAVCIntraPeriod";
+//      case HW_OMX_IndexConfigVideoNalSize:                   return "ConfigVideoNalSize";
+//      case HW_OMX_IndexParamCommonDeblocking:                return "ParamCommonDeblocking";
+//      case HW_OMX_IndexParamCommonSensorMode:                return "ParamCommonSensorMode";
+//      case HW_OMX_IndexParamCommonInterleave:                return "ParamCommonInterleave";
+//      case HW_OMX_IndexConfigCommonColorFormatConversion:
+//          return "ConfigCommonColorFormatConversion";
+        case HW_OMX_IndexConfigCommonScale:                    return "ConfigCommonScale";
+//      case HW_OMX_IndexConfigCommonImageFilter:              return "ConfigCommonImageFilter";
+//      case HW_OMX_IndexConfigCommonColorEnhancement:         return "ConfigCommonColorEnhancement";
+//      case HW_OMX_IndexConfigCommonColorKey:                 return "ConfigCommonColorKey";
+//      case HW_OMX_IndexConfigCommonColorBlend:               return "ConfigCommonColorBlend";
+//      case HW_OMX_IndexConfigCommonFrameStabilisation:       return "ConfigCommonFrameStabilisation";
+//      case HW_OMX_IndexConfigCommonRotate:                   return "ConfigCommonRotate";
+//      case HW_OMX_IndexConfigCommonMirror:                   return "ConfigCommonMirror";
+//      case HW_OMX_IndexConfigCommonOutputPosition:           return "ConfigCommonOutputPosition";
+        case HW_OMX_IndexConfigCommonInputCrop:                return "ConfigCommonInputCrop";
+        case HW_OMX_IndexConfigCommonOutputCrop:               return "ConfigCommonOutputCrop";
+//      case HW_OMX_IndexConfigCommonDigitalZoom:              return "ConfigCommonDigitalZoom";
+//      case HW_OMX_IndexConfigCommonOpticalZoom:              return "ConfigCommonOpticalZoom";
+//      case HW_OMX_IndexConfigCommonWhiteBalance:             return "ConfigCommonWhiteBalance";
+//      case HW_OMX_IndexConfigCommonExposure:                 return "ConfigCommonExposure";
+//      case HW_OMX_IndexConfigCommonContrast:                 return "ConfigCommonContrast";
+//      case HW_OMX_IndexConfigCommonBrightness:               return "ConfigCommonBrightness";
+//      case HW_OMX_IndexConfigCommonBacklight:                return "ConfigCommonBacklight";
+//      case HW_OMX_IndexConfigCommonGamma:                    return "ConfigCommonGamma";
+//      case HW_OMX_IndexConfigCommonSaturation:               return "ConfigCommonSaturation";
+//      case HW_OMX_IndexConfigCommonLightness:                return "ConfigCommonLightness";
+//      case HW_OMX_IndexConfigCommonExclusionRect:            return "ConfigCommonExclusionRect";
+//      case HW_OMX_IndexConfigCommonDithering:                return "ConfigCommonDithering";
+//      case HW_OMX_IndexConfigCommonPlaneBlend:               return "ConfigCommonPlaneBlend";
+//      case HW_OMX_IndexConfigCommonExposureValue:            return "ConfigCommonExposureValue";
+//      case HW_OMX_IndexConfigCommonOutputSize:               return "ConfigCommonOutputSize";
+//      case HW_OMX_IndexParamCommonExtraQuantData:            return "ParamCommonExtraQuantData";
+//      case HW_OMX_IndexConfigCommonFocusRegion:              return "ConfigCommonFocusRegion";
+//      case HW_OMX_IndexConfigCommonFocusStatus:              return "ConfigCommonFocusStatus";
+//      case HW_OMX_IndexConfigCommonTransitionEffect:         return "ConfigCommonTransitionEffect";
+//      case HW_OMX_IndexParamOtherPortFormat:                 return "ParamOtherPortFormat";
+//      case HW_OMX_IndexConfigOtherPower:                     return "ConfigOtherPower";
+//      case HW_OMX_IndexConfigOtherStats:                     return "ConfigOtherStats";
+//      case HW_OMX_IndexConfigTimeScale:                      return "ConfigTimeScale";
+//      case HW_OMX_IndexConfigTimeClockState:                 return "ConfigTimeClockState";
+//      case HW_OMX_IndexConfigTimeActiveRefClock:             return "ConfigTimeActiveRefClock";
+//      case HW_OMX_IndexConfigTimeCurrentMediaTime:           return "ConfigTimeCurrentMediaTime";
+//      case HW_OMX_IndexConfigTimeCurrentWallTime:            return "ConfigTimeCurrentWallTime";
+//      case HW_OMX_IndexConfigTimeCurrentAudioReference:
+//          return "ConfigTimeCurrentAudioReference";
+//      case HW_OMX_IndexConfigTimeCurrentVideoReference:
+//          return "ConfigTimeCurrentVideoReference";
+//      case HW_OMX_IndexConfigTimeMediaTimeRequest:           return "ConfigTimeMediaTimeRequest";
+//      case HW_OMX_IndexConfigTimeClientStartTime:            return "ConfigTimeClientStartTime";
+//      case HW_OMX_IndexConfigTimePosition:                   return "ConfigTimePosition";
+//      case HW_OMX_IndexConfigTimeSeekMode:                   return "ConfigTimeSeekMode";
+        default:                                            return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_INDEX_H
+
+#endif // HW_OMX_Index_h
+
+#ifdef HW_OMX_IndexExt_h
+/* asString definitions if media/openmax/HW_OMX_IndexExt.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_INDEXEXT_H
+#define AS_STRING_FOR_HW_OMX_INDEXEXT_H
+
+inline static const char *asString(HW_OMX_INDEXEXTTYPE i, const char *def = "??") {
+    switch (i) {
+//      case HW_OMX_IndexConfigCallbackRequest:            return "ConfigCallbackRequest";
+//      case HW_OMX_IndexConfigCommitMode:                 return "ConfigCommitMode";
+//      case HW_OMX_IndexConfigCommit:                     return "ConfigCommit";
+        case HW_OMX_IndexConfigAndroidVendorExtension:     return "ConfigAndroidVendorExtension";
+        case HW_OMX_IndexParamAudioAndroidAc3:             return "ParamAudioAndroidAc3";
+        case HW_OMX_IndexConfigAudioPresentation:          return "ConfigAudioPresentation";
+        case HW_OMX_IndexParamAudioAndroidOpus:            return "ParamAudioAndroidOpus";
+        case HW_OMX_IndexParamAudioAndroidAacPresentation: return "ParamAudioAndroidAacPresentation";
+        case HW_OMX_IndexParamAudioAndroidEac3:            return "ParamAudioAndroidEac3";
+        case HW_OMX_IndexParamAudioAndroidAc4:             return "ParamAudioAndroidAc4";
+        case HW_OMX_IndexParamAudioProfileQuerySupported:  return "ParamAudioProfileQuerySupported";
+//      case HW_OMX_IndexParamNalStreamFormatSupported:    return "ParamNalStreamFormatSupported";
+//      case HW_OMX_IndexParamNalStreamFormat:             return "ParamNalStreamFormat";
+//      case HW_OMX_IndexParamNalStreamFormatSelect:       return "ParamNalStreamFormatSelect";
+        case HW_OMX_IndexParamVideoVp8:                    return "ParamVideoVp8";
+//      case HW_OMX_IndexConfigVideoVp8ReferenceFrame:     return "ConfigVideoVp8ReferenceFrame";
+//      case HW_OMX_IndexConfigVideoVp8ReferenceFrameType: return "ConfigVideoVp8ReferenceFrameType";
+        case HW_OMX_IndexParamVideoAndroidVp8Encoder:      return "ParamVideoAndroidVp8Encoder";
+        case HW_OMX_IndexParamVideoHevc:                   return "ParamVideoHevc";
+//      case HW_OMX_IndexParamSliceSegments:               return "ParamSliceSegments";
+        case HW_OMX_IndexConfigAndroidIntraRefresh:        return "ConfigAndroidIntraRefresh";
+        case HW_OMX_IndexParamAndroidVideoTemporalLayering: return "ParamAndroidVideoTemporalLayering";
+        case HW_OMX_IndexConfigAndroidVideoTemporalLayering: return "ConfigAndroidVideoTemporalLayering";
+        case HW_OMX_IndexParamMaxFrameDurationForBitrateControl:
+            return "ParamMaxFrameDurationForBitrateControl";
+        case HW_OMX_IndexParamVideoVp9:                    return "ParamVideoVp9";
+        case HW_OMX_IndexParamVideoAndroidVp9Encoder:      return "ParamVideoAndroidVp9Encoder";
+        case HW_OMX_IndexConfigAutoFramerateConversion:    return "ConfigAutoFramerateConversion";
+        case HW_OMX_IndexConfigPriority:                   return "ConfigPriority";
+        case HW_OMX_IndexConfigOperatingRate:              return "ConfigOperatingRate";
+        case HW_OMX_IndexParamConsumerUsageBits:           return "ParamConsumerUsageBits";
+        case HW_OMX_IndexConfigLatency:                    return "ConfigLatency";
+        default:                                        return asString((HW_OMX_INDEXTYPE)i, def);
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_INDEXEXT_H
+
+#endif // HW_OMX_IndexExt_h
+
+#ifdef HW_OMX_IVCommon_h
+/* asString definitions if media/openmax/HW_OMX_IVCommon.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_IVCOMMON_H
+#define AS_STRING_FOR_HW_OMX_IVCOMMON_H
+
+inline static const char *asString(HW_OMX_COLOR_FORMATTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_COLOR_FormatUnused:
+            return "COLOR_FormatUnused";
+        case HW_OMX_COLOR_FormatMonochrome:
+            return "COLOR_FormatMonochrome";
+        case HW_OMX_COLOR_Format8bitRGB332:
+            return "COLOR_Format8bitRGB332";
+        case HW_OMX_COLOR_Format12bitRGB444:
+            return "COLOR_Format12bitRGB444";
+        case HW_OMX_COLOR_Format16bitARGB4444:
+            return "COLOR_Format16bitARGB4444";
+        case HW_OMX_COLOR_Format16bitARGB1555:
+            return "COLOR_Format16bitARGB1555";
+        case HW_OMX_COLOR_Format16bitRGB565:
+            return "COLOR_Format16bitRGB565";
+        case HW_OMX_COLOR_Format16bitBGR565:
+            return "COLOR_Format16bitBGR565";
+        case HW_OMX_COLOR_Format18bitRGB666:
+            return "COLOR_Format18bitRGB666";
+        case HW_OMX_COLOR_Format18bitARGB1665:
+            return "COLOR_Format18bitARGB1665";
+        case HW_OMX_COLOR_Format19bitARGB1666:
+            return "COLOR_Format19bitARGB1666";
+        case HW_OMX_COLOR_Format24bitRGB888:
+            return "COLOR_Format24bitRGB888";
+        case HW_OMX_COLOR_Format24bitBGR888:
+            return "COLOR_Format24bitBGR888";
+        case HW_OMX_COLOR_Format24bitARGB1887:
+            return "COLOR_Format24bitARGB1887";
+        case HW_OMX_COLOR_Format25bitARGB1888:
+            return "COLOR_Format25bitARGB1888";
+        case HW_OMX_COLOR_Format32bitBGRA8888:
+            return "COLOR_Format32bitBGRA8888";
+        case HW_OMX_COLOR_Format32bitARGB8888:
+            return "COLOR_Format32bitARGB8888";
+        case HW_OMX_COLOR_FormatYUV411Planar:
+            return "COLOR_FormatYUV411Planar";
+        case HW_OMX_COLOR_FormatYUV411PackedPlanar:
+            return "COLOR_FormatYUV411PackedPlanar";
+        case HW_OMX_COLOR_FormatYUV420Planar:
+            return "COLOR_FormatYUV420Planar";
+        case HW_OMX_COLOR_FormatYUV420PackedPlanar:
+            return "COLOR_FormatYUV420PackedPlanar";
+        case HW_OMX_COLOR_FormatYUV420SemiPlanar:
+            return "COLOR_FormatYUV420SemiPlanar";
+        case HW_OMX_COLOR_FormatYUV422Planar:
+            return "COLOR_FormatYUV422Planar";
+        case HW_OMX_COLOR_FormatYUV422PackedPlanar:
+            return "COLOR_FormatYUV422PackedPlanar";
+        case HW_OMX_COLOR_FormatYUV422SemiPlanar:
+            return "COLOR_FormatYUV422SemiPlanar";
+        case HW_OMX_COLOR_FormatYCbYCr:
+            return "COLOR_FormatYCbYCr";
+        case HW_OMX_COLOR_FormatYCrYCb:
+            return "COLOR_FormatYCrYCb";
+        case HW_OMX_COLOR_FormatCbYCrY:
+            return "COLOR_FormatCbYCrY";
+        case HW_OMX_COLOR_FormatCrYCbY:
+            return "COLOR_FormatCrYCbY";
+        case HW_OMX_COLOR_FormatYUV444Interleaved:
+            return "COLOR_FormatYUV444Interleaved";
+        case HW_OMX_COLOR_FormatRawBayer8bit:
+            return "COLOR_FormatRawBayer8bit";
+        case HW_OMX_COLOR_FormatRawBayer10bit:
+            return "COLOR_FormatRawBayer10bit";
+        case HW_OMX_COLOR_FormatRawBayer8bitcompressed:
+            return "COLOR_FormatRawBayer8bitcompressed";
+        case HW_OMX_COLOR_FormatL2:
+            return "COLOR_FormatL2";
+        case HW_OMX_COLOR_FormatL4:
+            return "COLOR_FormatL4";
+        case HW_OMX_COLOR_FormatL8:
+            return "COLOR_FormatL8";
+        case HW_OMX_COLOR_FormatL16:
+            return "COLOR_FormatL16";
+        case HW_OMX_COLOR_FormatL24:
+            return "COLOR_FormatL24";
+        case HW_OMX_COLOR_FormatL32:
+            return "COLOR_FormatL32";
+        case HW_OMX_COLOR_FormatYUV420PackedSemiPlanar:
+            return "COLOR_FormatYUV420PackedSemiPlanar";
+        case HW_OMX_COLOR_FormatYUV422PackedSemiPlanar:
+            return "COLOR_FormatYUV422PackedSemiPlanar";
+        case HW_OMX_COLOR_Format18BitBGR666:
+            return "COLOR_Format18BitBGR666";
+        case HW_OMX_COLOR_Format24BitARGB6666:
+            return "COLOR_Format24BitARGB6666";
+        case HW_OMX_COLOR_Format24BitABGR6666:
+            return "COLOR_Format24BitABGR6666";
+        case HW_OMX_COLOR_FormatAndroidOpaque:
+            return "COLOR_FormatAndroidOpaque";
+        case HW_OMX_COLOR_FormatYUV420Flexible:
+            return "COLOR_FormatYUV420Flexible";
+        case HW_OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
+            return "TI_COLOR_FormatYUV420PackedSemiPlanar";
+        case HW_OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
+            return "QCOM_COLOR_FormatYVU420SemiPlanar";
+//      case HW_OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka:
+//          return "QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka";
+//      case HW_OMX_SEC_COLOR_FormatNV12Tiled:
+//          return "SEC_COLOR_FormatNV12Tiled";
+//      case HW_OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar32m:
+//          return "QCOM_COLOR_FormatYUV420PackedSemiPlanar32m";
+        default:
+            return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_IVCOMMON_H
+
+#endif // HW_OMX_IVCommon_h
+
+#ifdef HW_OMX_Types_h
+/* asString definitions if media/openmax/HW_OMX_Types.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_TYPES_H
+#define AS_STRING_FOR_HW_OMX_TYPES_H
+
+inline static const char *asString(HW_OMX_BOOL i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_FALSE: return "FALSE";
+        case HW_OMX_TRUE:  return "TRUE";
+        default:        return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_DIRTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_DirInput:  return "Input";
+        case HW_OMX_DirOutput: return "Output";
+        default:            return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_ENDIANTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_EndianBig:    return "Big";
+//      case HW_OMX_EndianLittle: return "Little";
+        default:               return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_NUMERICALDATATYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_NumericalDataSigned:   return "Signed";
+//      case HW_OMX_NumericalDataUnsigned: return "Unsigned";
+        default:                        return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_TYPES_H
+
+#endif // HW_OMX_Types_h
+
+#ifdef HW_OMX_Video_h
+/* asString definitions if media/openmax/HW_OMX_Video.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_VIDEO_H
+#define AS_STRING_FOR_HW_OMX_VIDEO_H
+
+inline static const char *asString(HW_OMX_VIDEO_CODINGTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_CodingUnused:     return "Unused";
+        case HW_OMX_VIDEO_CodingAutoDetect: return "AutoDetect";  // unused
+        case HW_OMX_VIDEO_CodingMPEG2:      return "MPEG2";
+        case HW_OMX_VIDEO_CodingH263:       return "H263";
+        case HW_OMX_VIDEO_CodingMPEG4:      return "MPEG4";
+        case HW_OMX_VIDEO_CodingWMV:        return "WMV";         // unused
+        case HW_OMX_VIDEO_CodingRV:         return "RV";          // unused
+        case HW_OMX_VIDEO_CodingAVC:        return "AVC";
+        case HW_OMX_VIDEO_CodingMJPEG:      return "MJPEG";       // unused
+        case HW_OMX_VIDEO_CodingVP8:        return "VP8";
+        case HW_OMX_VIDEO_CodingVP9:        return "VP9";
+        case HW_OMX_VIDEO_CodingHEVC:       return "HEVC";
+        case HW_OMX_VIDEO_CodingDolbyVision:return "DolbyVision";
+        default:                         return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_CONTROLRATETYPE i, const char *def = "??") {
+    switch (i) {
+//      case HW_OMX_Video_ControlRateDisable:            return "Disable";
+        case HW_OMX_Video_ControlRateVariable:           return "Variable";
+        case HW_OMX_Video_ControlRateConstant:           return "Constant";
+//      case HW_OMX_Video_ControlRateVariableSkipFrames: return "VariableSkipFrames";
+//      case HW_OMX_Video_ControlRateConstantSkipFrames: return "ConstantSkipFrames";
+        default:                                      return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_INTRAREFRESHTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_IntraRefreshCyclic:   return "Cyclic";
+        case HW_OMX_VIDEO_IntraRefreshAdaptive: return "Adaptive";
+        case HW_OMX_VIDEO_IntraRefreshBoth:     return "Both";
+        default:                             return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_H263PROFILETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_H263ProfileBaseline:           return "Baseline";
+        case HW_OMX_VIDEO_H263ProfileH320Coding:         return "H320Coding";
+        case HW_OMX_VIDEO_H263ProfileBackwardCompatible: return "BackwardCompatible";
+        case HW_OMX_VIDEO_H263ProfileISWV2:              return "ISWV2";
+        case HW_OMX_VIDEO_H263ProfileISWV3:              return "ISWV3";
+        case HW_OMX_VIDEO_H263ProfileHighCompression:    return "HighCompression";
+        case HW_OMX_VIDEO_H263ProfileInternet:           return "Internet";
+        case HW_OMX_VIDEO_H263ProfileInterlace:          return "Interlace";
+        case HW_OMX_VIDEO_H263ProfileHighLatency:        return "HighLatency";
+        default:                                      return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_H263LEVELTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_H263Level10: return "Level10";
+        case HW_OMX_VIDEO_H263Level20: return "Level20";
+        case HW_OMX_VIDEO_H263Level30: return "Level30";
+        case HW_OMX_VIDEO_H263Level40: return "Level40";
+        case HW_OMX_VIDEO_H263Level45: return "Level45";
+        case HW_OMX_VIDEO_H263Level50: return "Level50";
+        case HW_OMX_VIDEO_H263Level60: return "Level60";
+        case HW_OMX_VIDEO_H263Level70: return "Level70";
+        default:                    return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_PICTURETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_PictureTypeI:  return "I";
+        case HW_OMX_VIDEO_PictureTypeP:  return "P";
+        case HW_OMX_VIDEO_PictureTypeB:  return "B";
+//      case HW_OMX_VIDEO_PictureTypeSI: return "SI";
+//      case HW_OMX_VIDEO_PictureTypeSP: return "SP";
+//      case HW_OMX_VIDEO_PictureTypeEI: return "EI";
+//      case HW_OMX_VIDEO_PictureTypeEP: return "EP";
+//      case HW_OMX_VIDEO_PictureTypeS:  return "S";
+        default:                      return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_MPEG4PROFILETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_MPEG4ProfileSimple:           return "Simple";
+        case HW_OMX_VIDEO_MPEG4ProfileSimpleScalable:   return "SimpleScalable";
+        case HW_OMX_VIDEO_MPEG4ProfileCore:             return "Core";
+        case HW_OMX_VIDEO_MPEG4ProfileMain:             return "Main";
+        case HW_OMX_VIDEO_MPEG4ProfileNbit:             return "Nbit";
+        case HW_OMX_VIDEO_MPEG4ProfileScalableTexture:  return "ScalableTexture";
+        case HW_OMX_VIDEO_MPEG4ProfileSimpleFace:       return "SimpleFace";
+        case HW_OMX_VIDEO_MPEG4ProfileSimpleFBA:        return "SimpleFBA";
+        case HW_OMX_VIDEO_MPEG4ProfileBasicAnimated:    return "BasicAnimated";
+        case HW_OMX_VIDEO_MPEG4ProfileHybrid:           return "Hybrid";
+        case HW_OMX_VIDEO_MPEG4ProfileAdvancedRealTime: return "AdvancedRealTime";
+        case HW_OMX_VIDEO_MPEG4ProfileCoreScalable:     return "CoreScalable";
+        case HW_OMX_VIDEO_MPEG4ProfileAdvancedCoding:   return "AdvancedCoding";
+        case HW_OMX_VIDEO_MPEG4ProfileAdvancedCore:     return "AdvancedCore";
+        case HW_OMX_VIDEO_MPEG4ProfileAdvancedScalable: return "AdvancedScalable";
+        case HW_OMX_VIDEO_MPEG4ProfileAdvancedSimple:   return "AdvancedSimple";
+        default:                                     return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_MPEG4LEVELTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_MPEG4Level0:  return "Level0";
+        case HW_OMX_VIDEO_MPEG4Level0b: return "Level0b";
+        case HW_OMX_VIDEO_MPEG4Level1:  return "Level1";
+        case HW_OMX_VIDEO_MPEG4Level2:  return "Level2";
+        case HW_OMX_VIDEO_MPEG4Level3:  return "Level3";
+        case HW_OMX_VIDEO_MPEG4Level3b: return "Level3b";
+        case HW_OMX_VIDEO_MPEG4Level4:  return "Level4";
+        case HW_OMX_VIDEO_MPEG4Level4a: return "Level4a";
+        case HW_OMX_VIDEO_MPEG4Level5:  return "Level5";
+        case HW_OMX_VIDEO_MPEG4Level6:  return "Level6";
+        default:                     return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_MPEG2PROFILETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_MPEG2ProfileSimple:  return "Simple";
+        case HW_OMX_VIDEO_MPEG2ProfileMain:    return "Main";
+        case HW_OMX_VIDEO_MPEG2Profile422:     return "4:2:2";
+        case HW_OMX_VIDEO_MPEG2ProfileSNR:     return "SNR";
+        case HW_OMX_VIDEO_MPEG2ProfileSpatial: return "Spatial";
+        case HW_OMX_VIDEO_MPEG2ProfileHigh:    return "High";
+        default:                            return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_MPEG2LEVELTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_MPEG2LevelLL:  return "Low";
+        case HW_OMX_VIDEO_MPEG2LevelML:  return "Main";
+        case HW_OMX_VIDEO_MPEG2LevelH14: return "High1440";
+        case HW_OMX_VIDEO_MPEG2LevelHL:  return "High";
+        default:                      return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_AVCPROFILETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_AVCProfileBaseline: return "Baseline";
+        case HW_OMX_VIDEO_AVCProfileMain:     return "Main";
+        case HW_OMX_VIDEO_AVCProfileExtended: return "Extended";
+        case HW_OMX_VIDEO_AVCProfileHigh:     return "High";
+        case HW_OMX_VIDEO_AVCProfileHigh10:   return "High10";
+        case HW_OMX_VIDEO_AVCProfileHigh422:  return "High422";
+        case HW_OMX_VIDEO_AVCProfileHigh444:  return "High444";
+        default:                           return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_AVCLEVELTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_AVCLevel1:  return "Level1";
+        case HW_OMX_VIDEO_AVCLevel1b: return "Level1b";
+        case HW_OMX_VIDEO_AVCLevel11: return "Level11";
+        case HW_OMX_VIDEO_AVCLevel12: return "Level12";
+        case HW_OMX_VIDEO_AVCLevel13: return "Level13";
+        case HW_OMX_VIDEO_AVCLevel2:  return "Level2";
+        case HW_OMX_VIDEO_AVCLevel21: return "Level21";
+        case HW_OMX_VIDEO_AVCLevel22: return "Level22";
+        case HW_OMX_VIDEO_AVCLevel3:  return "Level3";
+        case HW_OMX_VIDEO_AVCLevel31: return "Level31";
+        case HW_OMX_VIDEO_AVCLevel32: return "Level32";
+        case HW_OMX_VIDEO_AVCLevel4:  return "Level4";
+        case HW_OMX_VIDEO_AVCLevel41: return "Level41";
+        case HW_OMX_VIDEO_AVCLevel42: return "Level42";
+        case HW_OMX_VIDEO_AVCLevel5:  return "Level5";
+        case HW_OMX_VIDEO_AVCLevel51: return "Level51";
+        case HW_OMX_VIDEO_AVCLevel52: return "Level52";
+        case HW_OMX_VIDEO_AVCLevel6:  return "Level6";
+        case HW_OMX_VIDEO_AVCLevel61: return "Level61";
+        case HW_OMX_VIDEO_AVCLevel62: return "Level62";
+        default:                   return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_AVCLOOPFILTERTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_AVCLoopFilterEnable:               return "Enable";
+//      case HW_OMX_VIDEO_AVCLoopFilterDisable:              return "Disable";
+//      case HW_OMX_VIDEO_AVCLoopFilterDisableSliceBoundary: return "DisableSliceBoundary";
+        default:                                          return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_VIDEO_H
+
+#endif // HW_OMX_Video_h
+
+#ifdef HW_OMX_VideoExt_h
+/* asString definitions if media/openmax/HW_OMX_VideoExt.h was included */
+
+#ifndef AS_STRING_FOR_HW_OMX_VIDEOEXT_H
+#define AS_STRING_FOR_HW_OMX_VIDEOEXT_H
+
+inline static const char *asString(HW_OMX_VIDEO_AVCPROFILEEXTTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_AVCProfileConstrainedBaseline:   return "ConstrainedBaseline";
+        case HW_OMX_VIDEO_AVCProfileConstrainedHigh:       return "ConstrainedHigh";
+        default:                                return asString((HW_OMX_VIDEO_AVCPROFILETYPE)i, def);
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_VP8PROFILETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_VP8ProfileMain:    return "Main";
+        case HW_OMX_VIDEO_VP8ProfileUnknown: return "Unknown";  // unused
+        default:                          return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_VP8LEVELTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_VP8Level_Version0: return "_Version0";
+        case HW_OMX_VIDEO_VP8Level_Version1: return "_Version1";
+        case HW_OMX_VIDEO_VP8Level_Version2: return "_Version2";
+        case HW_OMX_VIDEO_VP8Level_Version3: return "_Version3";
+        case HW_OMX_VIDEO_VP8LevelUnknown:   return "Unknown";    // unused
+        default:                          return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_VP9PROFILETYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_VP9Profile0:    return "Profile0";
+        case HW_OMX_VIDEO_VP9Profile1:    return "Profile1";
+        case HW_OMX_VIDEO_VP9Profile2:    return "Profile2";
+        case HW_OMX_VIDEO_VP9Profile3:    return "Profile3";
+        case HW_OMX_VIDEO_VP9Profile2HDR: return "Profile2HDR";
+        case HW_OMX_VIDEO_VP9Profile3HDR: return "Profile3HDR";
+        default:                       return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_VP9LEVELTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_VP9Level1:  return "Level1";
+        case HW_OMX_VIDEO_VP9Level11: return "Level11";
+        case HW_OMX_VIDEO_VP9Level2:  return "Level2";
+        case HW_OMX_VIDEO_VP9Level21: return "Level21";
+        case HW_OMX_VIDEO_VP9Level3:  return "Level3";
+        case HW_OMX_VIDEO_VP9Level31: return "Level31";
+        case HW_OMX_VIDEO_VP9Level4:  return "Level4";
+        case HW_OMX_VIDEO_VP9Level41: return "Level41";
+        case HW_OMX_VIDEO_VP9Level5:  return "Level5";
+        case HW_OMX_VIDEO_VP9Level51: return "Level51";
+        case HW_OMX_VIDEO_VP9Level52: return "Level52";
+        case HW_OMX_VIDEO_VP9Level6:  return "Level6";
+        case HW_OMX_VIDEO_VP9Level61: return "Level61";
+        case HW_OMX_VIDEO_VP9Level62: return "Level62";
+        default:                   return def;
+    }
+}
+
+inline static const char *asString(
+        HW_OMX_VIDEO_ANDROID_VPXTEMPORALLAYERPATTERNTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_VPXTemporalLayerPatternNone:   return "None";
+        case HW_OMX_VIDEO_VPXTemporalLayerPatternWebRTC: return "WebRTC";
+        default:                                      return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_HEVCPROFILETYPE i, const char *def = "!!") {
+    switch (i) {
+        case HW_OMX_VIDEO_HEVCProfileUnknown:      return "Unknown";  // unused
+        case HW_OMX_VIDEO_HEVCProfileMain:         return "Main";
+        case HW_OMX_VIDEO_HEVCProfileMain10:       return "Main10";
+        case HW_OMX_VIDEO_HEVCProfileMain10HDR10:  return "Main10HDR10";
+        default:                                return def;
+    }
+}
+
+inline static const char *asString(HW_OMX_VIDEO_HEVCLEVELTYPE i, const char *def = "!!") {
+    switch (i) {
+        case HW_OMX_VIDEO_HEVCLevelUnknown:    return "LevelUnknown";     // unused
+        case HW_OMX_VIDEO_HEVCMainTierLevel1:  return "MainTierLevel1";
+        case HW_OMX_VIDEO_HEVCHighTierLevel1:  return "HighTierLevel1";
+        case HW_OMX_VIDEO_HEVCMainTierLevel2:  return "MainTierLevel2";
+        case HW_OMX_VIDEO_HEVCHighTierLevel2:  return "HighTierLevel2";
+        case HW_OMX_VIDEO_HEVCMainTierLevel21: return "MainTierLevel21";
+        case HW_OMX_VIDEO_HEVCHighTierLevel21: return "HighTierLevel21";
+        case HW_OMX_VIDEO_HEVCMainTierLevel3:  return "MainTierLevel3";
+        case HW_OMX_VIDEO_HEVCHighTierLevel3:  return "HighTierLevel3";
+        case HW_OMX_VIDEO_HEVCMainTierLevel31: return "MainTierLevel31";
+        case HW_OMX_VIDEO_HEVCHighTierLevel31: return "HighTierLevel31";
+        case HW_OMX_VIDEO_HEVCMainTierLevel4:  return "MainTierLevel4";
+        case HW_OMX_VIDEO_HEVCHighTierLevel4:  return "HighTierLevel4";
+        case HW_OMX_VIDEO_HEVCMainTierLevel41: return "MainTierLevel41";
+        case HW_OMX_VIDEO_HEVCHighTierLevel41: return "HighTierLevel41";
+        case HW_OMX_VIDEO_HEVCMainTierLevel5:  return "MainTierLevel5";
+        case HW_OMX_VIDEO_HEVCHighTierLevel5:  return "HighTierLevel5";
+        case HW_OMX_VIDEO_HEVCMainTierLevel51: return "MainTierLevel51";
+        case HW_OMX_VIDEO_HEVCHighTierLevel51: return "HighTierLevel51";
+        case HW_OMX_VIDEO_HEVCMainTierLevel52: return "MainTierLevel52";
+        case HW_OMX_VIDEO_HEVCHighTierLevel52: return "HighTierLevel52";
+        case HW_OMX_VIDEO_HEVCMainTierLevel6:  return "MainTierLevel6";
+        case HW_OMX_VIDEO_HEVCHighTierLevel6:  return "HighTierLevel6";
+        case HW_OMX_VIDEO_HEVCMainTierLevel61: return "MainTierLevel61";
+        case HW_OMX_VIDEO_HEVCHighTierLevel61: return "HighTierLevel61";
+        case HW_OMX_VIDEO_HEVCMainTierLevel62: return "MainTierLevel62";
+        case HW_OMX_VIDEO_HEVCHighTierLevel62: return "HighTierLevel62";
+        default:                            return def;
+    }
+}
+
+inline static const char *asString(
+        HW_OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE i, const char *def = "??") {
+    switch (i) {
+        case HW_OMX_VIDEO_AndroidTemporalLayeringPatternNone:    return "None";
+        case HW_OMX_VIDEO_AndroidTemporalLayeringPatternWebRTC:  return "WebRTC";
+        case HW_OMX_VIDEO_AndroidTemporalLayeringPatternAndroid: return "Android";
+        default:                                              return def;
+    }
+}
+
+#endif // AS_STRING_FOR_HW_OMX_VIDEOEXT_H
+
+#endif // HW_OMX_VideoExt_h
+
+#ifdef ANDROID
+} // namespace android
+#endif
Index: ffmpeg/libavcodec/HW_OMX_Audio.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_Audio.h
@@ -0,0 +1,1344 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file HW_OMX_Audio.h - OpenMax IL version 1.1.2
+ *  The structures needed by Audio components to exchange
+ *  parameters and configuration data with the componenmilts.
+ */
+
+#ifndef HW_OMX_Audio_h
+#define HW_OMX_Audio_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+
+#include "HW_OMX_Core.h"
+
+/** @defgroup midi MIDI
+ * @ingroup audio
+ */
+
+/** @defgroup effects Audio effects
+ * @ingroup audio
+ */
+
+/** @defgroup audio OpenMAX IL Audio Domain
+ * Structures for OpenMAX IL Audio domain
+ * @{
+ */
+
+/** Enumeration used to define the possible audio codings.
+ *  If "HW_OMX_AUDIO_CodingUnused" is selected, the coding selection must
+ *  be done in a vendor specific way.  Since this is for an audio
+ *  processing element this enum is relevant.  However, for another
+ *  type of component other enums would be in this area.
+ */
+typedef enum HW_OMX_AUDIO_CODINGTYPE {
+    HW_OMX_AUDIO_CodingUnused = 0,  /**< Placeholder value when coding is N/A  */
+    HW_OMX_AUDIO_CodingAutoDetect,  /**< auto detection of audio format */
+    HW_OMX_AUDIO_CodingPCM,         /**< Any variant of PCM coding */
+    HW_OMX_AUDIO_CodingADPCM,       /**< Any variant of ADPCM encoded data */
+    HW_OMX_AUDIO_CodingAMR,         /**< Any variant of AMR encoded data */
+    HW_OMX_AUDIO_CodingGSMFR,       /**< Any variant of GSM fullrate (i.e. GSM610) */
+    HW_OMX_AUDIO_CodingGSMEFR,      /**< Any variant of GSM Enhanced Fullrate encoded data*/
+    HW_OMX_AUDIO_CodingGSMHR,       /**< Any variant of GSM Halfrate encoded data */
+    HW_OMX_AUDIO_CodingPDCFR,       /**< Any variant of PDC Fullrate encoded data */
+    HW_OMX_AUDIO_CodingPDCEFR,      /**< Any variant of PDC Enhanced Fullrate encoded data */
+    HW_OMX_AUDIO_CodingPDCHR,       /**< Any variant of PDC Halfrate encoded data */
+    HW_OMX_AUDIO_CodingTDMAFR,      /**< Any variant of TDMA Fullrate encoded data (TIA/EIA-136-420) */
+    HW_OMX_AUDIO_CodingTDMAEFR,     /**< Any variant of TDMA Enhanced Fullrate encoded data (TIA/EIA-136-410) */
+    HW_OMX_AUDIO_CodingQCELP8,      /**< Any variant of QCELP 8kbps encoded data */
+    HW_OMX_AUDIO_CodingQCELP13,     /**< Any variant of QCELP 13kbps encoded data */
+    HW_OMX_AUDIO_CodingEVRC,        /**< Any variant of EVRC encoded data */
+    HW_OMX_AUDIO_CodingSMV,         /**< Any variant of SMV encoded data */
+    HW_OMX_AUDIO_CodingG711,        /**< Any variant of G.711 encoded data */
+    HW_OMX_AUDIO_CodingG723,        /**< Any variant of G.723 dot 1 encoded data */
+    HW_OMX_AUDIO_CodingG726,        /**< Any variant of G.726 encoded data */
+    HW_OMX_AUDIO_CodingG729,        /**< Any variant of G.729 encoded data */
+    HW_OMX_AUDIO_CodingAAC,         /**< Any variant of AAC encoded data */
+    HW_OMX_AUDIO_CodingMP3,         /**< Any variant of MP3 encoded data */
+    HW_OMX_AUDIO_CodingSBC,         /**< Any variant of SBC encoded data */
+    HW_OMX_AUDIO_CodingVORBIS,      /**< Any variant of VORBIS encoded data */
+    HW_OMX_AUDIO_CodingWMA,         /**< Any variant of WMA encoded data */
+    HW_OMX_AUDIO_CodingRA,          /**< Any variant of RA encoded data */
+    HW_OMX_AUDIO_CodingMIDI,        /**< Any variant of MIDI encoded data */
+    HW_OMX_AUDIO_CodingFLAC,        /**< Any variant of FLAC encoded data */
+    HW_OMX_AUDIO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_CodingMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_CODINGTYPE;
+
+
+/** The PortDefinition structure is used to define all of the parameters
+ *  necessary for the compliant component to setup an input or an output audio
+ *  path.  If additional information is needed to define the parameters of the
+ *  port (such as frequency), additional structures must be sent such as the
+ *  HW_OMX_AUDIO_PARAM_PCMMODETYPE structure to supply the extra parameters for the port.
+ */
+typedef struct HW_OMX_AUDIO_PORTDEFINITIONTYPE {
+    HW_OMX_STRING cMIMEType;            /**< MIME type of data for the port */
+    HW_OMX_NATIVE_DEVICETYPE pNativeRender; /** < platform specific reference
+                                               for an output device,
+                                               otherwise this field is 0 */
+    HW_OMX_BOOL bFlagErrorConcealment;  /**< Turns on error concealment if it is
+                                          supported by the OMX component */
+    HW_OMX_AUDIO_CODINGTYPE eEncoding;  /**< Type of data expected for this
+                                          port (e.g. PCM, AMR, MP3, etc) */
+} HW_OMX_AUDIO_PORTDEFINITIONTYPE;
+
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct HW_OMX_AUDIO_PARAM_PORTFORMATTYPE {
+    HW_OMX_U32 nSize;                  /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;             /**< Indicates which port to set */
+    HW_OMX_U32 nIndex;                 /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    HW_OMX_AUDIO_CODINGTYPE eEncoding; /**< Type of data expected for this port (e.g. PCM, AMR, MP3, etc) */
+} HW_OMX_AUDIO_PARAM_PORTFORMATTYPE;
+
+
+/** PCM mode type  */
+typedef enum HW_OMX_AUDIO_PCMMODETYPE {
+    HW_OMX_AUDIO_PCMModeLinear = 0,  /**< Linear PCM encoded data */
+    HW_OMX_AUDIO_PCMModeALaw,        /**< A law PCM encoded data (G.711) */
+    HW_OMX_AUDIO_PCMModeMULaw,       /**< Mu law PCM encoded data (G.711)  */
+    HW_OMX_AUDIO_PCMModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_PCMModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_PCMModeMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_PCMMODETYPE;
+
+
+typedef enum HW_OMX_AUDIO_CHANNELTYPE {
+    HW_OMX_AUDIO_ChannelNone = 0x0,    /**< Unused or empty */
+    HW_OMX_AUDIO_ChannelLF   = 0x1,    /**< Left front */
+    HW_OMX_AUDIO_ChannelRF   = 0x2,    /**< Right front */
+    HW_OMX_AUDIO_ChannelCF   = 0x3,    /**< Center front */
+    HW_OMX_AUDIO_ChannelLS   = 0x4,    /**< Left surround */
+    HW_OMX_AUDIO_ChannelRS   = 0x5,    /**< Right surround */
+    HW_OMX_AUDIO_ChannelLFE  = 0x6,    /**< Low frequency effects */
+    HW_OMX_AUDIO_ChannelCS   = 0x7,    /**< Back surround */
+    HW_OMX_AUDIO_ChannelLR   = 0x8,    /**< Left rear. */
+    HW_OMX_AUDIO_ChannelRR   = 0x9,    /**< Right rear. */
+    HW_OMX_AUDIO_ChannelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_ChannelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_ChannelMax  = 0x7FFFFFFF
+} HW_OMX_AUDIO_CHANNELTYPE;
+
+#define HW_OMX_AUDIO_MAXCHANNELS 16  /**< maximum number distinct audio channels that a buffer may contain */
+#define HW_OMX_MIN_PCMPAYLOAD_MSEC 5 /**< Minimum audio buffer payload size for uncompressed (PCM) audio */
+
+/** PCM format description */
+typedef struct HW_OMX_AUDIO_PARAM_PCMMODETYPE {
+    HW_OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
+    HW_OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;               /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;                /**< Number of channels (e.g. 2 for stereo) */
+    HW_OMX_NUMERICALDATATYPE eNumData;   /**< indicates PCM data as signed, unsigned or floating pt. */
+    HW_OMX_ENDIANTYPE eEndian;           /**< indicates PCM data as little or big endian */
+    HW_OMX_BOOL bInterleaved;            /**< True for normal interleaved data; false for
+                                           non-interleaved data (e.g. block data) */
+    HW_OMX_U32 nBitPerSample;            /**< Bit per sample */
+    HW_OMX_U32 nSamplingRate;            /**< Sampling rate of the source data.  Use 0 for
+                                           variable or unknown sampling rate. */
+    HW_OMX_AUDIO_PCMMODETYPE ePCMMode;   /**< PCM mode enumeration */
+    HW_OMX_AUDIO_CHANNELTYPE eChannelMapping[HW_OMX_AUDIO_MAXCHANNELS]; /**< Slot i contains channel defined by eChannelMap[i] */
+
+} HW_OMX_AUDIO_PARAM_PCMMODETYPE;
+
+
+/** Audio channel mode.  This is used by both AAC and MP3, although the names are more appropriate
+ * for the MP3.  For example, JointStereo for MP3 is CouplingChannels for AAC.
+ */
+typedef enum HW_OMX_AUDIO_CHANNELMODETYPE {
+    HW_OMX_AUDIO_ChannelModeStereo = 0,  /**< 2 channels, the bitrate allocation between those
+                                          two channels changes accordingly to each channel information */
+    HW_OMX_AUDIO_ChannelModeJointStereo, /**< mode that takes advantage of what is common between
+                                           2 channels for higher compression gain */
+    HW_OMX_AUDIO_ChannelModeDual,        /**< 2 mono-channels, each channel is encoded with half
+                                           the bitrate of the overall bitrate */
+    HW_OMX_AUDIO_ChannelModeMono,        /**< Mono channel mode */
+    HW_OMX_AUDIO_ChannelModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_ChannelModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_ChannelModeMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_CHANNELMODETYPE;
+
+
+typedef enum HW_OMX_AUDIO_MP3STREAMFORMATTYPE {
+    HW_OMX_AUDIO_MP3StreamFormatMP1Layer3 = 0, /**< MP3 Audio MPEG 1 Layer 3 Stream format */
+    HW_OMX_AUDIO_MP3StreamFormatMP2Layer3,     /**< MP3 Audio MPEG 2 Layer 3 Stream format */
+    HW_OMX_AUDIO_MP3StreamFormatMP2_5Layer3,   /**< MP3 Audio MPEG2.5 Layer 3 Stream format */
+    HW_OMX_AUDIO_MP3StreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_MP3StreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_MP3StreamFormatMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_MP3STREAMFORMATTYPE;
+
+/** MP3 params */
+typedef struct HW_OMX_AUDIO_PARAM_MP3TYPE {
+    HW_OMX_U32 nSize;                 /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;             /**< Number of channels */
+    HW_OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    HW_OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    HW_OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    HW_OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+    HW_OMX_AUDIO_MP3STREAMFORMATTYPE eFormat;  /**< MP3 stream format */
+} HW_OMX_AUDIO_PARAM_MP3TYPE;
+
+
+typedef enum HW_OMX_AUDIO_AACSTREAMFORMATTYPE {
+    HW_OMX_AUDIO_AACStreamFormatMP2ADTS = 0, /**< AAC Audio Data Transport Stream 2 format */
+    HW_OMX_AUDIO_AACStreamFormatMP4ADTS,     /**< AAC Audio Data Transport Stream 4 format */
+    HW_OMX_AUDIO_AACStreamFormatMP4LOAS,     /**< AAC Low Overhead Audio Stream format */
+    HW_OMX_AUDIO_AACStreamFormatMP4LATM,     /**< AAC Low overhead Audio Transport Multiplex */
+    HW_OMX_AUDIO_AACStreamFormatADIF,        /**< AAC Audio Data Interchange Format */
+    HW_OMX_AUDIO_AACStreamFormatMP4FF,       /**< AAC inside MPEG-4/ISO File Format */
+    HW_OMX_AUDIO_AACStreamFormatRAW,         /**< AAC Raw Format */
+    HW_OMX_AUDIO_AACStreamFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_AACStreamFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_AACStreamFormatMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_AACSTREAMFORMATTYPE;
+
+
+/** AAC mode type.  Note that the term profile is used with the MPEG-2
+ * standard and the term object type and profile is used with MPEG-4 */
+typedef enum HW_OMX_AUDIO_AACPROFILETYPE{
+  HW_OMX_AUDIO_AACObjectNull = 0,      /**< Null, not used */
+  HW_OMX_AUDIO_AACObjectMain = 1,      /**< AAC Main object */
+  HW_OMX_AUDIO_AACObjectLC,            /**< AAC Low Complexity object (AAC profile) */
+  HW_OMX_AUDIO_AACObjectSSR,           /**< AAC Scalable Sample Rate object */
+  HW_OMX_AUDIO_AACObjectLTP,           /**< AAC Long Term Prediction object */
+  HW_OMX_AUDIO_AACObjectHE,            /**< AAC High Efficiency (object type SBR, HE-AAC profile) */
+  HW_OMX_AUDIO_AACObjectScalable,      /**< AAC Scalable object */
+  HW_OMX_AUDIO_AACObjectERLC = 17,     /**< ER AAC Low Complexity object (Error Resilient AAC-LC) */
+  HW_OMX_AUDIO_AACObjectER_Scalable = 20, /**< ER AAC scalable object */
+  HW_OMX_AUDIO_AACObjectLD = 23,       /**< AAC Low Delay object (Error Resilient) */
+  HW_OMX_AUDIO_AACObjectHE_PS = 29,    /**< AAC High Efficiency with Parametric Stereo coding (HE-AAC v2, object type PS) */
+  HW_OMX_AUDIO_AACObjectELD = 39,      /** AAC Enhanced Low Delay. NOTE: Pending Khronos standardization **/
+  HW_OMX_AUDIO_AACObjectXHE = 42,      /** extended High Efficiency AAC. NOTE: Pending Khronos standardization */
+  HW_OMX_AUDIO_AACObjectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  HW_OMX_AUDIO_AACObjectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  HW_OMX_AUDIO_AACObjectMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_AACPROFILETYPE;
+
+
+/** AAC tool usage (for nAACtools in HW_OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for encoder configuration and optional as decoder info output.
+ * For MP3, HW_OMX_AUDIO_CHANNELMODETYPE is sufficient. */
+#define HW_OMX_AUDIO_AACToolNone 0x00000000 /**< no AAC tools allowed (encoder config) or active (decoder info output) */
+#define HW_OMX_AUDIO_AACToolMS   0x00000001 /**< MS: Mid/side joint coding tool allowed or active */
+#define HW_OMX_AUDIO_AACToolIS   0x00000002 /**< IS: Intensity stereo tool allowed or active */
+#define HW_OMX_AUDIO_AACToolTNS  0x00000004 /**< TNS: Temporal Noise Shaping tool allowed or active */
+#define HW_OMX_AUDIO_AACToolPNS  0x00000008 /**< PNS: MPEG-4 Perceptual Noise substitution tool allowed or active */
+#define HW_OMX_AUDIO_AACToolLTP  0x00000010 /**< LTP: MPEG-4 Long Term Prediction tool allowed or active */
+#define HW_OMX_AUDIO_AACToolVendor 0x00010000 /**< NOT A KHRONOS VALUE, offset for vendor-specific additions */
+#define HW_OMX_AUDIO_AACToolAll  0x7FFFFFFF /**< all AAC tools allowed or active (*/
+
+/** MPEG-4 AAC error resilience (ER) tool usage (for nAACERtools in HW_OMX_AUDIO_PARAM_AACPROFILETYPE).
+ * Required for ER encoder configuration and optional as decoder info output */
+#define HW_OMX_AUDIO_AACERNone  0x00000000  /**< no AAC ER tools allowed/used */
+#define HW_OMX_AUDIO_AACERVCB11 0x00000001  /**< VCB11: Virtual Code Books for AAC section data */
+#define HW_OMX_AUDIO_AACERRVLC  0x00000002  /**< RVLC: Reversible Variable Length Coding */
+#define HW_OMX_AUDIO_AACERHCR   0x00000004  /**< HCR: Huffman Codeword Reordering */
+#define HW_OMX_AUDIO_AACERAll   0x7FFFFFFF  /**< all AAC ER tools allowed/used */
+
+
+/** AAC params */
+typedef struct HW_OMX_AUDIO_PARAM_AACPROFILETYPE {
+    HW_OMX_U32 nSize;                 /**< Size of this structure, in Bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;            /**< Port that this structure applies to */
+    HW_OMX_U32 nChannels;             /**< Number of channels */
+    HW_OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+    HW_OMX_U32 nBitRate;              /**< Bit rate of the input data.  Use 0 for variable
+                                        rate or unknown bit rates */
+    HW_OMX_U32 nAudioBandWidth;       /**< Audio band width (in Hz) to which an encoder should
+                                        limit the audio signal. Use 0 to let encoder decide */
+    HW_OMX_U32 nFrameLength;          /**< Frame length (in audio samples per channel) of the codec.
+                                        Can be 1024 or 960 (AAC-LC), 2048 (HE-AAC), 480 or 512 (AAC-LD).
+                                        Use 0 to let encoder decide */
+    HW_OMX_U32 nAACtools;             /**< AAC tool usage */
+    HW_OMX_U32 nAACERtools;           /**< MPEG-4 AAC error resilience tool usage */
+    HW_OMX_AUDIO_AACPROFILETYPE eAACProfile;   /**< AAC profile enumeration */
+    HW_OMX_AUDIO_AACSTREAMFORMATTYPE eAACStreamFormat; /**< AAC stream format enumeration */
+    HW_OMX_AUDIO_CHANNELMODETYPE eChannelMode;   /**< Channel mode enumeration */
+} HW_OMX_AUDIO_PARAM_AACPROFILETYPE;
+
+
+/** VORBIS params */
+typedef struct HW_OMX_AUDIO_PARAM_VORBISTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;        /**< Number of channels */
+    HW_OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
+                                   rate or unknown bit rates. Encoding is set to the
+                                   bitrate closest to specified  value (in bps) */
+    HW_OMX_U32 nMinBitRate;      /**< Sets minimum bitrate (in bps). */
+    HW_OMX_U32 nMaxBitRate;      /**< Sets maximum bitrate (in bps). */
+
+    HW_OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
+                                   variable or unknown sampling rate. */
+    HW_OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
+                                   limit the audio signal. Use 0 to let encoder decide */
+    HW_OMX_S32 nQuality;         /**< Sets encoding quality to n, between -1 (low) and 10 (high).
+                                   In the default mode of operation, teh quality level is 3.
+                                   Normal quality range is 0 - 10. */
+    HW_OMX_BOOL bManaged;        /**< Set  bitrate  management  mode. This turns off the
+                                   normal VBR encoding, but allows hard or soft bitrate
+                                   constraints to be enforced by the encoder. This mode can
+                                   be slower, and may also be lower quality. It is
+                                   primarily useful for streaming. */
+    HW_OMX_BOOL bDownmix;        /**< Downmix input from stereo to mono (has no effect on
+                                   non-stereo streams). Useful for lower-bitrate encoding. */
+} HW_OMX_AUDIO_PARAM_VORBISTYPE;
+
+
+/** FLAC params */
+typedef struct HW_OMX_AUDIO_PARAM_FLACTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;        /**< Number of channels */
+    HW_OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
+                                   unknown sampling rate. */
+    HW_OMX_U32 nCompressionLevel;/**< FLAC compression level, from 0 (fastest compression)
+                                   to 8 (highest compression */
+} HW_OMX_AUDIO_PARAM_FLACTYPE;
+
+
+/** WMA Version */
+typedef enum HW_OMX_AUDIO_WMAFORMATTYPE {
+  HW_OMX_AUDIO_WMAFormatUnused = 0, /**< format unused or unknown */
+  HW_OMX_AUDIO_WMAFormat7,          /**< Windows Media Audio format 7 */
+  HW_OMX_AUDIO_WMAFormat8,          /**< Windows Media Audio format 8 */
+  HW_OMX_AUDIO_WMAFormat9,          /**< Windows Media Audio format 9 */
+  HW_OMX_AUDIO_WMAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  HW_OMX_AUDIO_WMAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  HW_OMX_AUDIO_WMAFormatMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_WMAFORMATTYPE;
+
+
+/** WMA Profile */
+typedef enum HW_OMX_AUDIO_WMAPROFILETYPE {
+  HW_OMX_AUDIO_WMAProfileUnused = 0,  /**< profile unused or unknown */
+  HW_OMX_AUDIO_WMAProfileL1,          /**< Windows Media audio version 9 profile L1 */
+  HW_OMX_AUDIO_WMAProfileL2,          /**< Windows Media audio version 9 profile L2 */
+  HW_OMX_AUDIO_WMAProfileL3,          /**< Windows Media audio version 9 profile L3 */
+  HW_OMX_AUDIO_WMAProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  HW_OMX_AUDIO_WMAProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  HW_OMX_AUDIO_WMAProfileMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_WMAPROFILETYPE;
+
+
+/** WMA params */
+typedef struct HW_OMX_AUDIO_PARAM_WMATYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_U16 nChannels;        /**< Number of channels */
+    HW_OMX_U32 nBitRate;         /**< Bit rate of the input data.  Use 0 for variable
+                                   rate or unknown bit rates */
+    HW_OMX_AUDIO_WMAFORMATTYPE eFormat; /**< Version of WMA stream / data */
+    HW_OMX_AUDIO_WMAPROFILETYPE eProfile;  /**< Profile of WMA stream / data */
+    HW_OMX_U32 nSamplingRate;    /**< Sampling rate of the source data */
+    HW_OMX_U16 nBlockAlign;      /**< is the block alignment, or block size, in bytes of the audio codec */
+    HW_OMX_U16 nEncodeOptions;   /**< WMA Type-specific data */
+    HW_OMX_U32 nSuperBlockAlign; /**< WMA Type-specific data */
+} HW_OMX_AUDIO_PARAM_WMATYPE;
+
+/**
+ * RealAudio format
+ */
+typedef enum HW_OMX_AUDIO_RAFORMATTYPE {
+    HW_OMX_AUDIO_RAFormatUnused = 0, /**< Format unused or unknown */
+    HW_OMX_AUDIO_RA8,                /**< RealAudio 8 codec */
+    HW_OMX_AUDIO_RA9,                /**< RealAudio 9 codec */
+    HW_OMX_AUDIO_RA10_AAC,           /**< MPEG-4 AAC codec for bitrates of more than 128kbps */
+    HW_OMX_AUDIO_RA10_CODEC,         /**< RealAudio codec for bitrates less than 128 kbps */
+    HW_OMX_AUDIO_RA10_LOSSLESS,      /**< RealAudio Lossless */
+    HW_OMX_AUDIO_RA10_MULTICHANNEL,  /**< RealAudio Multichannel */
+    HW_OMX_AUDIO_RA10_VOICE,         /**< RealAudio Voice for bitrates below 15 kbps */
+    HW_OMX_AUDIO_RAFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_RAFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_RAFormatMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_RAFORMATTYPE;
+
+/** RA (Real Audio) params */
+typedef struct HW_OMX_AUDIO_PARAM_RATYPE {
+    HW_OMX_U32 nSize;              /**< Size of this structure, in Bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< Port that this structure applies to */
+    HW_OMX_U32 nChannels;          /**< Number of channels */
+    HW_OMX_U32 nSamplingRate;      /**< is the sampling rate of the source data */
+    HW_OMX_U32 nBitsPerFrame;      /**< is the value for bits per frame  */
+    HW_OMX_U32 nSamplePerFrame;    /**< is the value for samples per frame */
+    HW_OMX_U32 nCouplingQuantBits; /**< is the number of coupling quantization bits in the stream */
+    HW_OMX_U32 nCouplingStartRegion;   /**< is the coupling start region in the stream  */
+    HW_OMX_U32 nNumRegions;        /**< is the number of regions value */
+    HW_OMX_AUDIO_RAFORMATTYPE eFormat; /**< is the RealAudio audio format */
+} HW_OMX_AUDIO_PARAM_RATYPE;
+
+
+/** SBC Allocation Method Type */
+typedef enum HW_OMX_AUDIO_SBCALLOCMETHODTYPE {
+  HW_OMX_AUDIO_SBCAllocMethodLoudness, /**< Loudness allocation method */
+  HW_OMX_AUDIO_SBCAllocMethodSNR,      /**< SNR allocation method */
+  HW_OMX_AUDIO_SBCAllocMethodKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  HW_OMX_AUDIO_SBCAllocMethodVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  HW_OMX_AUDIO_SBCAllocMethodMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_SBCALLOCMETHODTYPE;
+
+
+/** SBC params */
+typedef struct HW_OMX_AUDIO_PARAM_SBCTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;         /**< Number of channels */
+    HW_OMX_U32 nBitRate;          /**< Bit rate of the input data.  Use 0 for variable
+                                    rate or unknown bit rates */
+    HW_OMX_U32 nSampleRate;       /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+    HW_OMX_U32 nBlocks;           /**< Number of blocks */
+    HW_OMX_U32 nSubbands;         /**< Number of subbands */
+    HW_OMX_U32 nBitPool;          /**< Bitpool value */
+    HW_OMX_BOOL bEnableBitrate;   /**< Use bitrate value instead of bitpool */
+    HW_OMX_AUDIO_CHANNELMODETYPE eChannelMode; /**< Channel mode enumeration */
+    HW_OMX_AUDIO_SBCALLOCMETHODTYPE eSBCAllocType;   /**< SBC Allocation method type */
+} HW_OMX_AUDIO_PARAM_SBCTYPE;
+
+
+/** ADPCM stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_ADPCMTYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;          /**< Number of channels in the data stream (not
+                                     necessarily the same as the number of channels
+                                     to be rendered. */
+    HW_OMX_U32 nBitsPerSample;     /**< Number of bits in each sample */
+    HW_OMX_U32 nSampleRate;        /**< Sampling rate of the source data.  Use 0 for
+                                    variable or unknown sampling rate. */
+} HW_OMX_AUDIO_PARAM_ADPCMTYPE;
+
+
+/** G723 rate */
+typedef enum HW_OMX_AUDIO_G723RATE {
+    HW_OMX_AUDIO_G723ModeUnused = 0,  /**< AMRNB Mode unused / unknown */
+    HW_OMX_AUDIO_G723ModeLow,         /**< 5300 bps */
+    HW_OMX_AUDIO_G723ModeHigh,        /**< 6300 bps */
+    HW_OMX_AUDIO_G723ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_G723ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_G723ModeMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_G723RATE;
+
+
+/** G723 - Sample rate must be 8 KHz */
+typedef struct HW_OMX_AUDIO_PARAM_G723TYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    HW_OMX_AUDIO_G723RATE eBitRate;  /**< todo: Should this be moved to a config? */
+    HW_OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+    HW_OMX_BOOL bPostFilter;         /**< Enable Post Filter */
+} HW_OMX_AUDIO_PARAM_G723TYPE;
+
+
+/** ITU G726 (ADPCM) rate */
+typedef enum HW_OMX_AUDIO_G726MODE {
+    HW_OMX_AUDIO_G726ModeUnused = 0,  /**< G726 Mode unused / unknown */
+    HW_OMX_AUDIO_G726Mode16,          /**< 16 kbps */
+    HW_OMX_AUDIO_G726Mode24,          /**< 24 kbps */
+    HW_OMX_AUDIO_G726Mode32,          /**< 32 kbps, most common rate, also G721 */
+    HW_OMX_AUDIO_G726Mode40,          /**< 40 kbps */
+    HW_OMX_AUDIO_G726ModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_G726ModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_G726ModeMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_G726MODE;
+
+
+/** G.726 stream format parameters - must be at 8KHz */
+typedef struct HW_OMX_AUDIO_PARAM_G726TYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;          /**< Number of channels in the data stream (not
+                                     necessarily the same as the number of channels
+                                     to be rendered. */
+     HW_OMX_AUDIO_G726MODE eG726Mode;
+} HW_OMX_AUDIO_PARAM_G726TYPE;
+
+
+/** G729 coder type */
+typedef enum HW_OMX_AUDIO_G729TYPE {
+    HW_OMX_AUDIO_G729 = 0,           /**< ITU G.729  encoded data */
+    HW_OMX_AUDIO_G729A,              /**< ITU G.729 annex A  encoded data */
+    HW_OMX_AUDIO_G729B,              /**< ITU G.729 with annex B encoded data */
+    HW_OMX_AUDIO_G729AB,             /**< ITU G.729 annexes A and B encoded data */
+    HW_OMX_AUDIO_G729KhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_G729VendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_G729Max = 0x7FFFFFFF
+} HW_OMX_AUDIO_G729TYPE;
+
+
+/** G729 stream format parameters - fixed 6KHz sample rate */
+typedef struct HW_OMX_AUDIO_PARAM_G729TYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;        /**< Number of channels in the data stream (not
+                                   necessarily the same as the number of channels
+                                   to be rendered. */
+    HW_OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    HW_OMX_AUDIO_G729TYPE eBitType;
+} HW_OMX_AUDIO_PARAM_G729TYPE;
+
+
+/** AMR Frame format */
+typedef enum HW_OMX_AUDIO_AMRFRAMEFORMATTYPE {
+    HW_OMX_AUDIO_AMRFrameFormatConformance = 0,  /**< Frame Format is AMR Conformance
+                                                   (Standard) Format */
+    HW_OMX_AUDIO_AMRFrameFormatIF1,              /**< Frame Format is AMR Interface
+                                                   Format 1 */
+    HW_OMX_AUDIO_AMRFrameFormatIF2,              /**< Frame Format is AMR Interface
+                                                   Format 2*/
+    HW_OMX_AUDIO_AMRFrameFormatFSF,              /**< Frame Format is AMR File Storage
+                                                   Format */
+    HW_OMX_AUDIO_AMRFrameFormatRTPPayload,       /**< Frame Format is AMR Real-Time
+                                                   Transport Protocol Payload Format */
+    HW_OMX_AUDIO_AMRFrameFormatITU,              /**< Frame Format is ITU Format (added at Motorola request) */
+    HW_OMX_AUDIO_AMRFrameFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_AMRFrameFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_AMRFrameFormatMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_AMRFRAMEFORMATTYPE;
+
+
+/** AMR band mode */
+typedef enum HW_OMX_AUDIO_AMRBANDMODETYPE {
+    HW_OMX_AUDIO_AMRBandModeUnused = 0,          /**< AMRNB Mode unused / unknown */
+    HW_OMX_AUDIO_AMRBandModeNB0,                 /**< AMRNB Mode 0 =  4750 bps */
+    HW_OMX_AUDIO_AMRBandModeNB1,                 /**< AMRNB Mode 1 =  5150 bps */
+    HW_OMX_AUDIO_AMRBandModeNB2,                 /**< AMRNB Mode 2 =  5900 bps */
+    HW_OMX_AUDIO_AMRBandModeNB3,                 /**< AMRNB Mode 3 =  6700 bps */
+    HW_OMX_AUDIO_AMRBandModeNB4,                 /**< AMRNB Mode 4 =  7400 bps */
+    HW_OMX_AUDIO_AMRBandModeNB5,                 /**< AMRNB Mode 5 =  7950 bps */
+    HW_OMX_AUDIO_AMRBandModeNB6,                 /**< AMRNB Mode 6 = 10200 bps */
+    HW_OMX_AUDIO_AMRBandModeNB7,                 /**< AMRNB Mode 7 = 12200 bps */
+    HW_OMX_AUDIO_AMRBandModeWB0,                 /**< AMRWB Mode 0 =  6600 bps */
+    HW_OMX_AUDIO_AMRBandModeWB1,                 /**< AMRWB Mode 1 =  8850 bps */
+    HW_OMX_AUDIO_AMRBandModeWB2,                 /**< AMRWB Mode 2 = 12650 bps */
+    HW_OMX_AUDIO_AMRBandModeWB3,                 /**< AMRWB Mode 3 = 14250 bps */
+    HW_OMX_AUDIO_AMRBandModeWB4,                 /**< AMRWB Mode 4 = 15850 bps */
+    HW_OMX_AUDIO_AMRBandModeWB5,                 /**< AMRWB Mode 5 = 18250 bps */
+    HW_OMX_AUDIO_AMRBandModeWB6,                 /**< AMRWB Mode 6 = 19850 bps */
+    HW_OMX_AUDIO_AMRBandModeWB7,                 /**< AMRWB Mode 7 = 23050 bps */
+    HW_OMX_AUDIO_AMRBandModeWB8,                 /**< AMRWB Mode 8 = 23850 bps */
+    HW_OMX_AUDIO_AMRBandModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_AMRBandModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_AMRBandModeMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_AMRBANDMODETYPE;
+
+
+/** AMR Discontinuous Transmission mode */
+typedef enum HW_OMX_AUDIO_AMRDTXMODETYPE {
+    HW_OMX_AUDIO_AMRDTXModeOff = 0,        /**< AMR Discontinuous Transmission Mode is disabled */
+    HW_OMX_AUDIO_AMRDTXModeOnVAD1,         /**< AMR Discontinuous Transmission Mode using
+                                             Voice Activity Detector 1 (VAD1) is enabled */
+    HW_OMX_AUDIO_AMRDTXModeOnVAD2,         /**< AMR Discontinuous Transmission Mode using
+                                             Voice Activity Detector 2 (VAD2) is enabled */
+    HW_OMX_AUDIO_AMRDTXModeOnAuto,         /**< The codec will automatically select between
+                                             Off, VAD1 or VAD2 modes */
+
+    HW_OMX_AUDIO_AMRDTXasEFR,             /**< DTX as EFR instead of AMR standard (3GPP 26.101, frame type =8,9,10) */
+
+    HW_OMX_AUDIO_AMRDTXModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_AMRDTXModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_AMRDTXModeMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_AMRDTXMODETYPE;
+
+
+/** AMR params */
+typedef struct HW_OMX_AUDIO_PARAM_AMRTYPE {
+    HW_OMX_U32 nSize;                          /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;               /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;                     /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;                      /**< Number of channels */
+    HW_OMX_U32 nBitRate;                       /**< Bit rate read only field */
+    HW_OMX_AUDIO_AMRBANDMODETYPE eAMRBandMode; /**< AMR Band Mode enumeration */
+    HW_OMX_AUDIO_AMRDTXMODETYPE  eAMRDTXMode;  /**< AMR DTX Mode enumeration */
+    HW_OMX_AUDIO_AMRFRAMEFORMATTYPE eAMRFrameFormat; /**< AMR frame format enumeration */
+} HW_OMX_AUDIO_PARAM_AMRTYPE;
+
+
+/** GSM_FR (ETSI 06.10, 3GPP 46.010) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_GSMFRTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    HW_OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} HW_OMX_AUDIO_PARAM_GSMFRTYPE;
+
+
+/** GSM-HR (ETSI 06.20, 3GPP 46.020) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_GSMHRTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    HW_OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} HW_OMX_AUDIO_PARAM_GSMHRTYPE;
+
+
+/** GSM-EFR (ETSI 06.60, 3GPP 46.060) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_GSMEFRTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_BOOL bDTX;            /**< Enable Discontinuous Transmisssion */
+    HW_OMX_BOOL bHiPassFilter;   /**< Enable High Pass Filter */
+} HW_OMX_AUDIO_PARAM_GSMEFRTYPE;
+
+
+/** TDMA FR (TIA/EIA-136-420, VSELP 7.95kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_TDMAFRTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    HW_OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} HW_OMX_AUDIO_PARAM_TDMAFRTYPE;
+
+
+/** TDMA EFR (TIA/EIA-136-410, ACELP 7.4kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_TDMAEFRTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    HW_OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} HW_OMX_AUDIO_PARAM_TDMAEFRTYPE;
+
+
+/** PDC FR ( RCR-27, VSELP 6.7kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_PDCFRTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    HW_OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} HW_OMX_AUDIO_PARAM_PDCFRTYPE;
+
+
+/** PDC EFR ( RCR-27, ACELP 6.7kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_PDCEFRTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    HW_OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} HW_OMX_AUDIO_PARAM_PDCEFRTYPE;
+
+/** PDC HR ( RCR-27, PSI-CELP 3.45kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_PDCHRTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_BOOL bDTX;                /**< Enable Discontinuous Transmisssion */
+    HW_OMX_BOOL bHiPassFilter;       /**< Enable High Pass Filter */
+} HW_OMX_AUDIO_PARAM_PDCHRTYPE;
+
+
+/** CDMA Rate types */
+typedef enum HW_OMX_AUDIO_CDMARATETYPE {
+    HW_OMX_AUDIO_CDMARateBlank = 0,          /**< CDMA encoded frame is blank */
+    HW_OMX_AUDIO_CDMARateFull,               /**< CDMA encoded frame in full rate */
+    HW_OMX_AUDIO_CDMARateHalf,               /**< CDMA encoded frame in half rate */
+    HW_OMX_AUDIO_CDMARateQuarter,            /**< CDMA encoded frame in quarter rate */
+    HW_OMX_AUDIO_CDMARateEighth,             /**< CDMA encoded frame in eighth rate (DTX)*/
+    HW_OMX_AUDIO_CDMARateErasure,            /**< CDMA erasure frame */
+    HW_OMX_AUDIO_CDMARateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_CDMARateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_CDMARateMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_CDMARATETYPE;
+
+
+/** QCELP8 (TIA/EIA-96, up to 8kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_QCELP8TYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_U32 nBitRate;             /**< Bit rate of the input data.  Use 0 for variable
+                                       rate or unknown bit rates */
+    HW_OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    HW_OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    HW_OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} HW_OMX_AUDIO_PARAM_QCELP8TYPE;
+
+
+/** QCELP13 ( CDMA, EIA/TIA-733, 13.3kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_QCELP13TYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    HW_OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    HW_OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+} HW_OMX_AUDIO_PARAM_QCELP13TYPE;
+
+
+/** EVRC ( CDMA, EIA/TIA-127, RCELP up to 8.55kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_EVRCTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_AUDIO_CDMARATETYPE eCDMARate; /**< actual Frame rate */
+    HW_OMX_BOOL bRATE_REDUCon;       /**< RATE_REDUCtion is requested for this frame */
+    HW_OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 */
+    HW_OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 */
+    HW_OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter */
+    HW_OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    HW_OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter */
+} HW_OMX_AUDIO_PARAM_EVRCTYPE;
+
+
+/** SMV ( up to 8.55kbps coder) stream format parameters */
+typedef struct HW_OMX_AUDIO_PARAM_SMVTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;            /**< Number of channels in the data stream (not
+                                       necessarily the same as the number of channels
+                                       to be rendered. */
+    HW_OMX_AUDIO_CDMARATETYPE eCDMARate; /**< Frame rate */
+    HW_OMX_BOOL bRATE_REDUCon;           /**< RATE_REDUCtion is requested for this frame */
+    HW_OMX_U32 nMinBitRate;          /**< minmal rate for the encoder = 1,2,3,4, default = 1 ??*/
+    HW_OMX_U32 nMaxBitRate;          /**< maximal rate for the encoder = 1,2,3,4, default = 4 ??*/
+    HW_OMX_BOOL bHiPassFilter;       /**< Enable encoder's High Pass Filter ??*/
+    HW_OMX_BOOL bNoiseSuppressor;    /**< Enable encoder's noise suppressor pre-processing */
+    HW_OMX_BOOL bPostFilter;         /**< Enable decoder's post Filter ??*/
+} HW_OMX_AUDIO_PARAM_SMVTYPE;
+
+
+/** MIDI Format
+ * @ingroup midi
+ */
+typedef enum HW_OMX_AUDIO_MIDIFORMATTYPE
+{
+    HW_OMX_AUDIO_MIDIFormatUnknown = 0, /**< MIDI Format unknown or don't care */
+    HW_OMX_AUDIO_MIDIFormatSMF0,        /**< Standard MIDI File Type 0 */
+    HW_OMX_AUDIO_MIDIFormatSMF1,        /**< Standard MIDI File Type 1 */
+    HW_OMX_AUDIO_MIDIFormatSMF2,        /**< Standard MIDI File Type 2 */
+    HW_OMX_AUDIO_MIDIFormatSPMIDI,      /**< SP-MIDI */
+    HW_OMX_AUDIO_MIDIFormatXMF0,        /**< eXtensible Music Format type 0 */
+    HW_OMX_AUDIO_MIDIFormatXMF1,        /**< eXtensible Music Format type 1 */
+    HW_OMX_AUDIO_MIDIFormatMobileXMF,   /**< Mobile XMF (eXtensible Music Format type 2) */
+    HW_OMX_AUDIO_MIDIFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_MIDIFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_MIDIFormatMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_MIDIFORMATTYPE;
+
+
+/** MIDI params
+ * @ingroup midi
+ */
+typedef struct HW_OMX_AUDIO_PARAM_MIDITYPE {
+    HW_OMX_U32 nSize;                 /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    HW_OMX_U32 nFileSize;             /**< size of the MIDI file in bytes, where the entire
+                                        MIDI file passed in, otherwise if 0x0, the MIDI data
+                                        is merged and streamed (instead of passed as an
+                                        entire MIDI file) */
+    HW_OMX_BU32 sMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic
+                                        voices. A value of zero indicates that the default
+                                        polyphony of the device is used  */
+    HW_OMX_BOOL bLoadDefaultSound;    /**< Whether to load default sound
+                                        bank at initialization */
+    HW_OMX_AUDIO_MIDIFORMATTYPE eMidiFormat; /**< Version of the MIDI file */
+} HW_OMX_AUDIO_PARAM_MIDITYPE;
+
+
+/** Type of the MIDI sound bank
+ * @ingroup midi
+ */
+typedef enum HW_OMX_AUDIO_MIDISOUNDBANKTYPE {
+    HW_OMX_AUDIO_MIDISoundBankUnused = 0,           /**< unused/unknown soundbank type */
+    HW_OMX_AUDIO_MIDISoundBankDLS1,                 /**< DLS version 1 */
+    HW_OMX_AUDIO_MIDISoundBankDLS2,                 /**< DLS version 2 */
+    HW_OMX_AUDIO_MIDISoundBankMobileDLSBase,        /**< Mobile DLS, using the base functionality */
+    HW_OMX_AUDIO_MIDISoundBankMobileDLSPlusOptions, /**< Mobile DLS, using the specification-defined optional feature set */
+    HW_OMX_AUDIO_MIDISoundBankKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_MIDISoundBankVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_MIDISoundBankMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_MIDISOUNDBANKTYPE;
+
+
+/** Bank Layout describes how bank MSB & LSB are used in the DLS instrument definitions sound bank
+ * @ingroup midi
+ */
+typedef enum HW_OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE {
+   HW_OMX_AUDIO_MIDISoundBankLayoutUnused = 0,   /**< unused/unknown soundbank type */
+   HW_OMX_AUDIO_MIDISoundBankLayoutGM,           /**< GS layout (based on bank MSB 0x00) */
+   HW_OMX_AUDIO_MIDISoundBankLayoutGM2,          /**< General MIDI 2 layout (using MSB 0x78/0x79, LSB 0x00) */
+   HW_OMX_AUDIO_MIDISoundBankLayoutUser,         /**< Does not conform to any bank numbering standards */
+   HW_OMX_AUDIO_MIDISoundBankLayoutKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+   HW_OMX_AUDIO_MIDISoundBankLayoutVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   HW_OMX_AUDIO_MIDISoundBankLayoutMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE;
+
+
+/** MIDI params to load/unload user soundbank
+ * @ingroup midi
+ */
+typedef struct HW_OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_U32 nDLSIndex;        /**< DLS file index to be loaded */
+    HW_OMX_U32 nDLSSize;         /**< Size in bytes */
+    HW_OMX_PTR pDLSData;         /**< Pointer to DLS file data */
+    HW_OMX_AUDIO_MIDISOUNDBANKTYPE eMidiSoundBank;   /**< Midi sound bank type enumeration */
+    HW_OMX_AUDIO_MIDISOUNDBANKLAYOUTTYPE eMidiSoundBankLayout; /**< Midi sound bank layout enumeration */
+} HW_OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE;
+
+
+/** Structure for Live MIDI events and MIP messages.
+ * (MIP = Maximum Instantaneous Polyphony; part of the SP-MIDI standard.)
+ * @ingroup midi
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    HW_OMX_U32 nMidiEventSize;   /**< Size of immediate MIDI events or MIP message in bytes  */
+    HW_OMX_U8 nMidiEvents[1];    /**< MIDI event array to be rendered immediately, or an
+                                   array for the MIP message buffer, where the size is
+                                   indicated by nMidiEventSize */
+} HW_OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE;
+
+
+/** MIDI sound bank/ program pair in a given channel
+ * @ingroup midi
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< Port that this structure applies to */
+    HW_OMX_U32 nChannel;           /**< Valid channel values range from 1 to 16 */
+    HW_OMX_U16 nIDProgram;         /**< Valid program ID range is 1 to 128 */
+    HW_OMX_U16 nIDSoundBank;       /**< Sound bank ID */
+    HW_OMX_U32 nUserSoundBankIndex;/**< User soundbank index, easier to access soundbanks
+                                     by index if multiple banks are present */
+} HW_OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE;
+
+
+/** MIDI control
+ * @ingroup midi
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_MIDICONTROLTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_BS32 sPitchTransposition; /**< Pitch transposition in semitones, stored as Q22.10
+                                       format based on JAVA MMAPI (JSR-135) requirement */
+    HW_OMX_BU32 sPlayBackRate;       /**< Relative playback rate, stored as Q14.17 fixed-point
+                                       number based on JSR-135 requirement */
+    HW_OMX_BU32 sTempo ;             /**< Tempo in beats per minute (BPM), stored as Q22.10
+                                       fixed-point number based on JSR-135 requirement */
+    HW_OMX_U32 nMaxPolyphony;        /**< Specifies the maximum simultaneous polyphonic
+                                       voices. A value of zero indicates that the default
+                                       polyphony of the device is used  */
+    HW_OMX_U32 nNumRepeat;           /**< Number of times to repeat playback */
+    HW_OMX_U32 nStopTime;            /**< Time in milliseconds to indicate when playback
+                                       will stop automatically.  Set to zero if not used */
+    HW_OMX_U16 nChannelMuteMask;     /**< 16 bit mask for channel mute status */
+    HW_OMX_U16 nChannelSoloMask;     /**< 16 bit mask for channel solo status */
+    HW_OMX_U32 nTrack0031MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 0-31 */
+    HW_OMX_U32 nTrack3263MuteMask;   /**< 32 bit mask for track mute status. Note: This is for tracks 32-63 */
+    HW_OMX_U32 nTrack0031SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 0-31 */
+    HW_OMX_U32 nTrack3263SoloMask;   /**< 32 bit mask for track solo status. Note: This is for tracks 32-63 */
+
+} HW_OMX_AUDIO_CONFIG_MIDICONTROLTYPE;
+
+
+/** MIDI Playback States
+ * @ingroup midi
+ */
+typedef enum HW_OMX_AUDIO_MIDIPLAYBACKSTATETYPE {
+  HW_OMX_AUDIO_MIDIPlayBackStateUnknown = 0,      /**< Unknown state or state does not map to
+                                                    other defined states */
+  HW_OMX_AUDIO_MIDIPlayBackStateClosedEngaged,    /**< No MIDI resource is currently open.
+                                                    The MIDI engine is currently processing
+                                                    MIDI events. */
+  HW_OMX_AUDIO_MIDIPlayBackStateParsing,          /**< A MIDI resource is open and is being
+                                                    primed. The MIDI engine is currently
+                                                    processing MIDI events. */
+  HW_OMX_AUDIO_MIDIPlayBackStateOpenEngaged,      /**< A MIDI resource is open and primed but
+                                                    not playing. The MIDI engine is currently
+                                                    processing MIDI events. The transition to
+                                                    this state is only possible from the
+                                                    HW_OMX_AUDIO_MIDIPlayBackStatePlaying state,
+                                                    when the 'playback head' reaches the end
+                                                    of media data or the playback stops due
+                                                    to stop time set.*/
+  HW_OMX_AUDIO_MIDIPlayBackStatePlaying,          /**< A MIDI resource is open and currently
+                                                    playing. The MIDI engine is currently
+                                                    processing MIDI events.*/
+  HW_OMX_AUDIO_MIDIPlayBackStatePlayingPartially, /**< Best-effort playback due to SP-MIDI/DLS
+                                                    resource constraints */
+  HW_OMX_AUDIO_MIDIPlayBackStatePlayingSilently,  /**< Due to system resource constraints and
+                                                    SP-MIDI content constraints, there is
+                                                    no audible MIDI content during playback
+                                                    currently. The situation may change if
+                                                    resources are freed later.*/
+  HW_OMX_AUDIO_MIDIPlayBackStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  HW_OMX_AUDIO_MIDIPlayBackStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+  HW_OMX_AUDIO_MIDIPlayBackStateMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_MIDIPLAYBACKSTATETYPE;
+
+
+/** MIDI status
+ * @ingroup midi
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_MIDISTATUSTYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    HW_OMX_U16 nNumTracks;         /**< Number of MIDI tracks in the file, read only field.
+                                     NOTE: May not return a meaningful value until the entire
+                                     file is parsed and buffered.  */
+    HW_OMX_U32 nDuration;          /**< The length of the currently open MIDI resource
+                                     in milliseconds. NOTE: May not return a meaningful value
+                                     until the entire file is parsed and buffered.  */
+    HW_OMX_U32 nPosition;          /**< Current Position of the MIDI resource being played
+                                     in milliseconds */
+    HW_OMX_BOOL bVibra;            /**< Does Vibra track exist? NOTE: May not return a meaningful
+                                     value until the entire file is parsed and buffered. */
+    HW_OMX_U32 nNumMetaEvents;     /**< Total number of MIDI Meta Events in the currently
+                                     open MIDI resource. NOTE: May not return a meaningful value
+                                     until the entire file is parsed and buffered.  */
+    HW_OMX_U32 nNumActiveVoices;   /**< Number of active voices in the currently playing
+                                     MIDI resource. NOTE: May not return a meaningful value until
+                                     the entire file is parsed and buffered. */
+    HW_OMX_AUDIO_MIDIPLAYBACKSTATETYPE eMIDIPlayBackState;  /**< MIDI playback state enumeration, read only field */
+} HW_OMX_AUDIO_CONFIG_MIDISTATUSTYPE;
+
+
+/** MIDI Meta Event structure one per Meta Event.
+ *  MIDI Meta Events are like audio metadata, except that they are interspersed
+ *  with the MIDI content throughout the file and are not localized in the header.
+ *  As such, it is necessary to retrieve information about these Meta Events from
+ *  the engine, as it encounters these Meta Events within the MIDI content.
+ *  For example, SMF files can have up to 14 types of MIDI Meta Events (copyright,
+ *  author, default tempo, etc.) scattered throughout the file.
+ *  @ingroup midi
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE{
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_U32 nIndex;           /**< Index of Meta Event */
+    HW_OMX_U8 nMetaEventType;    /**< Meta Event Type, 7bits (i.e. 0 - 127) */
+    HW_OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */
+    HW_OMX_U32 nTrack;           /**< track number for the meta event */
+    HW_OMX_U32 nPosition;        /**< Position of the meta-event in milliseconds */
+} HW_OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE;
+
+
+/** MIDI Meta Event Data structure - one per Meta Event.
+ * @ingroup midi
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE{
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_U32 nIndex;           /**< Index of Meta Event */
+    HW_OMX_U32 nMetaEventSize;   /**< size of the Meta Event in bytes */
+    HW_OMX_U8 nData[1];          /**< array of one or more bytes of meta data
+                                   as indicated by the nMetaEventSize field */
+} HW_OMX_AUDIO_CONFIG__MIDIMETAEVENTDATATYPE;
+
+
+/** Audio Volume adjustment for a port */
+typedef struct HW_OMX_AUDIO_CONFIG_VOLUMETYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's volume.  Select the
+                                     output port to adjust the master
+                                     volume. */
+    HW_OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100)
+                                     or logarithmic scale (mB) */
+    HW_OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.  The values
+                                     for volume are in mB (millibels = 1/100 dB) relative
+                                     to a gain of 1 (e.g. the output is the same as the
+                                     input level).  Values are in mB from nMax
+                                     (maximum volume) to nMin mB (typically negative).
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+} HW_OMX_AUDIO_CONFIG_VOLUMETYPE;
+
+
+/** Audio Volume adjustment for a channel */
+typedef struct HW_OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's volume.  Select the
+                                     output port to adjust the master
+                                     volume. */
+    HW_OMX_U32 nChannel;           /**< channel to select from 0 to N-1,
+                                     using HW_OMX_ALL to apply volume settings
+                                     to all channels */
+    HW_OMX_BOOL bLinear;           /**< Is the volume to be set in linear (0.100) or
+                                     logarithmic scale (mB) */
+    HW_OMX_BS32 sVolume;           /**< Volume linear setting in the 0..100 range, OR
+                                     Volume logarithmic setting for this port.
+                                     The values for volume are in mB
+                                     (millibels = 1/100 dB) relative to a gain
+                                     of 1 (e.g. the output is the same as the
+                                     input level).  Values are in mB from nMax
+                                     (maximum volume) to nMin mB (typically negative).
+                                     Since the volume is "voltage"
+                                     and not a "power", it takes a setting of
+                                     -600 mB to decrease the volume by 1/2.  If
+                                     a component cannot accurately set the
+                                     volume to the requested value, it must
+                                     set the volume to the closest value BELOW
+                                     the requested value.  When getting the
+                                     volume setting, the current actual volume
+                                     must be returned. */
+    HW_OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */
+} HW_OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE;
+
+
+/** Audio balance setting */
+typedef struct HW_OMX_AUDIO_CONFIG_BALANCETYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's balance.  Select the
+                                     output port to adjust the master
+                                     balance. */
+    HW_OMX_S32 nBalance;           /**< balance setting for this port
+                                     (-100 to 100, where -100 indicates
+                                     all left, and no right */
+} HW_OMX_AUDIO_CONFIG_BALANCETYPE;
+
+
+/** Audio Port mute */
+typedef struct HW_OMX_AUDIO_CONFIG_MUTETYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< Port index indicating which port to
+                                     set.  Select the input port to set
+                                     just that port's mute.  Select the
+                                     output port to adjust the master
+                                     mute. */
+    HW_OMX_BOOL bMute;             /**< Mute setting for this port */
+} HW_OMX_AUDIO_CONFIG_MUTETYPE;
+
+
+/** Audio Channel mute */
+typedef struct HW_OMX_AUDIO_CONFIG_CHANNELMUTETYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    HW_OMX_U32 nChannel;           /**< channel to select from 0 to N-1,
+                                     using HW_OMX_ALL to apply mute settings
+                                     to all channels */
+    HW_OMX_BOOL bMute;             /**< Mute setting for this channel */
+    HW_OMX_BOOL bIsMIDI;           /**< TRUE if nChannel refers to a MIDI channel,
+                                     FALSE otherwise */
+} HW_OMX_AUDIO_CONFIG_CHANNELMUTETYPE;
+
+
+
+/** Enable / Disable for loudness control, which boosts bass and to a
+ *  smaller extent high end frequencies to compensate for hearing
+ *  ability at the extreme ends of the audio spectrum
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_LOUDNESSTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_BOOL bLoudness;        /**< Enable/disable for loudness */
+} HW_OMX_AUDIO_CONFIG_LOUDNESSTYPE;
+
+
+/** Enable / Disable for bass, which controls low frequencies
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_BASSTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_BOOL bEnable;          /**< Enable/disable for bass control */
+    HW_OMX_S32 nBass;             /**< bass setting for the port, as a
+                                    continuous value from -100 to 100
+                                    (0 means no change in bass level)*/
+} HW_OMX_AUDIO_CONFIG_BASSTYPE;
+
+
+/** Enable / Disable for treble, which controls high frequencies tones
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_TREBLETYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_BOOL bEnable;          /**< Enable/disable for treble control */
+    HW_OMX_S32  nTreble;          /**< treble setting for the port, as a
+                                    continuous value from -100 to 100
+                                    (0 means no change in treble level) */
+} HW_OMX_AUDIO_CONFIG_TREBLETYPE;
+
+
+/** An equalizer is typically used for two reasons: to compensate for an
+ *  sub-optimal frequency response of a system to make it sound more natural
+ *  or to create intentionally some unnatural coloring to the sound to create
+ *  an effect.
+ *  @ingroup effects
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_EQUALIZERTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_BOOL bEnable;          /**< Enable/disable for equalizer */
+    HW_OMX_BU32 sBandIndex;       /**< Band number to be set.  Upper Limit is
+                                    N-1, where N is the number of bands, lower limit is 0 */
+    HW_OMX_BU32 sCenterFreq;      /**< Center frequecies in Hz.  This is a
+                                    read only element and is used to determine
+                                    the lower, center and upper frequency of
+                                    this band.  */
+    HW_OMX_BS32 sBandLevel;       /**< band level in millibels */
+} HW_OMX_AUDIO_CONFIG_EQUALIZERTYPE;
+
+
+/** Stereo widening mode type
+ * @ingroup effects
+ */
+typedef enum HW_OMX_AUDIO_STEREOWIDENINGTYPE {
+    HW_OMX_AUDIO_StereoWideningHeadphones,    /**< Stereo widening for loudspeakers */
+    HW_OMX_AUDIO_StereoWideningLoudspeakers,  /**< Stereo widening for closely spaced loudspeakers */
+    HW_OMX_AUDIO_StereoWideningKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_AUDIO_StereoWideningVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_AUDIO_StereoWideningMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_STEREOWIDENINGTYPE;
+
+
+/** Control for stereo widening, which is a special 2-channel
+ *  case of the audio virtualizer effect. For example, for 5.1-channel
+ *  output, it translates to virtual surround sound.
+ * @ingroup effects
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_BOOL bEnable;          /**< Enable/disable for stereo widening control */
+    HW_OMX_AUDIO_STEREOWIDENINGTYPE eWideningType; /**< Stereo widening algorithm type */
+    HW_OMX_U32  nStereoWidening;  /**< stereo widening setting for the port,
+                                    as a continuous value from 0 to 100  */
+} HW_OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE;
+
+
+/** The chorus effect (or ``choralizer'') is any signal processor which makes
+ *  one sound source (such as a voice) sound like many such sources singing
+ *  (or playing) in unison. Since performance in unison is never exact, chorus
+ *  effects simulate this by making independently modified copies of the input
+ *  signal. Modifications may include (1) delay, (2) frequency shift, and
+ *  (3) amplitude modulation.
+ * @ingroup effects
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_CHORUSTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_BOOL bEnable;          /**< Enable/disable for chorus */
+    HW_OMX_BU32 sDelay;           /**< average delay in milliseconds */
+    HW_OMX_BU32 sModulationRate;  /**< rate of modulation in millihertz */
+    HW_OMX_U32 nModulationDepth;  /**< depth of modulation as a percentage of
+                                    delay (i.e. 0 to 100) */
+    HW_OMX_BU32 nFeedback;        /**< Feedback from chorus output to input in percentage */
+} HW_OMX_AUDIO_CONFIG_CHORUSTYPE;
+
+
+/** Reverberation is part of the reflected sound that follows the early
+ *  reflections. In a typical room, this consists of a dense succession of
+ *  echoes whose energy decays exponentially. The reverberation effect structure
+ *  as defined here includes both (early) reflections as well as (late) reverberations.
+ * @ingroup effects
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_REVERBERATIONTYPE {
+    HW_OMX_U32 nSize;                /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;     /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;           /**< port that this structure applies to */
+    HW_OMX_BOOL bEnable;             /**< Enable/disable for reverberation control */
+    HW_OMX_BS32 sRoomLevel;          /**< Intensity level for the whole room effect
+                                       (i.e. both early reflections and late
+                                       reverberation) in millibels */
+    HW_OMX_BS32 sRoomHighFreqLevel;  /**< Attenuation at high frequencies
+                                       relative to the intensity at low
+                                       frequencies in millibels */
+    HW_OMX_BS32 sReflectionsLevel;   /**< Intensity level of early reflections
+                                       (relative to room value), in millibels */
+    HW_OMX_BU32 sReflectionsDelay;   /**< Delay time of the first reflection relative
+                                       to the direct path, in milliseconds */
+    HW_OMX_BS32 sReverbLevel;        /**< Intensity level of late reverberation
+                                       relative to room level, in millibels */
+    HW_OMX_BU32 sReverbDelay;        /**< Time delay from the first early reflection
+                                       to the beginning of the late reverberation
+                                       section, in milliseconds */
+    HW_OMX_BU32 sDecayTime;          /**< Late reverberation decay time at low
+                                       frequencies, in milliseconds */
+    HW_OMX_BU32 nDecayHighFreqRatio; /**< Ratio of high frequency decay time relative
+                                       to low frequency decay time in percent  */
+    HW_OMX_U32 nDensity;             /**< Modal density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    HW_OMX_U32 nDiffusion;           /**< Echo density in the late reverberation decay,
+                                       in percent (i.e. 0 - 100) */
+    HW_OMX_BU32 sReferenceHighFreq;  /**< Reference high frequency in Hertz. This is
+                                       the frequency used as the reference for all
+                                       the high-frequency settings above */
+
+} HW_OMX_AUDIO_CONFIG_REVERBERATIONTYPE;
+
+
+/** Possible settings for the Echo Cancelation structure to use
+ * @ingroup effects
+ */
+typedef enum HW_OMX_AUDIO_ECHOCANTYPE {
+   HW_OMX_AUDIO_EchoCanOff = 0,    /**< Echo Cancellation is disabled */
+   HW_OMX_AUDIO_EchoCanNormal,     /**< Echo Cancellation normal operation -
+                                     echo from plastics and face */
+   HW_OMX_AUDIO_EchoCanHFree,      /**< Echo Cancellation optimized for
+                                     Hands Free operation */
+   HW_OMX_AUDIO_EchoCanCarKit,    /**< Echo Cancellation optimized for
+                                     Car Kit (longer echo) */
+   HW_OMX_AUDIO_EchoCanKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+   HW_OMX_AUDIO_EchoCanVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   HW_OMX_AUDIO_EchoCanMax = 0x7FFFFFFF
+} HW_OMX_AUDIO_ECHOCANTYPE;
+
+
+/** Enable / Disable for echo cancelation, which removes undesired echo's
+ *  from the audio
+ * @ingroup effects
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_AUDIO_ECHOCANTYPE eEchoCancelation; /**< Echo cancelation settings */
+} HW_OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE;
+
+
+/** Enable / Disable for noise reduction, which undesired noise from
+ * the audio
+ * @ingroup effects
+ */
+typedef struct HW_OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;        /**< port that this structure applies to */
+    HW_OMX_BOOL bNoiseReduction;  /**< Enable/disable for noise reduction */
+} HW_OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_AudioExt.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_AudioExt.h
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2010 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** HW_OMX_AudioExt.h - OpenMax IL version 1.1.2
+ * The HW_OMX_AudioExt header file contains extensions to the
+ * definitions used by both the application and the component to
+ * access video items.
+ */
+
+#ifndef HW_OMX_AudioExt_h
+#define HW_OMX_AudioExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include "HW_OMX_Core.h"
+
+#define HW_OMX_AUDIO_AACToolAndroidSSBR (HW_OMX_AUDIO_AACToolVendor << 0) /**< SSBR: MPEG-4 Single-rate (downsampled) Spectral Band Replication tool allowed or active */
+#define HW_OMX_AUDIO_AACToolAndroidDSBR (HW_OMX_AUDIO_AACToolVendor << 1) /**< DSBR: MPEG-4 Dual-rate Spectral Band Replication tool allowed or active */
+
+typedef enum HW_OMX_AUDIO_CODINGEXTTYPE {
+    HW_OMX_AUDIO_CodingAndroidUnused = HW_OMX_AUDIO_CodingKhronosExtensions + 0x00100000,
+    HW_OMX_AUDIO_CodingAndroidAC3,         /**< AC3 encoded data */
+    HW_OMX_AUDIO_CodingAndroidOPUS,        /**< OPUS encoded data */
+    HW_OMX_AUDIO_CodingAndroidEAC3,        /**< EAC3 encoded data */
+    HW_OMX_AUDIO_CodingAndroidAC4,         /**< AC4 encoded data */
+} HW_OMX_AUDIO_CODINGEXTTYPE;
+
+typedef struct HW_OMX_AUDIO_PARAM_ANDROID_AC3TYPE {
+    HW_OMX_U32 nSize;                 /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;             /**< Number of channels */
+    HW_OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+} HW_OMX_AUDIO_PARAM_ANDROID_AC3TYPE;
+
+typedef struct HW_OMX_AUDIO_PARAM_ANDROID_EAC3TYPE {
+    HW_OMX_U32 nSize;                 /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;             /**< Number of channels */
+    HW_OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+} HW_OMX_AUDIO_PARAM_ANDROID_EAC3TYPE;
+
+typedef struct HW_OMX_AUDIO_PARAM_ANDROID_AC4TYPE {
+    HW_OMX_U32 nSize;                 /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;            /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;             /**< Number of channels */
+    HW_OMX_U32 nSampleRate;           /**< Sampling rate of the source data.  Use 0 for
+                                        variable or unknown sampling rate. */
+} HW_OMX_AUDIO_PARAM_ANDROID_AC4TYPE;
+
+typedef struct HW_OMX_AUDIO_PARAM_ANDROID_OPUSTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< port that this structure applies to */
+    HW_OMX_U32 nChannels;        /**< Number of channels */
+    HW_OMX_U32 nBitRate;         /**< Bit rate of the encoded data data.  Use 0 for variable
+                                   rate or unknown bit rates. Encoding is set to the
+                                   bitrate closest to specified  value (in bps) */
+    HW_OMX_U32 nSampleRate;      /**< Sampling rate of the source data.  Use 0 for
+                                   variable or unknown sampling rate. */
+    HW_OMX_U32 nAudioBandWidth;  /**< Audio band width (in Hz) to which an encoder should
+                                   limit the audio signal. Use 0 to let encoder decide */
+} HW_OMX_AUDIO_PARAM_ANDROID_OPUSTYPE;
+
+/** deprecated. use HW_OMX_AUDIO_PARAM_ANDROID_AACDRCPRESENTATIONTYPE */
+typedef struct HW_OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_S32 nMaxOutputChannels;    /**< Maximum channel count to be output, -1 if unspecified, 0 if downmixing disabled */
+    HW_OMX_S32 nDrcCut;               /**< The DRC attenuation factor, between 0 and 127, -1 if unspecified */
+    HW_OMX_S32 nDrcBoost;             /**< The DRC amplification factor, between 0 and 127, -1 if unspecified */
+    HW_OMX_S32 nHeavyCompression;     /**< 0 for light compression, 1 for heavy compression, -1 if unspecified */
+    HW_OMX_S32 nTargetReferenceLevel; /**< Target reference level, between 0 and 127, -1 if unspecified */
+    HW_OMX_S32 nEncodedTargetLevel;   /**< Target reference level assumed at the encoder, between 0 and 127, -1 if unspecified */
+    HW_OMX_S32 nPCMLimiterEnable;     /**< Signal level limiting, 0 for disable, 1 for enable, -1 if unspecified */
+} HW_OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE;
+
+typedef struct HW_OMX_AUDIO_PARAM_ANDROID_AACDRCPRESENTATIONTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_S32 nMaxOutputChannels;    /**< Maximum channel count to be output, -1 if unspecified, 0 if downmixing disabled */
+    HW_OMX_S32 nDrcCut;               /**< The DRC attenuation factor, between 0 and 127, -1 if unspecified */
+    HW_OMX_S32 nDrcBoost;             /**< The DRC amplification factor, between 0 and 127, -1 if unspecified */
+    HW_OMX_S32 nHeavyCompression;     /**< 0 for light compression, 1 for heavy compression, -1 if unspecified */
+    HW_OMX_S32 nTargetReferenceLevel; /**< Target reference level, between 0 and 127, -1 if unspecified */
+    HW_OMX_S32 nEncodedTargetLevel;   /**< Target reference level assumed at the encoder, between 0 and 127, -1 if unspecified */
+    HW_OMX_S32 nPCMLimiterEnable;     /**< Signal level limiting, 0 for disable, 1 for enable, -1 if unspecified */
+    HW_OMX_S32 nDrcEffectType;        /**< MPEG-D DRC effect type, between -1 and 6, -2 if unspecified */
+} HW_OMX_AUDIO_PARAM_ANDROID_AACDRCPRESENTATIONTYPE;
+
+typedef struct HW_OMX_AUDIO_PARAM_ANDROID_PROFILETYPE {
+   HW_OMX_U32 nSize;
+   HW_OMX_VERSIONTYPE nVersion;
+   HW_OMX_U32 nPortIndex;
+   HW_OMX_U32 eProfile;      /**< type is HW_OMX_AUDIO_AACPROFILETYPE or HW_OMX_AUDIO_WMAPROFILETYPE
+                                 depending on context */
+   HW_OMX_U32 nProfileIndex; /**< Used to query for individual profile support information */
+} HW_OMX_AUDIO_PARAM_ANDROID_PROFILETYPE;
+
+typedef struct HW_OMX_AUDIO_CONFIG_ANDROID_AUDIOPRESENTATION {
+    HW_OMX_U32 nSize;                 /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    HW_OMX_S32 nPresentationId;       /**< presentation id */
+    HW_OMX_S32 nProgramId;            /**< program id */
+} HW_OMX_AUDIO_CONFIG_ANDROID_AUDIOPRESENTATION;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* HW_OMX_AudioExt_h */
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_Component.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_Component.h
@@ -0,0 +1,596 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** HW_OMX_Component.h - OpenMax IL version 1.1.2
+ *  The HW_OMX_Component header file contains the definitions used to define
+ *  the public interface of a component.  This header file is intended to
+ *  be used by both the application and the component.
+ */
+
+#ifndef HW_OMX_Component_h
+#define HW_OMX_Component_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+
+#include "HW_OMX_Audio.h"
+#include "HW_OMX_Video.h"
+#include "HW_OMX_Image.h"
+#include "HW_OMX_Other.h"
+
+/** @ingroup comp */
+typedef enum HW_OMX_PORTDOMAINTYPE {
+    HW_OMX_PortDomainAudio,
+    HW_OMX_PortDomainVideo,
+    HW_OMX_PortDomainImage,
+    HW_OMX_PortDomainOther,
+    HW_OMX_PortDomainKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_PortDomainVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_PortDomainMax = 0x7ffffff
+} HW_OMX_PORTDOMAINTYPE;
+
+/** @ingroup comp */
+typedef struct HW_OMX_PARAM_PORTDEFINITIONTYPE {
+    HW_OMX_U32 nSize;                 /**< Size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;            /**< Port number the structure applies to */
+    HW_OMX_DIRTYPE eDir;              /**< Direction (input or output) of this port */
+    HW_OMX_U32 nBufferCountActual;    /**< The actual number of buffers allocated on this port */
+    HW_OMX_U32 nBufferCountMin;       /**< The minimum number of buffers this port requires */
+    HW_OMX_U32 nBufferSize;           /**< Size, in bytes, for buffers to be used for this channel */
+    HW_OMX_BOOL bEnabled;             /**< Ports default to enabled and are enabled/disabled by
+                                        HW_OMX_CommandPortEnable/HW_OMX_CommandPortDisable.
+                                        When disabled a port is unpopulated. A disabled port
+                                        is not populated with buffers on a transition to IDLE. */
+    HW_OMX_BOOL bPopulated;           /**< Port is populated with all of its buffers as indicated by
+                                        nBufferCountActual. A disabled port is always unpopulated.
+                                        An enabled port is populated on a transition to HW_OMX_StateIdle
+                                        and unpopulated on a transition to loaded. */
+    HW_OMX_PORTDOMAINTYPE eDomain;    /**< Domain of the port. Determines the contents of metadata below. */
+    union {
+        HW_OMX_AUDIO_PORTDEFINITIONTYPE audio;
+        HW_OMX_VIDEO_PORTDEFINITIONTYPE video;
+        HW_OMX_IMAGE_PORTDEFINITIONTYPE image;
+        HW_OMX_OTHER_PORTDEFINITIONTYPE other;
+    } format;
+    HW_OMX_BOOL bBuffersContiguous;
+    HW_OMX_U32 nBufferAlignment;
+} HW_OMX_PARAM_PORTDEFINITIONTYPE;
+
+/** @ingroup comp */
+typedef struct HW_OMX_PARAM_U32TYPE {
+    HW_OMX_U32 nSize;                    /**< Size of this structure, in Bytes */
+    HW_OMX_VERSIONTYPE nVersion;         /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;               /**< port that this structure applies to */
+    HW_OMX_U32 nU32;                     /**< U32 value */
+} HW_OMX_PARAM_U32TYPE;
+
+/** @ingroup rpm */
+typedef enum HW_OMX_SUSPENSIONPOLICYTYPE {
+    HW_OMX_SuspensionDisabled, /**< No suspension; v1.0 behavior */
+    HW_OMX_SuspensionEnabled,  /**< Suspension allowed */
+    HW_OMX_SuspensionPolicyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_SuspensionPolicyStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_SuspensionPolicyMax = 0x7fffffff
+} HW_OMX_SUSPENSIONPOLICYTYPE;
+
+/** @ingroup rpm */
+typedef struct HW_OMX_PARAM_SUSPENSIONPOLICYTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_SUSPENSIONPOLICYTYPE ePolicy;
+} HW_OMX_PARAM_SUSPENSIONPOLICYTYPE;
+
+/** @ingroup rpm */
+typedef enum HW_OMX_SUSPENSIONTYPE {
+    HW_OMX_NotSuspended, /**< component is not suspended */
+    HW_OMX_Suspended,    /**< component is suspended */
+    HW_OMX_SuspensionKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_SuspensionVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_SuspendMax = 0x7FFFFFFF
+} HW_OMX_SUSPENSIONTYPE;
+
+/** @ingroup rpm */
+typedef struct HW_OMX_PARAM_SUSPENSIONTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_SUSPENSIONTYPE eType;
+} HW_OMX_PARAM_SUSPENSIONTYPE ;
+
+typedef struct HW_OMX_CONFIG_BOOLEANTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_BOOL bEnabled;
+} HW_OMX_CONFIG_BOOLEANTYPE;
+
+/* Parameter specifying the content uri to use. */
+/** @ingroup cp */
+typedef struct HW_OMX_PARAM_CONTENTURITYPE
+{
+    HW_OMX_U32 nSize;                      /**< size of the structure in bytes, including
+                                             actual URI name */
+    HW_OMX_VERSIONTYPE nVersion;           /**< OMX specification version information */
+    HW_OMX_U8 contentURI[1];               /**< The URI name */
+} HW_OMX_PARAM_CONTENTURITYPE;
+
+/* Parameter specifying the pipe to use. */
+/** @ingroup cp */
+typedef struct HW_OMX_PARAM_CONTENTPIPETYPE
+{
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_HANDLETYPE hPipe;       /**< The pipe handle*/
+} HW_OMX_PARAM_CONTENTPIPETYPE;
+
+/** @ingroup rpm */
+typedef struct HW_OMX_RESOURCECONCEALMENTTYPE {
+    HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+    HW_OMX_BOOL bResourceConcealmentForbidden; /**< disallow the use of resource concealment
+                                            methods (like degrading algorithm quality to
+                                            lower resource consumption or functional bypass)
+                                            on a component as a resolution to resource conflicts. */
+} HW_OMX_RESOURCECONCEALMENTTYPE;
+
+
+/** @ingroup metadata */
+typedef enum HW_OMX_METADATACHARSETTYPE {
+    HW_OMX_MetadataCharsetUnknown = 0,
+    HW_OMX_MetadataCharsetASCII,
+    HW_OMX_MetadataCharsetBinary,
+    HW_OMX_MetadataCharsetCodePage1252,
+    HW_OMX_MetadataCharsetUTF8,
+    HW_OMX_MetadataCharsetJavaConformantUTF8,
+    HW_OMX_MetadataCharsetUTF7,
+    HW_OMX_MetadataCharsetImapUTF7,
+    HW_OMX_MetadataCharsetUTF16LE,
+    HW_OMX_MetadataCharsetUTF16BE,
+    HW_OMX_MetadataCharsetGB12345,
+    HW_OMX_MetadataCharsetHZGB2312,
+    HW_OMX_MetadataCharsetGB2312,
+    HW_OMX_MetadataCharsetGB18030,
+    HW_OMX_MetadataCharsetGBK,
+    HW_OMX_MetadataCharsetBig5,
+    HW_OMX_MetadataCharsetISO88591,
+    HW_OMX_MetadataCharsetISO88592,
+    HW_OMX_MetadataCharsetISO88593,
+    HW_OMX_MetadataCharsetISO88594,
+    HW_OMX_MetadataCharsetISO88595,
+    HW_OMX_MetadataCharsetISO88596,
+    HW_OMX_MetadataCharsetISO88597,
+    HW_OMX_MetadataCharsetISO88598,
+    HW_OMX_MetadataCharsetISO88599,
+    HW_OMX_MetadataCharsetISO885910,
+    HW_OMX_MetadataCharsetISO885913,
+    HW_OMX_MetadataCharsetISO885914,
+    HW_OMX_MetadataCharsetISO885915,
+    HW_OMX_MetadataCharsetShiftJIS,
+    HW_OMX_MetadataCharsetISO2022JP,
+    HW_OMX_MetadataCharsetISO2022JP1,
+    HW_OMX_MetadataCharsetISOEUCJP,
+    HW_OMX_MetadataCharsetSMS7Bit,
+    HW_OMX_MetadataCharsetKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_MetadataCharsetVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_MetadataCharsetTypeMax= 0x7FFFFFFF
+} HW_OMX_METADATACHARSETTYPE;
+
+/** @ingroup metadata */
+typedef enum HW_OMX_METADATASCOPETYPE
+{
+    HW_OMX_MetadataScopeAllLevels,
+    HW_OMX_MetadataScopeTopLevel,
+    HW_OMX_MetadataScopePortLevel,
+    HW_OMX_MetadataScopeNodeLevel,
+    HW_OMX_MetadataScopeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_MetadataScopeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_MetadataScopeTypeMax = 0x7fffffff
+} HW_OMX_METADATASCOPETYPE;
+
+/** @ingroup metadata */
+typedef enum HW_OMX_METADATASEARCHMODETYPE
+{
+    HW_OMX_MetadataSearchValueSizeByIndex,
+    HW_OMX_MetadataSearchItemByIndex,
+    HW_OMX_MetadataSearchNextItemByKey,
+    HW_OMX_MetadataSearchKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_MetadataSearchVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_MetadataSearchTypeMax = 0x7fffffff
+} HW_OMX_METADATASEARCHMODETYPE;
+/** @ingroup metadata */
+typedef struct HW_OMX_CONFIG_METADATAITEMCOUNTTYPE
+{
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_METADATASCOPETYPE eScopeMode;
+    HW_OMX_U32 nScopeSpecifier;
+    HW_OMX_U32 nMetadataItemCount;
+} HW_OMX_CONFIG_METADATAITEMCOUNTTYPE;
+
+/** @ingroup metadata */
+typedef struct HW_OMX_CONFIG_METADATAITEMTYPE
+{
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_METADATASCOPETYPE eScopeMode;
+    HW_OMX_U32 nScopeSpecifier;
+    HW_OMX_U32 nMetadataItemIndex;
+    HW_OMX_METADATASEARCHMODETYPE eSearchMode;
+    HW_OMX_METADATACHARSETTYPE eKeyCharset;
+    HW_OMX_U8 nKeySizeUsed;
+    HW_OMX_U8 nKey[128];
+    HW_OMX_METADATACHARSETTYPE eValueCharset;
+    HW_OMX_STRING sLanguageCountry;
+    HW_OMX_U32 nValueMaxSize;
+    HW_OMX_U32 nValueSizeUsed;
+    HW_OMX_U8 nValue[1];
+} HW_OMX_CONFIG_METADATAITEMTYPE;
+
+/* @ingroup metadata */
+typedef struct HW_OMX_CONFIG_CONTAINERNODECOUNTTYPE
+{
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_BOOL bAllKeys;
+    HW_OMX_U32 nParentNodeID;
+    HW_OMX_U32 nNumNodes;
+} HW_OMX_CONFIG_CONTAINERNODECOUNTTYPE;
+
+/** @ingroup metadata */
+typedef struct HW_OMX_CONFIG_CONTAINERNODEIDTYPE
+{
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_BOOL bAllKeys;
+    HW_OMX_U32 nParentNodeID;
+    HW_OMX_U32 nNodeIndex;
+    HW_OMX_U32 nNodeID;
+    HW_OMX_STRING cNodeName;
+    HW_OMX_BOOL bIsLeafType;
+} HW_OMX_CONFIG_CONTAINERNODEIDTYPE;
+
+/** @ingroup metadata */
+typedef struct HW_OMX_PARAM_METADATAFILTERTYPE
+{
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_BOOL bAllKeys;  /* if true then this structure refers to all keys and
+                         * the three key fields below are ignored */
+    HW_OMX_METADATACHARSETTYPE eKeyCharset;
+    HW_OMX_U32 nKeySizeUsed;
+    HW_OMX_U8   nKey [128];
+    HW_OMX_U32 nLanguageCountrySizeUsed;
+    HW_OMX_U8 nLanguageCountry[128];
+    HW_OMX_BOOL bEnabled;  /* if true then key is part of filter (e.g.
+                         * retained for query later). If false then
+                         * key is not part of filter */
+} HW_OMX_PARAM_METADATAFILTERTYPE;
+
+/** The HW_OMX_HANDLETYPE structure defines the component handle.  The component
+ *  handle is used to access all of the component's public methods and also
+ *  contains pointers to the component's private data area.  The component
+ *  handle is initialized by the OMX core (with help from the component)
+ *  during the process of loading the component.  After the component is
+ *  successfully loaded, the application can safely access any of the
+ *  component's public functions (although some may return an error because
+ *  the state is inappropriate for the access).
+ *
+ *  @ingroup comp
+ */
+typedef struct HW_OMX_COMPONENTTYPE
+{
+    /** The size of this structure, in bytes.  It is the responsibility
+        of the allocator of this structure to fill in this value.  Since
+        this structure is allocated by the GetHandle function, this
+        function will fill in this value. */
+    HW_OMX_U32 nSize;
+
+    /** nVersion is the version of the OMX specification that the structure
+        is built against.  It is the responsibility of the creator of this
+        structure to initialize this value and every user of this structure
+        should verify that it knows how to use the exact version of
+        this structure found herein. */
+    HW_OMX_VERSIONTYPE nVersion;
+
+    /** pComponentPrivate is a pointer to the component private data area.
+        This member is allocated and initialized by the component when the
+        component is first loaded.  The application should not access this
+        data area. */
+    HW_OMX_PTR pComponentPrivate;
+
+    /** pApplicationPrivate is a pointer that is a parameter to the
+        HW_OMX_GetHandle method, and contains an application private value
+        provided by the IL client.  This application private data is
+        returned to the IL Client by OMX in all callbacks */
+    HW_OMX_PTR pApplicationPrivate;
+
+    /** refer to HW_OMX_GetComponentVersion in HW_OMX_core.h or the OMX IL
+        specification for details on the GetComponentVersion method.
+     */
+    HW_OMX_ERRORTYPE (*GetComponentVersion)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_OUT HW_OMX_STRING pComponentName,
+            HW_OMX_OUT HW_OMX_VERSIONTYPE* pComponentVersion,
+            HW_OMX_OUT HW_OMX_VERSIONTYPE* pSpecVersion,
+            HW_OMX_OUT HW_OMX_UUIDTYPE* pComponentUUID);
+
+    /** refer to HW_OMX_SendCommand in HW_OMX_core.h or the OMX IL
+        specification for details on the SendCommand method.
+     */
+    HW_OMX_ERRORTYPE (*SendCommand)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_COMMANDTYPE Cmd,
+            HW_OMX_IN  HW_OMX_U32 nParam1,
+            HW_OMX_IN  HW_OMX_PTR pCmdData);
+
+    /** refer to HW_OMX_GetParameter in HW_OMX_core.h or the OMX IL
+        specification for details on the GetParameter method.
+     */
+    HW_OMX_ERRORTYPE (*GetParameter)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_INDEXTYPE nParamIndex,
+            HW_OMX_INOUT HW_OMX_PTR pComponentParameterStructure);
+
+
+    /** refer to HW_OMX_SetParameter in HW_OMX_core.h or the OMX IL
+        specification for details on the SetParameter method.
+     */
+    HW_OMX_ERRORTYPE (*SetParameter)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_INDEXTYPE nIndex,
+            HW_OMX_IN  HW_OMX_PTR pComponentParameterStructure);
+
+
+    /** refer to HW_OMX_GetConfig in HW_OMX_core.h or the OMX IL
+        specification for details on the GetConfig method.
+     */
+    HW_OMX_ERRORTYPE (*GetConfig)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_INDEXTYPE nIndex,
+            HW_OMX_INOUT HW_OMX_PTR pComponentConfigStructure);
+
+
+    /** refer to HW_OMX_SetConfig in HW_OMX_core.h or the OMX IL
+        specification for details on the SetConfig method.
+     */
+    HW_OMX_ERRORTYPE (*SetConfig)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_INDEXTYPE nIndex,
+            HW_OMX_IN  HW_OMX_PTR pComponentConfigStructure);
+
+
+    /** refer to HW_OMX_GetExtensionIndex in HW_OMX_core.h or the OMX IL
+        specification for details on the GetExtensionIndex method.
+     */
+    HW_OMX_ERRORTYPE (*GetExtensionIndex)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_STRING cParameterName,
+            HW_OMX_OUT HW_OMX_INDEXTYPE* pIndexType);
+
+
+    /** refer to HW_OMX_GetState in HW_OMX_core.h or the OMX IL
+        specification for details on the GetState method.
+     */
+    HW_OMX_ERRORTYPE (*GetState)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_OUT HW_OMX_STATETYPE* pState);
+
+
+    /** The ComponentTunnelRequest method will interact with another OMX
+        component to determine if tunneling is possible and to setup the
+        tunneling.  The return codes for this method can be used to
+        determine if tunneling is not possible, or if tunneling is not
+        supported.
+
+        Base profile components (i.e. non-interop) do not support this
+        method and should return HW_OMX_ErrorNotImplemented
+
+        The interop profile component MUST support tunneling to another
+        interop profile component with a compatible port parameters.
+        A component may also support proprietary communication.
+
+        If proprietary communication is supported the negotiation of
+        proprietary communication is done outside of OMX in a vendor
+        specific way. It is only required that the proper result be
+        returned and the details of how the setup is done is left
+        to the component implementation.
+
+        When this method is invoked when nPort in an output port, the
+        component will:
+        1.  Populate the pTunnelSetup structure with the output port's
+            requirements and constraints for the tunnel.
+
+        When this method is invoked when nPort in an input port, the
+        component will:
+        1.  Query the necessary parameters from the output port to
+            determine if the ports are compatible for tunneling
+        2.  If the ports are compatible, the component should store
+            the tunnel step provided by the output port
+        3.  Determine which port (either input or output) is the buffer
+            supplier, and call HW_OMX_SetParameter on the output port to
+            indicate this selection.
+
+        The component will return from this call within 5 msec.
+
+        @param [in] hComp
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the HW_OMX_GetHandle method.
+        @param [in] nPort
+            nPort is used to select the port on the component to be used
+            for tunneling.
+        @param [in] hTunneledComp
+            Handle of the component to tunnel with.  This is the component
+            handle returned by the call to the HW_OMX_GetHandle method.  When
+            this parameter is 0x0 the component should setup the port for
+            communication with the application / IL Client.
+        @param [in] nPortOutput
+            nPortOutput is used indicate the port the component should
+            tunnel with.
+        @param [in] pTunnelSetup
+            Pointer to the tunnel setup structure.  When nPort is an output port
+            the component should populate the fields of this structure.  When
+            When nPort is an input port the component should review the setup
+            provided by the component with the output port.
+        @return HW_OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        @ingroup tun
+    */
+
+    HW_OMX_ERRORTYPE (*ComponentTunnelRequest)(
+        HW_OMX_IN  HW_OMX_HANDLETYPE hComp,
+        HW_OMX_IN  HW_OMX_U32 nPort,
+        HW_OMX_IN  HW_OMX_HANDLETYPE hTunneledComp,
+        HW_OMX_IN  HW_OMX_U32 nTunneledPort,
+        HW_OMX_INOUT  HW_OMX_TUNNELSETUPTYPE* pTunnelSetup);
+
+    /** refer to HW_OMX_UseBuffer in HW_OMX_core.h or the OMX IL
+        specification for details on the UseBuffer method.
+        @ingroup buf
+     */
+    HW_OMX_ERRORTYPE (*UseBuffer)(
+            HW_OMX_IN HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_INOUT HW_OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            HW_OMX_IN HW_OMX_U32 nPortIndex,
+            HW_OMX_IN HW_OMX_PTR pAppPrivate,
+            HW_OMX_IN HW_OMX_U32 nSizeBytes,
+            HW_OMX_IN HW_OMX_U8* pBuffer);
+
+    /** refer to HW_OMX_AllocateBuffer in HW_OMX_core.h or the OMX IL
+        specification for details on the AllocateBuffer method.
+        @ingroup buf
+     */
+    HW_OMX_ERRORTYPE (*AllocateBuffer)(
+            HW_OMX_IN HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_INOUT HW_OMX_BUFFERHEADERTYPE** ppBuffer,
+            HW_OMX_IN HW_OMX_U32 nPortIndex,
+            HW_OMX_IN HW_OMX_PTR pAppPrivate,
+            HW_OMX_IN HW_OMX_U32 nSizeBytes);
+
+    /** refer to HW_OMX_FreeBuffer in HW_OMX_core.h or the OMX IL
+        specification for details on the FreeBuffer method.
+        @ingroup buf
+     */
+    HW_OMX_ERRORTYPE (*FreeBuffer)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_U32 nPortIndex,
+            HW_OMX_IN  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** refer to HW_OMX_EmptyThisBuffer in HW_OMX_core.h or the OMX IL
+        specification for details on the EmptyThisBuffer method.
+        @ingroup buf
+     */
+    HW_OMX_ERRORTYPE (*EmptyThisBuffer)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** refer to HW_OMX_FillThisBuffer in HW_OMX_core.h or the OMX IL
+        specification for details on the FillThisBuffer method.
+        @ingroup buf
+     */
+    HW_OMX_ERRORTYPE (*FillThisBuffer)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The SetCallbacks method is used by the core to specify the callback
+        structure from the application to the component.  This is a blocking
+        call.  The component will return from this call within 5 msec.
+        @param [in] hComponent
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param [in] pCallbacks
+            pointer to an HW_OMX_CALLBACKTYPE structure used to provide the
+            callback information to the component
+        @param [in] pAppData
+            pointer to an application defined value.  It is anticipated that
+            the application will pass a pointer to a data structure or a "this
+            pointer" in this area to allow the callback (in the application)
+            to determine the context of the call
+        @return HW_OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+     */
+    HW_OMX_ERRORTYPE (*SetCallbacks)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_IN  HW_OMX_CALLBACKTYPE* pCallbacks,
+            HW_OMX_IN  HW_OMX_PTR pAppData);
+
+    /** ComponentDeInit method is used to deinitialize the component
+        providing a means to free any resources allocated at component
+        initialization.  NOTE:  After this call the component handle is
+        not valid for further use.
+        @param [in] hComponent
+            Handle of the component to be accessed.  This is the component
+            handle returned by the call to the GetHandle function.
+        @return HW_OMX_ERRORTYPE
+            If the command successfully executes, the return code will be
+            HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+     */
+    HW_OMX_ERRORTYPE (*ComponentDeInit)(
+            HW_OMX_IN  HW_OMX_HANDLETYPE hComponent);
+
+    /** @ingroup buf */
+    HW_OMX_ERRORTYPE (*UseEGLImage)(
+            HW_OMX_IN HW_OMX_HANDLETYPE hComponent,
+            HW_OMX_INOUT HW_OMX_BUFFERHEADERTYPE** ppBufferHdr,
+            HW_OMX_IN HW_OMX_U32 nPortIndex,
+            HW_OMX_IN HW_OMX_PTR pAppPrivate,
+            HW_OMX_IN void* eglImage);
+
+    HW_OMX_ERRORTYPE (*ComponentRoleEnum)(
+        HW_OMX_IN HW_OMX_HANDLETYPE hComponent,
+        HW_OMX_OUT HW_OMX_U8 *cRole,
+        HW_OMX_IN HW_OMX_U32 nIndex);
+
+} HW_OMX_COMPONENTTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_ContentPipe.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_ContentPipe.h
@@ -0,0 +1,212 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** HW_OMX_ContentPipe.h - OpenMax IL version 1.1.2
+ *  The HW_OMX_ContentPipe header file contains the definitions used to define
+ *  the public interface for content piples.  This header file is intended to
+ *  be used by the component.
+ */
+
+#ifndef HW_OMX_CONTENTPIPE_H
+#define HW_OMX_CONTENTPIPE_H
+
+#ifndef KD_EACCES
+/* OpenKODE error codes. CPResult values may be zero (indicating success
+   or one of the following values) */
+#define KD_EACCES (1)
+#define KD_EADDRINUSE (2)
+#define KD_EAGAIN (5)
+#define KD_EBADF (7)
+#define KD_EBUSY (8)
+#define KD_ECONNREFUSED (9)
+#define KD_ECONNRESET (10)
+#define KD_EDEADLK (11)
+#define KD_EDESTADDRREQ (12)
+#define KD_ERANGE (35)
+#define KD_EEXIST (13)
+#define KD_EFBIG (14)
+#define KD_EHOSTUNREACH (15)
+#define KD_EINVAL (17)
+#define KD_EIO (18)
+#define KD_EISCONN (20)
+#define KD_EISDIR (21)
+#define KD_EMFILE (22)
+#define KD_ENAMETOOLONG (23)
+#define KD_ENOENT (24)
+#define KD_ENOMEM (25)
+#define KD_ENOSPC (26)
+#define KD_ENOSYS (27)
+#define KD_ENOTCONN (28)
+#define KD_EPERM (33)
+#define KD_ETIMEDOUT (36)
+#define KD_EILSEQ (19)
+#endif
+
+/** Map types from OMX standard types only here so interface is as generic as possible. */
+typedef HW_OMX_U32    CPresult;
+typedef char *     CPstring;
+typedef void *     CPhandle;
+typedef HW_OMX_U32    CPuint;
+typedef HW_OMX_S32    CPint;
+typedef char       CPbyte;
+typedef HW_OMX_BOOL   CPbool;
+
+/** enumeration of origin types used in the CP_PIPETYPE's Seek function
+ * @ingroup cp
+ */
+typedef enum CP_ORIGINTYPE {
+    CP_OriginBegin,
+    CP_OriginCur,
+    CP_OriginEnd,
+    CP_OriginKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    CP_OriginVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_OriginMax = 0X7FFFFFFF
+} CP_ORIGINTYPE;
+
+/** enumeration of contact access types used in the CP_PIPETYPE's Open function
+ * @ingroup cp
+ */
+typedef enum CP_ACCESSTYPE {
+    CP_AccessRead,
+    CP_AccessWrite,
+    CP_AccessReadWrite,
+    CP_AccessKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    CP_AccessVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_AccessMax = 0X7FFFFFFF
+} CP_ACCESSTYPE;
+
+/** enumeration of results returned by the CP_PIPETYPE's CheckAvailableBytes function
+ * @ingroup cp
+ */
+typedef enum CP_CHECKBYTESRESULTTYPE
+{
+    CP_CheckBytesOk,                    /**< There are at least the request number
+                                              of bytes available */
+    CP_CheckBytesNotReady,              /**< The pipe is still retrieving bytes
+                                              and presently lacks sufficient bytes.
+                                              Client will be called when they are
+                                              sufficient bytes are available. */
+    CP_CheckBytesInsufficientBytes,     /**< The pipe has retrieved all bytes
+                                              but those available are less than those
+                                              requested */
+    CP_CheckBytesAtEndOfStream,         /**< The pipe has reached the end of stream
+                                              and no more bytes are available. */
+    CP_CheckBytesOutOfBuffers,          /**< All read/write buffers are currently in use. */
+    CP_CheckBytesKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    CP_CheckBytesVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_CheckBytesMax = 0X7FFFFFFF
+} CP_CHECKBYTESRESULTTYPE;
+
+/** enumeration of content pipe events sent to the client callback.
+ * @ingroup cp
+ */
+typedef enum CP_EVENTTYPE{
+    CP_BytesAvailable,                      /** bytes requested in a CheckAvailableBytes call are now available*/
+    CP_Overflow,                            /** enumeration of content pipe events sent to the client callback*/
+    CP_PipeDisconnected,                    /** enumeration of content pipe events sent to the client callback*/
+    CP_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    CP_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    CP_EventMax = 0X7FFFFFFF
+} CP_EVENTTYPE;
+
+/** content pipe definition
+ * @ingroup cp
+ */
+typedef struct CP_PIPETYPE
+{
+    /** Open a content stream for reading or writing. */
+    CPresult (*Open)( CPhandle* hContent, CPstring szURI, CP_ACCESSTYPE eAccess );
+
+    /** Close a content stream. */
+    CPresult (*Close)( CPhandle hContent );
+
+    /** Create a content source and open it for writing. */
+    CPresult (*Create)( CPhandle *hContent, CPstring szURI );
+
+    /** Check the that specified number of bytes are available for reading or writing (depending on access type).*/
+    CPresult (*CheckAvailableBytes)( CPhandle hContent, CPuint nBytesRequested, CP_CHECKBYTESRESULTTYPE *eResult );
+
+    /** Seek to certain position in the content relative to the specified origin. */
+    CPresult (*SetPosition)( CPhandle  hContent, CPint nOffset, CP_ORIGINTYPE eOrigin);
+
+    /** Retrieve the current position relative to the start of the content. */
+    CPresult (*GetPosition)( CPhandle hContent, CPuint *pPosition);
+
+    /** Retrieve data of the specified size from the content stream (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency reads. */
+    CPresult (*Read)( CPhandle hContent, CPbyte *pData, CPuint nSize);
+
+    /** Retrieve a buffer allocated by the pipe that contains the requested number of bytes.
+       Buffer contains the next block of bytes, as specified by nSize, of the content. nSize also
+       returns the size of the block actually read. Content pointer advances the by the returned size.
+       Note: pipe provides pointer. This function is appropriate for large reads. The client must call
+       ReleaseReadBuffer when done with buffer.
+
+       In some cases the requested block may not reside in contiguous memory within the
+       pipe implementation. For instance if the pipe leverages a circular buffer then the requested
+       block may straddle the boundary of the circular buffer. By default a pipe implementation
+       performs a copy in this case to provide the block to the pipe client in one contiguous buffer.
+       If, however, the client sets bForbidCopy, then the pipe returns only those bytes preceding the memory
+       boundary. Here the client may retrieve the data in segments over successive calls. */
+    CPresult (*ReadBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint *nSize, CPbool bForbidCopy);
+
+    /** Release a buffer obtained by ReadBuffer back to the pipe. */
+    CPresult (*ReleaseReadBuffer)(CPhandle hContent, CPbyte *pBuffer);
+
+    /** Write data of the specified size to the content (advance content pointer by size of data).
+       Note: pipe client provides pointer. This function is appropriate for small high frequency writes. */
+    CPresult (*Write)( CPhandle hContent, CPbyte *data, CPuint nSize);
+
+    /** Retrieve a buffer allocated by the pipe used to write data to the content.
+       Client will fill buffer with output data. Note: pipe provides pointer. This function is appropriate
+       for large writes. The client must call WriteBuffer when done it has filled the buffer with data.*/
+    CPresult (*GetWriteBuffer)( CPhandle hContent, CPbyte **ppBuffer, CPuint nSize);
+
+    /** Deliver a buffer obtained via GetWriteBuffer to the pipe. Pipe will write the
+       the contents of the buffer to content and advance content pointer by the size of the buffer */
+    CPresult (*WriteBuffer)( CPhandle hContent, CPbyte *pBuffer, CPuint nFilledSize);
+
+    /** Register a per-handle client callback with the content pipe. */
+    CPresult (*RegisterCallback)( CPhandle hContent, CPresult (*ClientCallback)(CP_EVENTTYPE eEvent, CPuint iParam));
+
+} CP_PIPETYPE;
+
+#endif
+
Index: ffmpeg/libavcodec/HW_OMX_Core.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_Core.h
@@ -0,0 +1,1502 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** HW_OMX_Core.h - OpenMax IL version 1.1.2
+ *  The HW_OMX_Core header file contains the definitions used by both the
+ *  application and the component to access common items.
+ */
+
+#ifndef HW_OMX_Core_h
+#define HW_OMX_Core_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header shall include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+
+#include "HW_OMX_Index.h"
+
+
+/** The HW_OMX_COMMANDTYPE enumeration is used to specify the action in the
+ *  HW_OMX_SendCommand macro.
+ *  @ingroup core
+ */
+typedef enum HW_OMX_COMMANDTYPE
+{
+    HW_OMX_CommandStateSet,    /**< Change the component state */
+    HW_OMX_CommandFlush,       /**< Flush the data queue(s) of a component */
+    HW_OMX_CommandPortDisable, /**< Disable a port on a component. */
+    HW_OMX_CommandPortEnable,  /**< Enable a port on a component. */
+    HW_OMX_CommandMarkBuffer,  /**< Mark a component/buffer for observation */
+    HW_OMX_CommandKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_CommandVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_CommandMax = 0X7FFFFFFF
+} HW_OMX_COMMANDTYPE;
+
+
+
+/** The HW_OMX_STATETYPE enumeration is used to indicate or change the component
+ *  state.  This enumeration reflects the current state of the component when
+ *  used with the HW_OMX_GetState macro or becomes the parameter in a state change
+ *  command when used with the HW_OMX_SendCommand macro.
+ *
+ *  The component will be in the Loaded state after the component is initially
+ *  loaded into memory.  In the Loaded state, the component is not allowed to
+ *  allocate or hold resources other than to build it's internal parameter
+ *  and configuration tables.  The application will send one or more
+ *  SetParameters/GetParameters and SetConfig/GetConfig commands to the
+ *  component and the component will record each of these parameter and
+ *  configuration changes for use later.  When the application sends the
+ *  Idle command, the component will acquire the resources needed for the
+ *  specified configuration and will transition to the idle state if the
+ *  allocation is successful.  If the component cannot successfully
+ *  transition to the idle state for any reason, the state of the component
+ *  shall be fully rolled back to the Loaded state (e.g. all allocated
+ *  resources shall be released).  When the component receives the command
+ *  to go to the Executing state, it shall begin processing buffers by
+ *  sending all input buffers it holds to the application.  While
+ *  the component is in the Idle state, the application may also send the
+ *  Pause command.  If the component receives the pause command while in the
+ *  Idle state, the component shall send all input buffers it holds to the
+ *  application, but shall not begin processing buffers.  This will allow the
+ *  application to prefill buffers.
+ *
+ *  @ingroup comp
+ */
+
+typedef enum HW_OMX_STATETYPE
+{
+    HW_OMX_StateInvalid,      /**< component has detected that it's internal data
+                                structures are corrupted to the point that
+                                it cannot determine it's state properly */
+    HW_OMX_StateLoaded,      /**< component has been loaded but has not completed
+                                initialization.  The HW_OMX_SetParameter macro
+                                and the HW_OMX_GetParameter macro are the only
+                                valid macros allowed to be sent to the
+                                component in this state. */
+    HW_OMX_StateIdle,        /**< component initialization has been completed
+                                successfully and the component is ready to
+                                to start. */
+    HW_OMX_StateExecuting,   /**< component has accepted the start command and
+                                is processing data (if data is available) */
+    HW_OMX_StatePause,       /**< component has received pause command */
+    HW_OMX_StateWaitForResources, /**< component is waiting for resources, either after
+                                preemption or before it gets the resources requested.
+                                See specification for complete details. */
+    HW_OMX_StateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_StateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_StateMax = 0X7FFFFFFF
+} HW_OMX_STATETYPE;
+
+/** The HW_OMX_ERRORTYPE enumeration defines the standard OMX Errors.  These
+ *  errors should cover most of the common failure cases.  However,
+ *  vendors are free to add additional error messages of their own as
+ *  long as they follow these rules:
+ *  1.  Vendor error messages shall be in the range of 0x90000000 to
+ *      0x9000FFFF.
+ *  2.  Vendor error messages shall be defined in a header file provided
+ *      with the component.  No error messages are allowed that are
+ *      not defined.
+ */
+typedef enum HW_OMX_ERRORTYPE
+{
+  HW_OMX_ErrorNone = 0,
+
+  /** There were insufficient resources to perform the requested operation */
+  HW_OMX_ErrorInsufficientResources = (HW_OMX_S32) 0x80001000,
+
+  /** There was an error, but the cause of the error could not be determined */
+  HW_OMX_ErrorUndefined = (HW_OMX_S32) 0x80001001,
+
+  /** The component name string was not valid */
+  HW_OMX_ErrorInvalidComponentName = (HW_OMX_S32) 0x80001002,
+
+  /** No component with the specified name string was found */
+  HW_OMX_ErrorComponentNotFound = (HW_OMX_S32) 0x80001003,
+
+  /** The component specified did not have a "HW_OMX_ComponentInit" or
+      "HW_OMX_ComponentDeInit entry point */
+  HW_OMX_ErrorInvalidComponent = (HW_OMX_S32) 0x80001004,
+
+  /** One or more parameters were not valid */
+  HW_OMX_ErrorBadParameter = (HW_OMX_S32) 0x80001005,
+
+  /** The requested function is not implemented */
+  HW_OMX_ErrorNotImplemented = (HW_OMX_S32) 0x80001006,
+
+  /** The buffer was emptied before the next buffer was ready */
+  HW_OMX_ErrorUnderflow = (HW_OMX_S32) 0x80001007,
+
+  /** The buffer was not available when it was needed */
+  HW_OMX_ErrorOverflow = (HW_OMX_S32) 0x80001008,
+
+  /** The hardware failed to respond as expected */
+  HW_OMX_ErrorHardware = (HW_OMX_S32) 0x80001009,
+
+  /** The component is in the state HW_OMX_StateInvalid */
+  HW_OMX_ErrorInvalidState = (HW_OMX_S32) 0x8000100A,
+
+  /** Stream is found to be corrupt */
+  HW_OMX_ErrorStreamCorrupt = (HW_OMX_S32) 0x8000100B,
+
+  /** Ports being connected are not compatible */
+  HW_OMX_ErrorPortsNotCompatible = (HW_OMX_S32) 0x8000100C,
+
+  /** Resources allocated to an idle component have been
+      lost resulting in the component returning to the loaded state */
+  HW_OMX_ErrorResourcesLost = (HW_OMX_S32) 0x8000100D,
+
+  /** No more indicies can be enumerated */
+  HW_OMX_ErrorNoMore = (HW_OMX_S32) 0x8000100E,
+
+  /** The component detected a version mismatch */
+  HW_OMX_ErrorVersionMismatch = (HW_OMX_S32) 0x8000100F,
+
+  /** The component is not ready to return data at this time */
+  HW_OMX_ErrorNotReady = (HW_OMX_S32) 0x80001010,
+
+  /** There was a timeout that occurred */
+  HW_OMX_ErrorTimeout = (HW_OMX_S32) 0x80001011,
+
+  /** This error occurs when trying to transition into the state you are already in */
+  HW_OMX_ErrorSameState = (HW_OMX_S32) 0x80001012,
+
+  /** Resources allocated to an executing or paused component have been
+      preempted, causing the component to return to the idle state */
+  HW_OMX_ErrorResourcesPreempted = (HW_OMX_S32) 0x80001013,
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback)
+      during the allocation of buffers (on a transition from the LOADED to the IDLE state or
+      on a port restart) when it deems that it has waited an unusually long time for the supplier
+      to send it an allocated buffer via a UseBuffer call. */
+  HW_OMX_ErrorPortUnresponsiveDuringAllocation = (HW_OMX_S32) 0x80001014,
+
+  /** A non-supplier port sends this error to the IL client (via the EventHandler callback)
+      during the deallocation of buffers (on a transition from the IDLE to LOADED state or
+      on a port stop) when it deems that it has waited an unusually long time for the supplier
+      to request the deallocation of a buffer header via a FreeBuffer call. */
+  HW_OMX_ErrorPortUnresponsiveDuringDeallocation = (HW_OMX_S32) 0x80001015,
+
+  /** A supplier port sends this error to the IL client (via the EventHandler callback)
+      during the stopping of a port (either on a transition from the IDLE to LOADED
+      state or a port stop) when it deems that it has waited an unusually long time for
+      the non-supplier to return a buffer via an EmptyThisBuffer or FillThisBuffer call. */
+  HW_OMX_ErrorPortUnresponsiveDuringStop = (HW_OMX_S32) 0x80001016,
+
+  /** Attempting a state transtion that is not allowed */
+  HW_OMX_ErrorIncorrectStateTransition = (HW_OMX_S32) 0x80001017,
+
+  /* Attempting a command that is not allowed during the present state. */
+  HW_OMX_ErrorIncorrectStateOperation = (HW_OMX_S32) 0x80001018,
+
+  /** The values encapsulated in the parameter or config structure are not supported. */
+  HW_OMX_ErrorUnsupportedSetting = (HW_OMX_S32) 0x80001019,
+
+  /** The parameter or config indicated by the given index is not supported. */
+  HW_OMX_ErrorUnsupportedIndex = (HW_OMX_S32) 0x8000101A,
+
+  /** The port index supplied is incorrect. */
+  HW_OMX_ErrorBadPortIndex = (HW_OMX_S32) 0x8000101B,
+
+  /** The port has lost one or more of its buffers and it thus unpopulated. */
+  HW_OMX_ErrorPortUnpopulated = (HW_OMX_S32) 0x8000101C,
+
+  /** Component suspended due to temporary loss of resources */
+  HW_OMX_ErrorComponentSuspended = (HW_OMX_S32) 0x8000101D,
+
+  /** Component suspended due to an inability to acquire dynamic resources */
+  HW_OMX_ErrorDynamicResourcesUnavailable = (HW_OMX_S32) 0x8000101E,
+
+  /** When the macroblock error reporting is enabled the component returns new error
+  for every frame that has errors */
+  HW_OMX_ErrorMbErrorsInFrame = (HW_OMX_S32) 0x8000101F,
+
+  /** A component reports this error when it cannot parse or determine the format of an input stream. */
+  HW_OMX_ErrorFormatNotDetected = (HW_OMX_S32) 0x80001020,
+
+  /** The content open operation failed. */
+  HW_OMX_ErrorContentPipeOpenFailed = (HW_OMX_S32) 0x80001021,
+
+  /** The content creation operation failed. */
+  HW_OMX_ErrorContentPipeCreationFailed = (HW_OMX_S32) 0x80001022,
+
+  /** Separate table information is being used */
+  HW_OMX_ErrorSeperateTablesUsed = (HW_OMX_S32) 0x80001023,
+
+  /** Tunneling is unsupported by the component*/
+  HW_OMX_ErrorTunnelingUnsupported = (HW_OMX_S32) 0x80001024,
+
+  HW_OMX_ErrorKhronosExtensions = (HW_OMX_S32)0x8F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+  HW_OMX_ErrorVendorStartUnused = (HW_OMX_S32)0x90000000, /**< Reserved region for introducing Vendor Extensions */
+  HW_OMX_ErrorMax = 0x7FFFFFFF
+} HW_OMX_ERRORTYPE;
+
+/** @ingroup core */
+typedef HW_OMX_ERRORTYPE (* HW_OMX_COMPONENTINITTYPE)(HW_OMX_IN  HW_OMX_HANDLETYPE hComponent);
+
+/** @ingroup core */
+typedef struct HW_OMX_COMPONENTREGISTERTYPE
+{
+  const char          * pName;       /* Component name, 128 byte limit (including '\0') applies */
+  HW_OMX_COMPONENTINITTYPE pInitialize; /* Component instance initialization function */
+} HW_OMX_COMPONENTREGISTERTYPE;
+
+/** @ingroup core */
+extern HW_OMX_COMPONENTREGISTERTYPE HW_OMX_ComponentRegistered[];
+
+/** @ingroup rpm */
+typedef struct HW_OMX_PRIORITYMGMTTYPE {
+ HW_OMX_U32 nSize;             /**< size of the structure in bytes */
+ HW_OMX_VERSIONTYPE nVersion;  /**< OMX specification version information */
+ HW_OMX_U32 nGroupPriority;            /**< Priority of the component group */
+ HW_OMX_U32 nGroupID;                  /**< ID of the component group */
+} HW_OMX_PRIORITYMGMTTYPE;
+
+/* Component name and Role names are limited to 128 characters including the terminating '\0'. */
+#define HW_OMX_MAX_STRINGNAME_SIZE 128
+
+/** @ingroup comp */
+typedef struct HW_OMX_PARAM_COMPONENTROLETYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U8 cRole[HW_OMX_MAX_STRINGNAME_SIZE];  /**< name of standard component which defines component role */
+} HW_OMX_PARAM_COMPONENTROLETYPE;
+
+/** End of Stream Buffer Flag:
+  *
+  * A component sets EOS when it has no more data to emit on a particular
+  * output port. Thus an output port shall set EOS on the last buffer it
+  * emits. A component's determination of when an output port should
+  * cease sending data is implemenation specific.
+  * @ingroup buf
+  */
+
+#define HW_OMX_BUFFERFLAG_EOS 0x00000001
+
+/** Start Time Buffer Flag:
+ *
+ * The source of a stream (e.g. a demux component) sets the STARTTIME
+ * flag on the buffer that contains the starting timestamp for the
+ * stream. The starting timestamp corresponds to the first data that
+ * should be displayed at startup or after a seek.
+ * The first timestamp of the stream is not necessarily the start time.
+ * For instance, in the case of a seek to a particular video frame,
+ * the target frame may be an interframe. Thus the first buffer of
+ * the stream will be the intra-frame preceding the target frame and
+ * the starttime will occur with the target frame (with any other
+ * required frames required to reconstruct the target intervening).
+ *
+ * The STARTTIME flag is directly associated with the buffer's
+ * timestamp ' thus its association to buffer data and its
+ * propagation is identical to the timestamp's.
+ *
+ * When a Sync Component client receives a buffer with the
+ * STARTTIME flag it shall perform a SetConfig on its sync port
+ * using HW_OMX_ConfigTimeClientStartTime and passing the buffer's
+ * timestamp.
+ *
+ * @ingroup buf
+ */
+
+#define HW_OMX_BUFFERFLAG_STARTTIME 0x00000002
+
+
+
+/** Decode Only Buffer Flag:
+ *
+ * The source of a stream (e.g. a demux component) sets the DECODEONLY
+ * flag on any buffer that should shall be decoded but should not be
+ * displayed. This flag is used, for instance, when a source seeks to
+ * a target interframe that requires the decode of frames preceding the
+ * target to facilitate the target's reconstruction. In this case the
+ * source would emit the frames preceding the target downstream
+ * but mark them as decode only.
+ *
+ * The DECODEONLY is associated with buffer data and propagated in a
+ * manner identical to the buffer timestamp.
+ *
+ * A component that renders data should ignore all buffers with
+ * the DECODEONLY flag set.
+ *
+ * @ingroup buf
+ */
+
+#define HW_OMX_BUFFERFLAG_DECODEONLY 0x00000004
+
+
+/* Data Corrupt Flag: This flag is set when the IL client believes the data in the associated buffer is corrupt
+ * @ingroup buf
+ */
+
+#define HW_OMX_BUFFERFLAG_DATACORRUPT 0x00000008
+
+/* End of Frame: The buffer contains exactly one end of frame and no data
+ *  occurs after the end of frame. This flag is an optional hint. The absence
+ *  of this flag does not imply the absence of an end of frame within the buffer.
+ * @ingroup buf
+*/
+#define HW_OMX_BUFFERFLAG_ENDOFFRAME 0x00000010
+
+/* Sync Frame Flag: This flag is set when the buffer content contains a coded sync frame '
+ *  a frame that has no dependency on any other frame information
+ *  @ingroup buf
+ */
+#define HW_OMX_BUFFERFLAG_SYNCFRAME 0x00000020
+
+/* Extra data present flag: there is extra data appended to the data stream
+ * residing in the buffer
+ * @ingroup buf
+ */
+#define HW_OMX_BUFFERFLAG_EXTRADATA 0x00000040
+
+/** Codec Config Buffer Flag:
+* HW_OMX_BUFFERFLAG_CODECCONFIG is an optional flag that is set by an
+* output port when all bytes in the buffer form part or all of a set of
+* codec specific configuration data.  Examples include SPS/PPS nal units
+* for HW_OMX_VIDEO_CodingAVC or AudioSpecificConfig data for
+* HW_OMX_AUDIO_CodingAAC.  Any component that for a given stream sets
+* HW_OMX_BUFFERFLAG_CODECCONFIG shall not mix codec configuration bytes
+* with frame data in the same buffer, and shall send all buffers
+* containing codec configuration bytes before any buffers containing
+* frame data that those configurations bytes describe.
+* If the stream format for a particular codec has a frame specific
+* header at the start of each frame, for example HW_OMX_AUDIO_CodingMP3 or
+* HW_OMX_AUDIO_CodingAAC in ADTS mode, then these shall be presented as
+* normal without setting HW_OMX_BUFFERFLAG_CODECCONFIG.
+ * @ingroup buf
+ */
+#define HW_OMX_BUFFERFLAG_CODECCONFIG 0x00000080
+
+
+
+/** @ingroup buf */
+typedef struct HW_OMX_BUFFERHEADERTYPE
+{
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U8* pBuffer;            /**< Pointer to actual block of memory
+                                     that is acting as the buffer */
+    HW_OMX_U32 nAllocLen;          /**< size of the buffer allocated, in bytes */
+    HW_OMX_U32 nFilledLen;         /**< number of bytes currently in the
+                                     buffer */
+    HW_OMX_U32 nOffset;            /**< start offset of valid data in bytes from
+                                     the start of the buffer */
+    HW_OMX_PTR pAppPrivate;        /**< pointer to any data the application
+                                     wants to associate with this buffer */
+    HW_OMX_PTR pPlatformPrivate;   /**< pointer to any data the platform
+                                     wants to associate with this buffer */
+    HW_OMX_PTR pInputPortPrivate;  /**< pointer to any data the input port
+                                     wants to associate with this buffer */
+    HW_OMX_PTR pOutputPortPrivate; /**< pointer to any data the output port
+                                     wants to associate with this buffer */
+    HW_OMX_HANDLETYPE hMarkTargetComponent; /**< The component that will generate a
+                                              mark event upon processing this buffer. */
+    HW_OMX_PTR pMarkData;          /**< Application specific data associated with
+                                     the mark sent on a mark event to disambiguate
+                                     this mark from others. */
+    HW_OMX_U32 nTickCount;         /**< Optional entry that the component and
+                                     application can update with a tick count
+                                     when they access the component.  This
+                                     value should be in microseconds.  Since
+                                     this is a value relative to an arbitrary
+                                     starting point, this value cannot be used
+                                     to determine absolute time.  This is an
+                                     optional entry and not all components
+                                     will update it.*/
+ HW_OMX_TICKS nTimeStamp;          /**< Timestamp corresponding to the sample
+                                     starting at the first logical sample
+                                     boundary in the buffer. Timestamps of
+                                     successive samples within the buffer may
+                                     be inferred by adding the duration of the
+                                     of the preceding buffer to the timestamp
+                                     of the preceding buffer.*/
+  HW_OMX_U32     nFlags;           /**< buffer specific flags */
+  HW_OMX_U32 nOutputPortIndex;     /**< The index of the output port (if any) using
+                                     this buffer */
+  HW_OMX_U32 nInputPortIndex;      /**< The index of the input port (if any) using
+                                     this buffer */
+} HW_OMX_BUFFERHEADERTYPE;
+
+/** The HW_OMX_EXTRADATATYPE enumeration is used to define the
+ * possible extra data payload types.
+ * NB: this enum is binary backwards compatible with the previous
+ * HW_OMX_EXTRADATA_QUANT define.  This should be replaced with
+ * HW_OMX_ExtraDataQuantization.
+ */
+typedef enum HW_OMX_EXTRADATATYPE
+{
+   HW_OMX_ExtraDataNone = 0,                       /**< Indicates that no more extra data sections follow */
+   HW_OMX_ExtraDataQuantization,                   /**< The data payload contains quantization data */
+   HW_OMX_ExtraDataKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+   HW_OMX_ExtraDataVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+   HW_OMX_ExtraDataMax = 0x7FFFFFFF
+} HW_OMX_EXTRADATATYPE;
+
+
+typedef struct HW_OMX_OTHER_EXTRADATATYPE  {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_EXTRADATATYPE eType;       /* Extra Data type */
+    HW_OMX_U32 nDataSize;   /* Size of the supporting data to follow */
+    HW_OMX_U8  data[1];     /* Supporting data hint  */
+} HW_OMX_OTHER_EXTRADATATYPE;
+
+/** @ingroup comp */
+typedef struct HW_OMX_PORT_PARAM_TYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPorts;             /**< The number of ports for this component */
+    HW_OMX_U32 nStartPortNumber;   /** first port number for this type of port */
+} HW_OMX_PORT_PARAM_TYPE;
+
+/** @ingroup comp */
+typedef enum HW_OMX_EVENTTYPE
+{
+    HW_OMX_EventCmdComplete,         /**< component has sucessfully completed a command */
+    HW_OMX_EventError,               /**< component has detected an error condition */
+    HW_OMX_EventMark,                /**< component has detected a buffer mark */
+    HW_OMX_EventPortSettingsChanged, /**< component is reported a port settings change */
+    HW_OMX_EventBufferFlag,          /**< component has detected an EOS */
+    HW_OMX_EventResourcesAcquired,   /**< component has been granted resources and is
+                                       automatically starting the state change from
+                                       HW_OMX_StateWaitForResources to HW_OMX_StateIdle. */
+    HW_OMX_EventComponentResumed,     /**< Component resumed due to reacquisition of resources */
+    HW_OMX_EventDynamicResourcesAvailable, /**< Component has acquired previously unavailable dynamic resources */
+    HW_OMX_EventPortFormatDetected,      /**< Component has detected a supported format. */
+    HW_OMX_EventKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_EventVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+
+    /** Event when tunneled decoder has rendered an output or reached EOS
+     *  nData1 must contain the number of timestamps returned
+     *  pEventData must point to an array of the HW_OMX_VIDEO_RENDEREVENTTYPE structs containing the
+     *  render-timestamps of each frame. Component may batch rendered timestamps using this event,
+     *  but must signal the event no more than 40ms after the first frame in the batch. The frames
+     *  must be ordered by system timestamp inside and across batches.
+     *
+     *  The component shall signal the render-timestamp of the very first frame (as well as the
+     *  first frame after each flush) unbatched (with nData1 set to 1) within 5 msec.
+     *
+     *  If component is doing frame-rate conversion, it must signal the render time of each
+     *  converted frame, and must interpolate media timestamps for in-between frames.
+     *
+     *  When the component reached EOS, it must signal an EOS timestamp using the same mechanism.
+     *  This is in addition to the timestamp of the last rendered frame, and should follow that
+     *  frame.
+     */
+    HW_OMX_EventOutputRendered = 0x7F000001,
+
+    /** For framework internal use only: event sent by OMXNodeInstance when it receives a graphic
+     *  input buffer with a new dataspace for encoding. |arg1| will contain the dataspace. |arg2|
+     *  will contain the ColorAspects requested by the component (or framework defaults) using
+     *  the following bitfield layout:
+     *
+     *       +----------+-------------+----------------+------------+
+     *       |   Range  |  Primaries  |  MatrixCoeffs  |  Transfer  |
+     *       +----------+-------------+----------------+------------+
+     *  bits:  31....24   23.......16   15...........8   7........0
+     *
+     *  TODO: We would really need to tie this to an output buffer, but OMX does not provide a
+     *  fool-proof way to do that for video encoders.
+     */
+    HW_OMX_EventDataSpaceChanged,
+
+    /**
+     * Event when a component has an updated configuration on output for the client to retrieve.
+     * |arg1| contains the port index (currently only output port is valid). |arg2| contains the
+     * index of the updated config.
+     *
+     * For config updates that's associated with one frame, the update should be applied to the
+     * next output frame that comes in EmptyBufferDone callback.
+     *
+     * Upon receiving this event, the client must call the corresponding HW_OMX_GetConfig to retrieve
+     * the config update.
+     */
+    HW_OMX_EventConfigUpdate,
+
+    HW_OMX_EventMax = 0x7FFFFFFF
+} HW_OMX_EVENTTYPE;
+
+typedef struct HW_OMX_CALLBACKTYPE
+{
+    /** The EventHandler method is used to notify the application when an
+        event of interest occurs.  Events are defined in the HW_OMX_EVENTTYPE
+        enumeration.  Please see that enumeration for details of what will
+        be returned for each type of event. Callbacks should not return
+        an error to the component, so if an error occurs, the application
+        shall handle it internally.  This is a blocking call.
+
+        The application should return from this call within 5 msec to avoid
+        blocking the component for an excessively long period of time.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the
+            pAppData parameter to the HW_OMX_GetHandle method for the component.
+            This application defined value is provided so that the application
+            can have a component specific context when receiving the callback.
+        @param eEvent
+            Event that the component wants to notify the application about.
+        @param nData1
+            nData will be the HW_OMX_ERRORTYPE for an error event and will be
+            an HW_OMX_COMMANDTYPE for a command complete event and HW_OMX_INDEXTYPE for a HW_OMX_PortSettingsChanged event.
+         @param nData2
+            nData2 will hold further information related to the event. Can be HW_OMX_STATETYPE for
+            a HW_OMX_CommandStateSet command or port index for a HW_OMX_PortSettingsChanged event.
+            Default value is 0 if not used. )
+        @param pEventData
+            Pointer to additional event-specific data (see spec for meaning).
+      */
+
+   HW_OMX_ERRORTYPE (*EventHandler)(
+        HW_OMX_IN HW_OMX_HANDLETYPE hComponent,
+        HW_OMX_IN HW_OMX_PTR pAppData,
+        HW_OMX_IN HW_OMX_EVENTTYPE eEvent,
+        HW_OMX_IN HW_OMX_U32 nData1,
+        HW_OMX_IN HW_OMX_U32 nData2,
+        HW_OMX_IN HW_OMX_PTR pEventData);
+
+    /** The EmptyBufferDone method is used to return emptied buffers from an
+        input port back to the application for reuse.  This is a blocking call
+        so the application should not attempt to refill the buffers during this
+        call, but should queue them and refill them in another thread.  There
+        is no error return, so the application shall handle any errors generated
+        internally.
+
+        The application should return from this call within 5 msec.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the
+            pAppData parameter to the HW_OMX_GetHandle method for the component.
+            This application defined value is provided so that the application
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an HW_OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was emptied.
+        @ingroup buf
+     */
+    HW_OMX_ERRORTYPE (*EmptyBufferDone)(
+        HW_OMX_IN HW_OMX_HANDLETYPE hComponent,
+        HW_OMX_IN HW_OMX_PTR pAppData,
+        HW_OMX_IN HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+    /** The FillBufferDone method is used to return filled buffers from an
+        output port back to the application for emptying and then reuse.
+        This is a blocking call so the application should not attempt to
+        empty the buffers during this call, but should queue the buffers
+        and empty them in another thread.  There is no error return, so
+        the application shall handle any errors generated internally.  The
+        application shall also update the buffer header to indicate the
+        number of bytes placed into the buffer.
+
+        The application should return from this call within 5 msec.
+
+        @param hComponent
+            handle of the component to access.  This is the component
+            handle returned by the call to the GetHandle function.
+        @param pAppData
+            pointer to an application defined value that was provided in the
+            pAppData parameter to the HW_OMX_GetHandle method for the component.
+            This application defined value is provided so that the application
+            can have a component specific context when receiving the callback.
+        @param pBuffer
+            pointer to an HW_OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+            or AllocateBuffer indicating the buffer that was filled.
+        @ingroup buf
+     */
+    HW_OMX_ERRORTYPE (*FillBufferDone)(
+        HW_OMX_OUT HW_OMX_HANDLETYPE hComponent,
+        HW_OMX_OUT HW_OMX_PTR pAppData,
+        HW_OMX_OUT HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+} HW_OMX_CALLBACKTYPE;
+
+/** The HW_OMX_BUFFERSUPPLIERTYPE enumeration is used to dictate port supplier
+    preference when tunneling between two ports.
+    @ingroup tun buf
+*/
+typedef enum HW_OMX_BUFFERSUPPLIERTYPE
+{
+    HW_OMX_BufferSupplyUnspecified = 0x0, /**< port supplying the buffers is unspecified,
+                                              or don't care */
+    HW_OMX_BufferSupplyInput,             /**< input port supplies the buffers */
+    HW_OMX_BufferSupplyOutput,            /**< output port supplies the buffers */
+    HW_OMX_BufferSupplyKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_BufferSupplyVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_BufferSupplyMax = 0x7FFFFFFF
+} HW_OMX_BUFFERSUPPLIERTYPE;
+
+
+/** buffer supplier parameter
+ * @ingroup tun
+ */
+typedef struct HW_OMX_PARAM_BUFFERSUPPLIERTYPE {
+    HW_OMX_U32 nSize; /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex; /**< port that this structure applies to */
+    HW_OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< buffer supplier */
+} HW_OMX_PARAM_BUFFERSUPPLIERTYPE;
+
+
+/**< indicates that buffers received by an input port of a tunnel
+     may not modify the data in the buffers
+     @ingroup tun
+ */
+#define HW_OMX_PORTTUNNELFLAG_READONLY 0x00000001
+
+
+/** The HW_OMX_TUNNELSETUPTYPE structure is used to pass data from an output
+    port to an input port as part the two ComponentTunnelRequest calls
+    resulting from a HW_OMX_SetupTunnel call from the IL Client.
+    @ingroup tun
+ */
+typedef struct HW_OMX_TUNNELSETUPTYPE
+{
+    HW_OMX_U32 nTunnelFlags;             /**< bit flags for tunneling */
+    HW_OMX_BUFFERSUPPLIERTYPE eSupplier; /**< supplier preference */
+} HW_OMX_TUNNELSETUPTYPE;
+
+/* OMX Component headers is included to enable the core to use
+   macros for functions into the component for OMX release 1.0.
+   Developers should not access any structures or data from within
+   the component header directly */
+/* TO BE REMOVED - #include <HW_OMX_Component.h> */
+
+/** GetComponentVersion will return information about the component.
+    This is a blocking call.  This macro will go directly from the
+    application to the component (via a core macro).  The
+    component will return from this call within 5 msec.
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [out] pComponentName
+        pointer to an empty string of length 128 bytes.  The component
+        will write its name into this string.  The name will be
+        terminated by a single zero byte.  The name of a component will
+        be 127 bytes or less to leave room for the trailing zero byte.
+        An example of a valid component name is "OMX.ABC.ChannelMixer\0".
+    @param [out] pComponentVersion
+        pointer to an OMX Version structure that the component will fill
+        in.  The component will fill in a value that indicates the
+        component version.  NOTE: the component version is NOT the same
+        as the OMX Specification version (found in all structures).  The
+        component version is defined by the vendor of the component and
+        its value is entirely up to the component vendor.
+    @param [out] pSpecVersion
+        pointer to an OMX Version structure that the component will fill
+        in.  The SpecVersion is the version of the specification that the
+        component was built against.  Please note that this value may or
+        may not match the structure's version.  For example, if the
+        component was built against the 2.0 specification, but the
+        application (which creates the structure is built against the
+        1.0 specification the versions would be different.
+    @param [out] pComponentUUID
+        pointer to the UUID of the component which will be filled in by
+        the component.  The UUID is a unique identifier that is set at
+        RUN time for the component and is unique to each instantion of
+        the component.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define HW_OMX_GetComponentVersion(                            \
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                                     \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->GetComponentVersion(\
+        hComponent,                                         \
+        pComponentName,                                     \
+        pComponentVersion,                                  \
+        pSpecVersion,                                       \
+        pComponentUUID)                 /* Macro End */
+
+
+/** Send a command to the component.  This call is a non-blocking call.
+    The component should check the parameters and then queue the command
+    to the component thread to be executed.  The component thread shall
+    send the EventHandler() callback at the conclusion of the command.
+    This macro will go directly from the application to the component (via
+    a core macro).  The component will return from this call within 5 msec.
+
+    When the command is "HW_OMX_CommandStateSet" the component will queue a
+    state transition to the new state idenfied in nParam.
+
+    The component shall transition from executing to loaded state within 500 msec.
+
+    When the command is "HW_OMX_CommandFlush", to flush a port's buffer queues,
+    the command will force the component to return all buffers NOT CURRENTLY
+    BEING PROCESSED to the application, in the order in which the buffers
+    were received.
+
+    The component shall finish flusing each port within 5 msec.
+
+    When the command is "HW_OMX_CommandPortDisable" or
+    "HW_OMX_CommandPortEnable", the component's port (given by the value of
+    nParam) will be stopped or restarted.
+
+    The component shall finish disabling/reenabling each port within 5 msec.
+
+    When the command "HW_OMX_CommandMarkBuffer" is used to mark a buffer, the
+    pCmdData will point to a HW_OMX_MARKTYPE structure containing the component
+    handle of the component to examine the buffer chain for the mark.  nParam1
+    contains the index of the port on which the buffer mark is applied.
+
+    Specification text for more details.
+
+    @param [in] hComponent
+        handle of component to execute the command
+    @param [in] Cmd
+        Command for the component to execute
+    @param [in] nParam
+        Parameter for the command to be executed.  When Cmd has the value
+        HW_OMX_CommandStateSet, value is a member of HW_OMX_STATETYPE.  When Cmd has
+        the value HW_OMX_CommandFlush, value of nParam indicates which port(s)
+        to flush. -1 is used to flush all ports a single port index will
+        only flush that port.  When Cmd has the value "HW_OMX_CommandPortDisable"
+        or "HW_OMX_CommandPortEnable", the component's port is given by
+        the value of nParam.  When Cmd has the value "HW_OMX_CommandMarkBuffer"
+        the components pot is given by the value of nParam.
+    @param [in] pCmdData
+        Parameter pointing to the HW_OMX_MARKTYPE structure when Cmd has the value
+        "HW_OMX_CommandMarkBuffer".
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define HW_OMX_SendCommand(                                    \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                                          \
+     ((HW_OMX_COMPONENTTYPE*)(hComponent))->SendCommand(       \
+         hComponent,                                        \
+         Cmd,                                               \
+         nParam,                                            \
+         pCmdData)                          /* Macro End */
+
+
+/** The HW_OMX_GetParameter macro will get one of the current parameter
+    settings from the component.  This macro cannot only be invoked when
+    the component is in the HW_OMX_StateInvalid state.  The nParamIndex
+    parameter is used to indicate which structure is being requested from
+    the component.  The application shall allocate the correct structure
+    and shall fill in the structure size and version information before
+    invoking this macro.  When the parameter applies to a port, the
+    caller shall fill in the appropriate nPortIndex value indicating the
+    port on which the parameter applies. If the component has not had
+    any settings changed, then the component should return a set of
+    valid DEFAULT  parameters for the component.  This is a blocking
+    call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [in] nParamIndex
+        Index of the structure to be filled.  This value is from the
+        HW_OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentParameterStructure
+        Pointer to application allocated structure to be filled by the
+        component.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define HW_OMX_GetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                       \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->GetParameter(       \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The HW_OMX_SetParameter macro will send an initialization parameter
+    structure to a component.  Each structure shall be sent one at a time,
+    in a separate invocation of the macro.  This macro can only be
+    invoked when the component is in the HW_OMX_StateLoaded state, or the
+    port is disabled (when the parameter applies to a port). The
+    nParamIndex parameter is used to indicate which structure is being
+    passed to the component.  The application shall allocate the
+    correct structure and shall fill in the structure size and version
+    information (as well as the actual data) before invoking this macro.
+    The application is free to dispose of this structure after the call
+    as the component is required to copy any data it shall retain.  This
+    is a blocking call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be sent.  This value is from the
+        HW_OMX_INDEXTYPE enumeration.
+    @param [in] pComponentParameterStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define HW_OMX_SetParameter(                                   \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)                       \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->SetParameter(       \
+        hComponent,                                         \
+        nParamIndex,                                        \
+        pComponentParameterStructure)    /* Macro End */
+
+
+/** The HW_OMX_GetConfig macro will get one of the configuration structures
+    from a component.  This macro can be invoked anytime after the
+    component has been loaded.  The nParamIndex call parameter is used to
+    indicate which structure is being requested from the component.  The
+    application shall allocate the correct structure and shall fill in the
+    structure size and version information before invoking this macro.
+    If the component has not had this configuration parameter sent before,
+    then the component should return a set of valid DEFAULT values for the
+    component.  This is a blocking call.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [in] nIndex
+        Index of the structure to be filled.  This value is from the
+        HW_OMX_INDEXTYPE enumeration.
+    @param [in,out] pComponentConfigStructure
+        pointer to application allocated structure to be filled by the
+        component.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+*/
+#define HW_OMX_GetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                          \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->GetConfig(          \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The HW_OMX_SetConfig macro will send one of the configuration
+    structures to a component.  Each structure shall be sent one at a time,
+    each in a separate invocation of the macro.  This macro can be invoked
+    anytime after the component has been loaded.  The application shall
+    allocate the correct structure and shall fill in the structure size
+    and version information (as well as the actual data) before invoking
+    this macro.  The application is free to dispose of this structure after
+    the call as the component is required to copy any data it shall retain.
+    This is a blocking call.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [in] nConfigIndex
+        Index of the structure to be sent.  This value is from the
+        HW_OMX_INDEXTYPE enumeration above.
+    @param [in] pComponentConfigStructure
+        pointer to application allocated structure to be used for
+        initialization by the component.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define HW_OMX_SetConfig(                                      \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)                          \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->SetConfig(          \
+        hComponent,                                         \
+        nConfigIndex,                                       \
+        pComponentConfigStructure)       /* Macro End */
+
+
+/** The HW_OMX_GetExtensionIndex macro will invoke a component to translate
+    a vendor specific configuration or parameter string into an OMX
+    structure index.  There is no requirement for the vendor to support
+    this command for the indexes already found in the HW_OMX_INDEXTYPE
+    enumeration (this is done to save space in small components).  The
+    component shall support all vendor supplied extension indexes not found
+    in the master HW_OMX_INDEXTYPE enumeration.  This is a blocking call.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @param [in] cParameterName
+        HW_OMX_STRING that shall be less than 128 characters long including
+        the trailing null byte.  This is the string that will get
+        translated by the component into a configuration index.
+    @param [out] pIndexType
+        a pointer to a HW_OMX_INDEXTYPE to receive the index value.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define HW_OMX_GetExtensionIndex(                              \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                                         \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->GetExtensionIndex(  \
+        hComponent,                                         \
+        cParameterName,                                     \
+        pIndexType)                     /* Macro End */
+
+
+/** The HW_OMX_GetState macro will invoke the component to get the current
+    state of the component and place the state value into the location
+    pointed to by pState.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [out] pState
+        pointer to the location to receive the state.  The value returned
+        is one of the HW_OMX_STATETYPE members
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp
+ */
+#define HW_OMX_GetState(                                       \
+        hComponent,                                         \
+        pState)                                             \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->GetState(           \
+        hComponent,                                         \
+        pState)                         /* Macro End */
+
+
+/** The HW_OMX_UseBuffer macro will request that the component use
+    a buffer (and allocate its own buffer header) already allocated
+    by another component, or by the IL Client. This is a blocking
+    call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an HW_OMX_BUFFERHEADERTYPE structure used to receive the
+        pointer to the buffer header
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+
+#define HW_OMX_UseBuffer(                                      \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)                                         \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->UseBuffer(          \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           nSizeBytes,                                      \
+           pBuffer)
+
+
+/** The HW_OMX_AllocateBuffer macro will request that the component allocate
+    a new buffer and buffer header.  The component will allocate the
+    buffer and the buffer header and return a pointer to the buffer
+    header.  This is a blocking call.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an HW_OMX_BUFFERHEADERTYPE structure used to receive
+        the pointer to the buffer header
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the
+        buffer header structure.
+    @param [in] nSizeBytes
+        size of the buffer to allocate.  Used when bAllocateNew is true.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define HW_OMX_AllocateBuffer(                                 \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                                         \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->AllocateBuffer(     \
+        hComponent,                                         \
+        ppBuffer,                                           \
+        nPortIndex,                                         \
+        pAppPrivate,                                        \
+        nSizeBytes)                     /* Macro End */
+
+
+/** The HW_OMX_FreeBuffer macro will release a buffer header from the component
+    which was allocated using either HW_OMX_AllocateBuffer or HW_OMX_UseBuffer. If
+    the component allocated the buffer (see the HW_OMX_UseBuffer macro) then
+    the component shall free the buffer and buffer header. This is a
+    blocking call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.
+    @param [in] pBuffer
+        pointer to an HW_OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define HW_OMX_FreeBuffer(                                     \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                                            \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->FreeBuffer(         \
+        hComponent,                                         \
+        nPortIndex,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The HW_OMX_EmptyThisBuffer macro will send a buffer full of data to an
+    input port of a component.  The buffer will be emptied by the component
+    and returned to the application via the EmptyBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then empty the buffer, later, at the proper
+    time.  As expected, this macro may be invoked only while the component
+    is in the HW_OMX_StateExecuting.  If nPortIndex does not specify an input
+    port, the component shall return an error.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an HW_OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define HW_OMX_EmptyThisBuffer(                                \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->EmptyThisBuffer(    \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+/** The HW_OMX_FillThisBuffer macro will send an empty buffer to an
+    output port of a component.  The buffer will be filled by the component
+    and returned to the application via the FillBufferDone call back.
+    This is a non-blocking call in that the component will record the buffer
+    and return immediately and then fill the buffer, later, at the proper
+    time.  As expected, this macro may be invoked only while the component
+    is in the HW_OMX_ExecutingState.  If nPortIndex does not specify an output
+    port, the component shall return an error.
+
+    The component should return from this call within 5 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [in] pBuffer
+        pointer to an HW_OMX_BUFFERHEADERTYPE structure allocated with UseBuffer
+        or AllocateBuffer.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define HW_OMX_FillThisBuffer(                                 \
+        hComponent,                                         \
+        pBuffer)                                            \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->FillThisBuffer(     \
+        hComponent,                                         \
+        pBuffer)                        /* Macro End */
+
+
+
+/** The HW_OMX_UseEGLImage macro will request that the component use
+    a EGLImage provided by EGL (and allocate its own buffer header)
+    This is a blocking call.
+
+    The component should return from this call within 20 msec.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the HW_OMX_GetHandle function.
+    @param [out] ppBuffer
+        pointer to an HW_OMX_BUFFERHEADERTYPE structure used to receive the
+        pointer to the buffer header.  Note that the memory location used
+        for this buffer is NOT visible to the IL Client.
+    @param [in] nPortIndex
+        nPortIndex is used to select the port on the component the buffer will
+        be used with.  The port can be found by using the nPortIndex
+        value as an index into the Port Definition array of the component.
+    @param [in] pAppPrivate
+        pAppPrivate is used to initialize the pAppPrivate member of the
+        buffer header structure.
+    @param [in] eglImage
+        eglImage contains the handle of the EGLImage to use as a buffer on the
+        specified port.  The component is expected to validate properties of
+        the EGLImage against the configuration of the port to ensure the component
+        can use the EGLImage as a buffer.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup comp buf
+ */
+#define HW_OMX_UseEGLImage(                                    \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)                                        \
+    ((HW_OMX_COMPONENTTYPE*)(hComponent))->UseEGLImage(        \
+           hComponent,                                      \
+           ppBufferHdr,                                     \
+           nPortIndex,                                      \
+           pAppPrivate,                                     \
+           eglImage)
+
+/** The HW_OMX_Init method is used to initialize the OMX core.  It shall be the
+    first call made into OMX and it should only be executed one time without
+    an interviening HW_OMX_Deinit call.
+
+    The core should return from this call within 20 msec.
+
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+HW_OMX_API HW_OMX_ERRORTYPE HW_OMX_APIENTRY HW_OMX_Init(void);
+
+
+/** The HW_OMX_Deinit method is used to deinitialize the OMX core.  It shall be
+    the last call made into OMX. In the event that the core determines that
+    thare are components loaded when this call is made, the core may return
+    with an error rather than try to unload the components.
+
+    The core should return from this call within 20 msec.
+
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+HW_OMX_API HW_OMX_ERRORTYPE HW_OMX_APIENTRY HW_OMX_Deinit(void);
+
+
+/** The HW_OMX_ComponentNameEnum method will enumerate through all the names of
+    recognised valid components in the system. This function is provided
+    as a means to detect all the components in the system run-time. There is
+    no strict ordering to the enumeration order of component names, although
+    each name will only be enumerated once.  If the OMX core supports run-time
+    installation of new components, it is only requried to detect newly
+    installed components when the first call to enumerate component names
+    is made (i.e. when nIndex is 0x0).
+
+    The core should return from this call in 20 msec.
+
+    @param [out] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are
+        assigned by the vendor, but shall start with "OMX." and then have
+        the Vendor designation next.
+    @param [in] nNameLength
+        number of characters in the cComponentName string.  With all
+        component name strings restricted to less than 128 characters
+        (including the trailing null) it is recomended that the caller
+        provide a input string for the cComponentName of 128 characters.
+    @param [in] nIndex
+        number containing the enumeration index for the component.
+        Multiple calls to HW_OMX_ComponentNameEnum with increasing values
+        of nIndex will enumerate through the component names in the
+        system until HW_OMX_ErrorNoMore is returned.  The value of nIndex
+        is 0 to (N-1), where N is the number of valid installed components
+        in the system.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  When the value of nIndex exceeds the number of
+        components in the system minus 1, HW_OMX_ErrorNoMore will be
+        returned. Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+HW_OMX_API HW_OMX_ERRORTYPE HW_OMX_APIENTRY HW_OMX_ComponentNameEnum(
+    HW_OMX_OUT HW_OMX_STRING cComponentName,
+    HW_OMX_IN  HW_OMX_U32 nNameLength,
+    HW_OMX_IN  HW_OMX_U32 nIndex);
+
+
+/** The HW_OMX_GetHandle method will locate the component specified by the
+    component name given, load that component into memory and then invoke
+    the component's methods to create an instance of the component.
+
+    The core should return from this call within 20 msec.
+
+    @param [out] pHandle
+        pointer to an HW_OMX_HANDLETYPE pointer to be filled in by this method.
+    @param [in] cComponentName
+        pointer to a null terminated string with the component name.  The
+        names of the components are strings less than 127 bytes in length
+        plus the trailing null for a maximum size of 128 bytes.  An example
+        of a valid component name is "OMX.TI.AUDIO.DSP.MIXER\0".  Names are
+        assigned by the vendor, but shall start with "OMX." and then have
+        the Vendor designation next.
+    @param [in] pAppData
+        pointer to an application defined value that will be returned
+        during callbacks so that the application can identify the source
+        of the callback.
+    @param [in] pCallBacks
+        pointer to a HW_OMX_CALLBACKTYPE structure that will be passed to the
+        component to initialize it with.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+HW_OMX_API HW_OMX_ERRORTYPE HW_OMX_APIENTRY HW_OMX_GetHandle(
+    HW_OMX_OUT HW_OMX_HANDLETYPE* pHandle,
+    HW_OMX_IN  HW_OMX_STRING cComponentName,
+    HW_OMX_IN  HW_OMX_PTR pAppData,
+    HW_OMX_IN  HW_OMX_CALLBACKTYPE* pCallBacks);
+
+
+/** The HW_OMX_FreeHandle method will free a handle allocated by the HW_OMX_GetHandle
+    method.  If the component reference count goes to zero, the component will
+    be unloaded from memory.
+
+    The core should return from this call within 20 msec when the component is
+    in the HW_OMX_StateLoaded state.
+
+    @param [in] hComponent
+        Handle of the component to be accessed.  This is the component
+        handle returned by the call to the GetHandle function.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+    @ingroup core
+ */
+HW_OMX_API HW_OMX_ERRORTYPE HW_OMX_APIENTRY HW_OMX_FreeHandle(
+    HW_OMX_IN  HW_OMX_HANDLETYPE hComponent);
+
+
+
+/** The HW_OMX_SetupTunnel method will handle the necessary calls to the components
+    to setup the specified tunnel the two components.  NOTE: This is
+    an actual method (not a #define macro).  This method will make calls into
+    the component ComponentTunnelRequest method to do the actual tunnel
+    connection.
+
+    The ComponentTunnelRequest method on both components will be called.
+    This method shall not be called unless the component is in the
+    HW_OMX_StateLoaded state except when the ports used for the tunnel are
+    disabled. In this case, the component may be in the HW_OMX_StateExecuting,
+    HW_OMX_StatePause, or HW_OMX_StateIdle states.
+
+    The core should return from this call within 20 msec.
+
+    @param [in] hOutput
+        Handle of the component to be accessed.  Also this is the handle
+        of the component whose port, specified in the nPortOutput parameter
+        will be used the source for the tunnel. This is the component handle
+        returned by the call to the HW_OMX_GetHandle function.  There is a
+        requirement that hOutput be the source for the data when
+        tunelling (i.e. nPortOutput is an output port).  If 0x0, the component
+        specified in hInput will have it's port specified in nPortInput
+        setup for communication with the application / IL client.
+    @param [in] nPortOutput
+        nPortOutput is used to select the source port on component to be
+        used in the tunnel.
+    @param [in] hInput
+        This is the component to setup the tunnel with. This is the handle
+        of the component whose port, specified in the nPortInput parameter
+        will be used the destination for the tunnel. This is the component handle
+        returned by the call to the HW_OMX_GetHandle function.  There is a
+        requirement that hInput be the destination for the data when
+        tunelling (i.e. nPortInut is an input port).   If 0x0, the component
+        specified in hOutput will have it's port specified in nPortPOutput
+        setup for communication with the application / IL client.
+    @param [in] nPortInput
+        nPortInput is used to select the destination port on component to be
+        used in the tunnel.
+    @return HW_OMX_ERRORTYPE
+        If the command successfully executes, the return code will be
+        HW_OMX_ErrorNone.  Otherwise the appropriate OMX error will be returned.
+        When HW_OMX_ErrorNotImplemented is returned, one or both components is
+        a non-interop component and does not support tunneling.
+
+        On failure, the ports of both components are setup for communication
+        with the application / IL Client.
+    @ingroup core tun
+ */
+HW_OMX_API HW_OMX_ERRORTYPE HW_OMX_APIENTRY HW_OMX_SetupTunnel(
+    HW_OMX_IN  HW_OMX_HANDLETYPE hOutput,
+    HW_OMX_IN  HW_OMX_U32 nPortOutput,
+    HW_OMX_IN  HW_OMX_HANDLETYPE hInput,
+    HW_OMX_IN  HW_OMX_U32 nPortInput);
+
+/** @ingroup cp */
+HW_OMX_API HW_OMX_ERRORTYPE   HW_OMX_GetContentPipe(
+    HW_OMX_OUT HW_OMX_HANDLETYPE *hPipe,
+    HW_OMX_IN HW_OMX_STRING szURI);
+
+/** The HW_OMX_GetComponentsOfRole method will return the number of components that support the given
+    role and (if the compNames field is non-NULL) the names of those components. The call will fail if
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the compNames field NULL to determine the number of component names
+        * second call this function with the compNames field pointing to an array of names allocated
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+
+    @param [in] role
+        This is generic standard component name consisting only of component class
+        name and the type within that class (e.g. 'audio_decoder.aac').
+    @param [inout] pNumComps
+        This is used both as input and output.
+
+        If compNames is NULL, the input is ignored and the output specifies how many components support
+        the given role.
+
+        If compNames is not NULL, on input it bounds the size of the input structure and
+        on output, it specifies the number of components string names listed within the compNames parameter.
+    @param [inout] compNames
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings which accepts
+        a list of the names of all physical components that implement the specified standard component name.
+        Each name is NULL terminated. numComps indicates the number of names.
+    @ingroup core
+ */
+HW_OMX_API HW_OMX_ERRORTYPE HW_OMX_GetComponentsOfRole (
+    HW_OMX_IN      HW_OMX_STRING role,
+    HW_OMX_INOUT   HW_OMX_U32 *pNumComps,
+    HW_OMX_INOUT   HW_OMX_U8  **compNames);
+
+/** The HW_OMX_GetRolesOfComponent method will return the number of roles supported by the given
+    component and (if the roles field is non-NULL) the names of those roles. The call will fail if
+    an insufficiently sized array of names is supplied. To ensure the array is sufficiently sized the
+    client should:
+        * first call this function with the roles field NULL to determine the number of role names
+        * second call this function with the roles field pointing to an array of names allocated
+          according to the number returned by the first call.
+
+    The core should return from this call within 5 msec.
+
+    @param [in] compName
+        This is the name of the component being queried about.
+    @param [inout] pNumRoles
+        This is used both as input and output.
+
+        If roles is NULL, the input is ignored and the output specifies how many roles the component supports.
+
+        If compNames is not NULL, on input it bounds the size of the input structure and
+        on output, it specifies the number of roles string names listed within the roles parameter.
+    @param [out] roles
+        If NULL this field is ignored. If non-NULL this points to an array of 128-byte strings
+        which accepts a list of the names of all standard components roles implemented on the
+        specified component name. numComps indicates the number of names.
+    @ingroup core
+ */
+HW_OMX_API HW_OMX_ERRORTYPE HW_OMX_GetRolesOfComponent (
+    HW_OMX_IN      HW_OMX_STRING compName,
+    HW_OMX_INOUT   HW_OMX_U32 *pNumRoles,
+    HW_OMX_OUT     HW_OMX_U8 **roles);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
Index: ffmpeg/libavcodec/HW_OMX_IVCommon.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_IVCommon.h
@@ -0,0 +1,966 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/**
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/**
+ * @file HW_OMX_IVCommon.h - OpenMax IL version 1.1.2
+ *  The structures needed by Video and Image components to exchange
+ *  parameters and configuration data with the components.
+ */
+#ifndef HW_OMX_IVCommon_h
+#define HW_OMX_IVCommon_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/**
+ * Each OMX header must include all required header files to allow the header
+ * to compile without errors.  The includes below are required for this header
+ * file to compile successfully
+ */
+
+#include "HW_OMX_Core.h"
+
+/** @defgroup iv OpenMAX IL Imaging and Video Domain
+ * Common structures for OpenMAX IL Imaging and Video domains
+ * @{
+ */
+
+
+/**
+ * Enumeration defining possible uncompressed image/video formats.
+ *
+ * ENUMS:
+ *  Unused                 : Placeholder value when format is N/A
+ *  Monochrome             : black and white
+ *  8bitRGB332             : Red 7:5, Green 4:2, Blue 1:0
+ *  12bitRGB444            : Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB4444          : Alpha 15:12, Red 11:8, Green 7:4, Blue 3:0
+ *  16bitARGB1555          : Alpha 15, Red 14:10, Green 9:5, Blue 4:0
+ *  16bitRGB565            : Red 15:11, Green 10:5, Blue 4:0
+ *  16bitBGR565            : Blue 15:11, Green 10:5, Red 4:0
+ *  18bitRGB666            : Red 17:12, Green 11:6, Blue 5:0
+ *  18bitARGB1665          : Alpha 17, Red 16:11, Green 10:5, Blue 4:0
+ *  19bitARGB1666          : Alpha 18, Red 17:12, Green 11:6, Blue 5:0
+ *  24bitRGB888            : Red 24:16, Green 15:8, Blue 7:0
+ *  24bitBGR888            : Blue 24:16, Green 15:8, Red 7:0
+ *  24bitARGB1887          : Alpha 23, Red 22:15, Green 14:7, Blue 6:0
+ *  25bitARGB1888          : Alpha 24, Red 23:16, Green 15:8, Blue 7:0
+ *  32bitBGRA8888          : Blue 31:24, Green 23:16, Red 15:8, Alpha 7:0
+ *  32bitARGB8888          : Alpha 31:24, Red 23:16, Green 15:8, Blue 7:0
+ *  YUV411Planar           : U,Y are subsampled by a factor of 4 horizontally
+ *  YUV411PackedPlanar     : packed per payload in planar slices
+ *  YUV420Planar           : Three arrays Y,U,V.
+ *  YUV420PackedPlanar     : packed per payload in planar slices
+ *  YUV420SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YUV422Planar           : Three arrays Y,U,V.
+ *  YUV422PackedPlanar     : packed per payload in planar slices
+ *  YUV422SemiPlanar       : Two arrays, one is all Y, the other is U and V
+ *  YCbYCr                 : Organized as 16bit YUYV (i.e. YCbYCr)
+ *  YCrYCb                 : Organized as 16bit YVYU (i.e. YCrYCb)
+ *  CbYCrY                 : Organized as 16bit UYVY (i.e. CbYCrY)
+ *  CrYCbY                 : Organized as 16bit VYUY (i.e. CrYCbY)
+ *  YUV444Interleaved      : Each pixel contains equal parts YUV
+ *  RawBayer8bit           : SMIA camera output format
+ *  RawBayer10bit          : SMIA camera output format
+ *  RawBayer8bitcompressed : SMIA camera output format
+ */
+typedef enum HW_OMX_COLOR_FORMATTYPE {
+    HW_OMX_COLOR_FormatUnused,
+    HW_OMX_COLOR_FormatMonochrome,
+    HW_OMX_COLOR_Format8bitRGB332,
+    HW_OMX_COLOR_Format12bitRGB444,
+    HW_OMX_COLOR_Format16bitARGB4444,
+    HW_OMX_COLOR_Format16bitARGB1555,
+    HW_OMX_COLOR_Format16bitRGB565,
+    HW_OMX_COLOR_Format16bitBGR565,
+    HW_OMX_COLOR_Format18bitRGB666,
+    HW_OMX_COLOR_Format18bitARGB1665,
+    HW_OMX_COLOR_Format19bitARGB1666,
+    HW_OMX_COLOR_Format24bitRGB888,
+    HW_OMX_COLOR_Format24bitBGR888,
+    HW_OMX_COLOR_Format24bitARGB1887,
+    HW_OMX_COLOR_Format25bitARGB1888,
+    HW_OMX_COLOR_Format32bitBGRA8888,
+    HW_OMX_COLOR_Format32bitARGB8888,
+    HW_OMX_COLOR_FormatYUV411Planar,
+    HW_OMX_COLOR_FormatYUV411PackedPlanar,
+    HW_OMX_COLOR_FormatYUV420Planar,
+    HW_OMX_COLOR_FormatYUV420PackedPlanar,
+    HW_OMX_COLOR_FormatYUV420SemiPlanar,
+    HW_OMX_COLOR_FormatYUV422Planar,
+    HW_OMX_COLOR_FormatYUV422PackedPlanar,
+    HW_OMX_COLOR_FormatYUV422SemiPlanar,
+    HW_OMX_COLOR_FormatYCbYCr,
+    HW_OMX_COLOR_FormatYCrYCb,
+    HW_OMX_COLOR_FormatCbYCrY,
+    HW_OMX_COLOR_FormatCrYCbY,
+    HW_OMX_COLOR_FormatYUV444Interleaved,
+    HW_OMX_COLOR_FormatRawBayer8bit,
+    HW_OMX_COLOR_FormatRawBayer10bit,
+    HW_OMX_COLOR_FormatRawBayer8bitcompressed,
+    HW_OMX_COLOR_FormatL2,
+    HW_OMX_COLOR_FormatL4,
+    HW_OMX_COLOR_FormatL8,
+    HW_OMX_COLOR_FormatL16,
+    HW_OMX_COLOR_FormatL24,
+    HW_OMX_COLOR_FormatL32,
+    HW_OMX_COLOR_FormatYUV420PackedSemiPlanar,
+    HW_OMX_COLOR_FormatYUV422PackedSemiPlanar,
+    HW_OMX_COLOR_Format18BitBGR666,
+    HW_OMX_COLOR_Format24BitARGB6666,
+    HW_OMX_COLOR_Format24BitABGR6666,
+    HW_OMX_COLOR_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_COLOR_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    /**<Reserved android opaque colorformat. Tells the encoder that
+     * the actual colorformat will be  relayed by the
+     * Gralloc Buffers.
+     * FIXME: In the process of reserving some enum values for
+     * Android-specific OMX IL colorformats. Change this enum to
+     * an acceptable range once that is done.
+     * */
+    HW_OMX_COLOR_FormatAndroidOpaque = 0x7F000789,
+    HW_OMX_COLOR_Format32BitRGBA8888 = 0x7F00A000,
+    /** Flexible 8-bit YUV format.  Codec should report this format
+     *  as being supported if it supports any YUV420 packed planar
+     *  or semiplanar formats.  When port is set to use this format,
+     *  codec can substitute any YUV420 packed planar or semiplanar
+     *  format for it. */
+    HW_OMX_COLOR_FormatYUV420Flexible = 0x7F420888,
+
+    // 10-bit or 12-bit YUV format, LSB-justified (0's on higher bits)
+    HW_OMX_COLOR_FormatYUV420Planar16 = 0x7F42016B,
+
+    // Packed 10-bit YUV444 representation that includes 2 bits of alpha. Each pixel is
+    // 32-bit. Bits 0-9 contain the U sample, bits 10-19 contain the Y sample,
+    // bits 20-29 contain the V sample, and bits 30-31 contain the alpha value.
+    HW_OMX_COLOR_FormatYUV444Y410 = 0x7F444AAA,
+
+    HW_OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
+    HW_OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
+    HW_OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
+    HW_OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002,
+    HW_OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar32m = 0x7FA30C04,
+    HW_OMX_COLOR_FormatMax = 0x7FFFFFFF
+} HW_OMX_COLOR_FORMATTYPE;
+
+
+/**
+ * Defines the matrix for conversion from RGB to YUV or vice versa.
+ * iColorMatrix should be initialized with the fixed point values
+ * used in converting between formats.
+ */
+typedef struct HW_OMX_CONFIG_COLORCONVERSIONTYPE {
+    HW_OMX_U32 nSize;              /**< Size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version info */
+    HW_OMX_U32 nPortIndex;         /**< Port that this struct applies to */
+    HW_OMX_S32 xColorMatrix[3][3]; /**< Stored in signed Q16 format */
+    HW_OMX_S32 xColorOffset[4];    /**< Stored in signed Q16 format */
+}HW_OMX_CONFIG_COLORCONVERSIONTYPE;
+
+
+/**
+ * Structure defining percent to scale each frame dimension.  For example:
+ * To make the width 50% larger, use fWidth = 1.5 and to make the width
+ * 1/2 the original size, use fWidth = 0.5
+ */
+typedef struct HW_OMX_CONFIG_SCALEFACTORTYPE {
+    HW_OMX_U32 nSize;            /**< Size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version info */
+    HW_OMX_U32 nPortIndex;       /**< Port that this struct applies to */
+    HW_OMX_S32 xWidth;           /**< Fixed point value stored as Q16 */
+    HW_OMX_S32 xHeight;          /**< Fixed point value stored as Q16 */
+}HW_OMX_CONFIG_SCALEFACTORTYPE;
+
+
+/**
+ * Enumeration of possible image filter types
+ */
+typedef enum HW_OMX_IMAGEFILTERTYPE {
+    HW_OMX_ImageFilterNone,
+    HW_OMX_ImageFilterNoise,
+    HW_OMX_ImageFilterEmboss,
+    HW_OMX_ImageFilterNegative,
+    HW_OMX_ImageFilterSketch,
+    HW_OMX_ImageFilterOilPaint,
+    HW_OMX_ImageFilterHatch,
+    HW_OMX_ImageFilterGpen,
+    HW_OMX_ImageFilterAntialias,
+    HW_OMX_ImageFilterDeRing,
+    HW_OMX_ImageFilterSolarize,
+    HW_OMX_ImageFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_ImageFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_ImageFilterMax = 0x7FFFFFFF
+} HW_OMX_IMAGEFILTERTYPE;
+
+
+/**
+ * Image filter configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to
+ *  eImageFilter : Image filter type enumeration
+ */
+typedef struct HW_OMX_CONFIG_IMAGEFILTERTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_IMAGEFILTERTYPE eImageFilter;
+} HW_OMX_CONFIG_IMAGEFILTERTYPE;
+
+
+/**
+ * Customized U and V for color enhancement
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes
+ *  nVersion          : OMX specification version information
+ *  nPortIndex        : Port that this structure applies to
+ *  bColorEnhancement : Enable/disable color enhancement
+ *  nCustomizedU      : Practical values: 16-240, range: 0-255, value set for
+ *                      U component
+ *  nCustomizedV      : Practical values: 16-240, range: 0-255, value set for
+ *                      V component
+ */
+typedef struct HW_OMX_CONFIG_COLORENHANCEMENTTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bColorEnhancement;
+    HW_OMX_U8 nCustomizedU;
+    HW_OMX_U8 nCustomizedV;
+} HW_OMX_CONFIG_COLORENHANCEMENTTYPE;
+
+
+/**
+ * Define color key and color key mask
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nARGBColor : 32bit Alpha, Red, Green, Blue Color
+ *  nARGBMask  : 32bit Mask for Alpha, Red, Green, Blue channels
+ */
+typedef struct HW_OMX_CONFIG_COLORKEYTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nARGBColor;
+    HW_OMX_U32 nARGBMask;
+} HW_OMX_CONFIG_COLORKEYTYPE;
+
+
+/**
+ * List of color blend types for pre/post processing
+ *
+ * ENUMS:
+ *  None          : No color blending present
+ *  AlphaConstant : Function is (alpha_constant * src) +
+ *                  (1 - alpha_constant) * dst)
+ *  AlphaPerPixel : Function is (alpha * src) + (1 - alpha) * dst)
+ *  Alternate     : Function is alternating pixels from src and dst
+ *  And           : Function is (src & dst)
+ *  Or            : Function is (src | dst)
+ *  Invert        : Function is ~src
+ */
+typedef enum HW_OMX_COLORBLENDTYPE {
+    HW_OMX_ColorBlendNone,
+    HW_OMX_ColorBlendAlphaConstant,
+    HW_OMX_ColorBlendAlphaPerPixel,
+    HW_OMX_ColorBlendAlternate,
+    HW_OMX_ColorBlendAnd,
+    HW_OMX_ColorBlendOr,
+    HW_OMX_ColorBlendInvert,
+    HW_OMX_ColorBlendKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_ColorBlendVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_ColorBlendMax = 0x7FFFFFFF
+} HW_OMX_COLORBLENDTYPE;
+
+
+/**
+ * Color blend configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize             : Size of the structure in bytes
+ *  nVersion          : OMX specification version information
+ *  nPortIndex        : Port that this structure applies to
+ *  nRGBAlphaConstant : Constant global alpha values when global alpha is used
+ *  eColorBlend       : Color blend type enumeration
+ */
+typedef struct HW_OMX_CONFIG_COLORBLENDTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nRGBAlphaConstant;
+    HW_OMX_COLORBLENDTYPE  eColorBlend;
+} HW_OMX_CONFIG_COLORBLENDTYPE;
+
+
+/**
+ * Hold frame dimension
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nWidth     : Frame width in pixels
+ *  nHeight    : Frame height in pixels
+ */
+typedef struct HW_OMX_FRAMESIZETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nWidth;
+    HW_OMX_U32 nHeight;
+} HW_OMX_FRAMESIZETYPE;
+
+
+/**
+ * Rotation configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nRotation  : +/- integer rotation value
+ */
+typedef struct HW_OMX_CONFIG_ROTATIONTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_S32 nRotation;
+} HW_OMX_CONFIG_ROTATIONTYPE;
+
+
+/**
+ * Possible mirroring directions for pre/post processing
+ *
+ * ENUMS:
+ *  None       : No mirroring
+ *  Vertical   : Vertical mirroring, flip on X axis
+ *  Horizontal : Horizontal mirroring, flip on Y axis
+ *  Both       : Both vertical and horizontal mirroring
+ */
+typedef enum HW_OMX_MIRRORTYPE {
+    HW_OMX_MirrorNone = 0,
+    HW_OMX_MirrorVertical,
+    HW_OMX_MirrorHorizontal,
+    HW_OMX_MirrorBoth,
+    HW_OMX_MirrorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_MirrorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_MirrorMax = 0x7FFFFFFF
+} HW_OMX_MIRRORTYPE;
+
+
+/**
+ * Mirroring configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  eMirror    : Mirror type enumeration
+ */
+typedef struct HW_OMX_CONFIG_MIRRORTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_MIRRORTYPE  eMirror;
+} HW_OMX_CONFIG_MIRRORTYPE;
+
+
+/**
+ * Position information only
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nX         : X coordinate for the point
+ *  nY         : Y coordinate for the point
+ */
+typedef struct HW_OMX_CONFIG_POINTTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_S32 nX;
+    HW_OMX_S32 nY;
+} HW_OMX_CONFIG_POINTTYPE;
+
+
+/**
+ * Frame size plus position
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nLeft      : X Coordinate of the top left corner of the rectangle
+ *  nTop       : Y Coordinate of the top left corner of the rectangle
+ *  nWidth     : Width of the rectangle
+ *  nHeight    : Height of the rectangle
+ */
+typedef struct HW_OMX_CONFIG_RECTTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_S32 nLeft;
+    HW_OMX_S32 nTop;
+    HW_OMX_U32 nWidth;
+    HW_OMX_U32 nHeight;
+} HW_OMX_CONFIG_RECTTYPE;
+
+
+/**
+ * Deblocking state; it is required to be set up before starting the codec
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  bDeblocking : Enable/disable deblocking mode
+ */
+typedef struct HW_OMX_PARAM_DEBLOCKINGTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bDeblocking;
+} HW_OMX_PARAM_DEBLOCKINGTYPE;
+
+
+/**
+ * Stabilization state
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  bStab      : Enable/disable frame stabilization state
+ */
+typedef struct HW_OMX_CONFIG_FRAMESTABTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bStab;
+} HW_OMX_CONFIG_FRAMESTABTYPE;
+
+
+/**
+ * White Balance control type
+ *
+ * STRUCT MEMBERS:
+ *  SunLight : Referenced in JSR-234
+ *  Flash    : Optimal for device's integrated flash
+ */
+typedef enum HW_OMX_WHITEBALCONTROLTYPE {
+    HW_OMX_WhiteBalControlOff = 0,
+    HW_OMX_WhiteBalControlAuto,
+    HW_OMX_WhiteBalControlSunLight,
+    HW_OMX_WhiteBalControlCloudy,
+    HW_OMX_WhiteBalControlShade,
+    HW_OMX_WhiteBalControlTungsten,
+    HW_OMX_WhiteBalControlFluorescent,
+    HW_OMX_WhiteBalControlIncandescent,
+    HW_OMX_WhiteBalControlFlash,
+    HW_OMX_WhiteBalControlHorizon,
+    HW_OMX_WhiteBalControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_WhiteBalControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_WhiteBalControlMax = 0x7FFFFFFF
+} HW_OMX_WHITEBALCONTROLTYPE;
+
+
+/**
+ * White Balance control configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to
+ *  eWhiteBalControl : White balance enumeration
+ */
+typedef struct HW_OMX_CONFIG_WHITEBALCONTROLTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_WHITEBALCONTROLTYPE eWhiteBalControl;
+} HW_OMX_CONFIG_WHITEBALCONTROLTYPE;
+
+
+/**
+ * Exposure control type
+ */
+typedef enum HW_OMX_EXPOSURECONTROLTYPE {
+    HW_OMX_ExposureControlOff = 0,
+    HW_OMX_ExposureControlAuto,
+    HW_OMX_ExposureControlNight,
+    HW_OMX_ExposureControlBackLight,
+    HW_OMX_ExposureControlSpotLight,
+    HW_OMX_ExposureControlSports,
+    HW_OMX_ExposureControlSnow,
+    HW_OMX_ExposureControlBeach,
+    HW_OMX_ExposureControlLargeAperture,
+    HW_OMX_ExposureControlSmallApperture,
+    HW_OMX_ExposureControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_ExposureControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_ExposureControlMax = 0x7FFFFFFF
+} HW_OMX_EXPOSURECONTROLTYPE;
+
+
+/**
+ * White Balance control configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to
+ *  eExposureControl : Exposure control enumeration
+ */
+typedef struct HW_OMX_CONFIG_EXPOSURECONTROLTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_EXPOSURECONTROLTYPE eExposureControl;
+} HW_OMX_CONFIG_EXPOSURECONTROLTYPE;
+
+
+/**
+ * Defines sensor supported mode.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nFrameRate : Single shot mode is indicated by a 0
+ *  bOneShot   : Enable for single shot, disable for streaming
+ *  sFrameSize : Framesize
+ */
+typedef struct HW_OMX_PARAM_SENSORMODETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nFrameRate;
+    HW_OMX_BOOL bOneShot;
+    HW_OMX_FRAMESIZETYPE sFrameSize;
+} HW_OMX_PARAM_SENSORMODETYPE;
+
+
+/**
+ * Defines contrast level
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nContrast  : Values allowed for contrast -100 to 100, zero means no change
+ */
+typedef struct HW_OMX_CONFIG_CONTRASTTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_S32 nContrast;
+} HW_OMX_CONFIG_CONTRASTTYPE;
+
+
+/**
+ * Defines brightness level
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  nBrightness : 0-100%
+ */
+typedef struct HW_OMX_CONFIG_BRIGHTNESSTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nBrightness;
+} HW_OMX_CONFIG_BRIGHTNESSTYPE;
+
+
+/**
+ * Defines backlight level configuration for a video sink, e.g. LCD panel
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nBacklight : Values allowed for backlight 0-100%
+ *  nTimeout   : Number of milliseconds before backlight automatically turns
+ *               off.  A value of 0x0 disables backight timeout
+ */
+typedef struct HW_OMX_CONFIG_BACKLIGHTTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nBacklight;
+    HW_OMX_U32 nTimeout;
+} HW_OMX_CONFIG_BACKLIGHTTYPE;
+
+
+/**
+ * Defines setting for Gamma
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nGamma     : Values allowed for gamma -100 to 100, zero means no change
+ */
+typedef struct HW_OMX_CONFIG_GAMMATYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_S32 nGamma;
+} HW_OMX_CONFIG_GAMMATYPE;
+
+
+/**
+ * Define for setting saturation
+ *
+ * STRUCT MEMBERS:
+ *  nSize       : Size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  nPortIndex  : Port that this structure applies to
+ *  nSaturation : Values allowed for saturation -100 to 100, zero means
+ *                no change
+ */
+typedef struct HW_OMX_CONFIG_SATURATIONTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_S32 nSaturation;
+} HW_OMX_CONFIG_SATURATIONTYPE;
+
+
+/**
+ * Define for setting Lightness
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nLightness : Values allowed for lightness -100 to 100, zero means no
+ *               change
+ */
+typedef struct HW_OMX_CONFIG_LIGHTNESSTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_S32 nLightness;
+} HW_OMX_CONFIG_LIGHTNESSTYPE;
+
+
+/**
+ * Plane blend configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Index of input port associated with the plane.
+ *  nDepth     : Depth of the plane in relation to the screen. Higher
+ *               numbered depths are "behind" lower number depths.
+ *               This number defaults to the Port Index number.
+ *  nAlpha     : Transparency blending component for the entire plane.
+ *               See blending modes for more detail.
+ */
+typedef struct HW_OMX_CONFIG_PLANEBLENDTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nDepth;
+    HW_OMX_U32 nAlpha;
+} HW_OMX_CONFIG_PLANEBLENDTYPE;
+
+
+/**
+ * Define interlace type
+ *
+ * STRUCT MEMBERS:
+ *  nSize                 : Size of the structure in bytes
+ *  nVersion              : OMX specification version information
+ *  nPortIndex            : Port that this structure applies to
+ *  bEnable               : Enable control variable for this functionality
+ *                          (see below)
+ *  nInterleavePortIndex  : Index of input or output port associated with
+ *                          the interleaved plane.
+ *  pPlanarPortIndexes[4] : Index of input or output planar ports.
+ */
+typedef struct HW_OMX_PARAM_INTERLEAVETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bEnable;
+    HW_OMX_U32 nInterleavePortIndex;
+} HW_OMX_PARAM_INTERLEAVETYPE;
+
+
+/**
+ * Defines the picture effect used for an input picture
+ */
+typedef enum HW_OMX_TRANSITIONEFFECTTYPE {
+    HW_OMX_EffectNone,
+    HW_OMX_EffectFadeFromBlack,
+    HW_OMX_EffectFadeToBlack,
+    HW_OMX_EffectUnspecifiedThroughConstantColor,
+    HW_OMX_EffectDissolve,
+    HW_OMX_EffectWipe,
+    HW_OMX_EffectUnspecifiedMixOfTwoScenes,
+    HW_OMX_EffectKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_EffectVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_EffectMax = 0x7FFFFFFF
+} HW_OMX_TRANSITIONEFFECTTYPE;
+
+
+/**
+ * Structure used to configure current transition effect
+ *
+ * STRUCT MEMBERS:
+ * nSize      : Size of the structure in bytes
+ * nVersion   : OMX specification version information
+ * nPortIndex : Port that this structure applies to
+ * eEffect    : Effect to enable
+ */
+typedef struct HW_OMX_CONFIG_TRANSITIONEFFECTTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_TRANSITIONEFFECTTYPE eEffect;
+} HW_OMX_CONFIG_TRANSITIONEFFECTTYPE;
+
+
+/**
+ * Defines possible data unit types for encoded video data. The data unit
+ * types are used both for encoded video input for playback as well as
+ * encoded video output from recording.
+ */
+typedef enum HW_OMX_DATAUNITTYPE {
+    HW_OMX_DataUnitCodedPicture,
+    HW_OMX_DataUnitVideoSegment,
+    HW_OMX_DataUnitSeveralSegments,
+    HW_OMX_DataUnitArbitraryStreamSection,
+    HW_OMX_DataUnitKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_DataUnitVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_DataUnitMax = 0x7FFFFFFF
+} HW_OMX_DATAUNITTYPE;
+
+
+/**
+ * Defines possible encapsulation types for coded video data unit. The
+ * encapsulation information is used both for encoded video input for
+ * playback as well as encoded video output from recording.
+ */
+typedef enum HW_OMX_DATAUNITENCAPSULATIONTYPE {
+    HW_OMX_DataEncapsulationElementaryStream,
+    HW_OMX_DataEncapsulationGenericPayload,
+    HW_OMX_DataEncapsulationRtpPayload,
+    HW_OMX_DataEncapsulationKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_DataEncapsulationVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_DataEncapsulationMax = 0x7FFFFFFF
+} HW_OMX_DATAUNITENCAPSULATIONTYPE;
+
+
+/**
+ * Structure used to configure the type of being decoded/encoded
+ */
+typedef struct HW_OMX_PARAM_DATAUNITTYPE {
+    HW_OMX_U32 nSize;            /**< Size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    HW_OMX_DATAUNITTYPE eUnitType;
+    HW_OMX_DATAUNITENCAPSULATIONTYPE eEncapsulationType;
+} HW_OMX_PARAM_DATAUNITTYPE;
+
+
+/**
+ * Defines dither types
+ */
+typedef enum HW_OMX_DITHERTYPE {
+    HW_OMX_DitherNone,
+    HW_OMX_DitherOrdered,
+    HW_OMX_DitherErrorDiffusion,
+    HW_OMX_DitherOther,
+    HW_OMX_DitherKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_DitherVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_DitherMax = 0x7FFFFFFF
+} HW_OMX_DITHERTYPE;
+
+
+/**
+ * Structure used to configure current type of dithering
+ */
+typedef struct HW_OMX_CONFIG_DITHERTYPE {
+    HW_OMX_U32 nSize;            /**< Size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;       /**< Port that this structure applies to */
+    HW_OMX_DITHERTYPE eDither;   /**< Type of dithering to use */
+} HW_OMX_CONFIG_DITHERTYPE;
+
+typedef struct HW_OMX_CONFIG_CAPTUREMODETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;     /**< Port that this structure applies to */
+    HW_OMX_BOOL bContinuous;   /**< If true then ignore frame rate and emit capture
+                             *   data as fast as possible (otherwise obey port's frame rate). */
+    HW_OMX_BOOL bFrameLimited; /**< If true then terminate capture after the port emits the
+                             *   specified number of frames (otherwise the port does not
+                             *   terminate the capture until instructed to do so by the client).
+                             *   Even if set, the client may manually terminate the capture prior
+                             *   to reaching the limit. */
+    HW_OMX_U32 nFrameLimit;      /**< Limit on number of frames emitted during a capture (only
+                               *   valid if bFrameLimited is set). */
+} HW_OMX_CONFIG_CAPTUREMODETYPE;
+
+typedef enum HW_OMX_METERINGTYPE {
+
+    HW_OMX_MeteringModeAverage,     /**< Center-weighted average metering. */
+    HW_OMX_MeteringModeSpot,        /**< Spot (partial) metering. */
+    HW_OMX_MeteringModeMatrix,      /**< Matrix or evaluative metering. */
+
+    HW_OMX_MeteringKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_MeteringVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_EVModeMax = 0x7fffffff
+} HW_OMX_METERINGTYPE;
+
+typedef struct HW_OMX_CONFIG_EXPOSUREVALUETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_METERINGTYPE eMetering;
+    HW_OMX_S32 xEVCompensation;      /**< Fixed point value stored as Q16 */
+    HW_OMX_U32 nApertureFNumber;     /**< e.g. nApertureFNumber = 2 implies "f/2" - Q16 format */
+    HW_OMX_BOOL bAutoAperture;       /**< Whether aperture number is defined automatically */
+    HW_OMX_U32 nShutterSpeedMsec;    /**< Shutterspeed in milliseconds */
+    HW_OMX_BOOL bAutoShutterSpeed;   /**< Whether shutter speed is defined automatically */
+    HW_OMX_U32 nSensitivity;         /**< e.g. nSensitivity = 100 implies "ISO 100" */
+    HW_OMX_BOOL bAutoSensitivity;    /**< Whether sensitivity is defined automatically */
+} HW_OMX_CONFIG_EXPOSUREVALUETYPE;
+
+/**
+ * Focus region configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  bCenter         : Use center region as focus region of interest
+ *  bLeft           : Use left region as focus region of interest
+ *  bRight          : Use right region as focus region of interest
+ *  bTop            : Use top region as focus region of interest
+ *  bBottom         : Use bottom region as focus region of interest
+ *  bTopLeft        : Use top left region as focus region of interest
+ *  bTopRight       : Use top right region as focus region of interest
+ *  bBottomLeft     : Use bottom left region as focus region of interest
+ *  bBottomRight    : Use bottom right region as focus region of interest
+ */
+typedef struct HW_OMX_CONFIG_FOCUSREGIONTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bCenter;
+    HW_OMX_BOOL bLeft;
+    HW_OMX_BOOL bRight;
+    HW_OMX_BOOL bTop;
+    HW_OMX_BOOL bBottom;
+    HW_OMX_BOOL bTopLeft;
+    HW_OMX_BOOL bTopRight;
+    HW_OMX_BOOL bBottomLeft;
+    HW_OMX_BOOL bBottomRight;
+} HW_OMX_CONFIG_FOCUSREGIONTYPE;
+
+/**
+ * Focus Status type
+ */
+typedef enum HW_OMX_FOCUSSTATUSTYPE {
+    HW_OMX_FocusStatusOff = 0,
+    HW_OMX_FocusStatusRequest,
+    HW_OMX_FocusStatusReached,
+    HW_OMX_FocusStatusUnableToReach,
+    HW_OMX_FocusStatusLost,
+    HW_OMX_FocusStatusKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_FocusStatusVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_FocusStatusMax = 0x7FFFFFFF
+} HW_OMX_FOCUSSTATUSTYPE;
+
+/**
+ * Focus status configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize               : Size of the structure in bytes
+ *  nVersion            : OMX specification version information
+ *  nPortIndex          : Port that this structure applies to
+ *  eFocusStatus        : Specifies the focus status
+ *  bCenterStatus       : Use center region as focus region of interest
+ *  bLeftStatus         : Use left region as focus region of interest
+ *  bRightStatus        : Use right region as focus region of interest
+ *  bTopStatus          : Use top region as focus region of interest
+ *  bBottomStatus       : Use bottom region as focus region of interest
+ *  bTopLeftStatus      : Use top left region as focus region of interest
+ *  bTopRightStatus     : Use top right region as focus region of interest
+ *  bBottomLeftStatus   : Use bottom left region as focus region of interest
+ *  bBottomRightStatus  : Use bottom right region as focus region of interest
+ */
+typedef struct HW_OMX_PARAM_FOCUSSTATUSTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_FOCUSSTATUSTYPE eFocusStatus;
+    HW_OMX_BOOL bCenterStatus;
+    HW_OMX_BOOL bLeftStatus;
+    HW_OMX_BOOL bRightStatus;
+    HW_OMX_BOOL bTopStatus;
+    HW_OMX_BOOL bBottomStatus;
+    HW_OMX_BOOL bTopLeftStatus;
+    HW_OMX_BOOL bTopRightStatus;
+    HW_OMX_BOOL bBottomLeftStatus;
+    HW_OMX_BOOL bBottomRightStatus;
+} HW_OMX_PARAM_FOCUSSTATUSTYPE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_Image.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_Image.h
@@ -0,0 +1,345 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/**
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * @file HW_OMX_Image.h - OpenMax IL version 1.1.2
+ * The structures needed by Image components to exchange parameters and
+ * configuration data with the components.
+ */
+#ifndef HW_OMX_Image_h
+#define HW_OMX_Image_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+
+#include "HW_OMX_IVCommon.h"
+
+/** @defgroup imaging OpenMAX IL Imaging Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Imaging domain
+ * @{
+ */
+
+/**
+ * Enumeration used to define the possible image compression coding.
+ */
+typedef enum HW_OMX_IMAGE_CODINGTYPE {
+    HW_OMX_IMAGE_CodingUnused,      /**< Value when format is N/A */
+    HW_OMX_IMAGE_CodingAutoDetect,  /**< Auto detection of image format */
+    HW_OMX_IMAGE_CodingJPEG,        /**< JPEG/JFIF image format */
+    HW_OMX_IMAGE_CodingJPEG2K,      /**< JPEG 2000 image format */
+    HW_OMX_IMAGE_CodingEXIF,        /**< EXIF image format */
+    HW_OMX_IMAGE_CodingTIFF,        /**< TIFF image format */
+    HW_OMX_IMAGE_CodingGIF,         /**< Graphics image format */
+    HW_OMX_IMAGE_CodingPNG,         /**< PNG image format */
+    HW_OMX_IMAGE_CodingLZW,         /**< LZW image format */
+    HW_OMX_IMAGE_CodingBMP,         /**< Windows Bitmap format */
+    HW_OMX_IMAGE_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_IMAGE_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_IMAGE_CodingMax = 0x7FFFFFFF
+} HW_OMX_IMAGE_CODINGTYPE;
+
+
+/**
+ * Data structure used to define an image path. The number of image paths
+ * for input and output will vary by type of the image component.
+ *
+ *  Input (aka Source) : Zero Inputs, one Output,
+ *  Splitter           : One Input, 2 or more Outputs,
+ *  Processing Element : One Input, one output,
+ *  Mixer              : 2 or more inputs, one output,
+ *  Output (aka Sink)  : One Input, zero outputs.
+ *
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output
+ * image path.  If additional vendor specific data is required, it should
+ * be transmitted to the component using the CustomCommand function.
+ * Compliant components will prepopulate this structure with optimal
+ * values during the HW_OMX_GetParameter() command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on port if
+ *                          uncompressed format is used.  Use 0 for
+ *                          unknown, don't care or variable
+ *  nFrameHeight          : Height of frame to be used on port if
+ *                          uncompressed format is used. Use 0 for
+ *                          unknown, don't care or variable
+ *  nStride               : Number of bytes per span of an image (i.e.
+ *                          indicates the number of bytes to get from
+ *                          span N to span N+1, where negative stride
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of
+ *                          the component. When HW_OMX_IMAGE_CodingUnused is
+ *                          specified, eColorFormat is valid
+ *  eColorFormat          : Decompressed format used by this component
+ *  pNativeWindow         : Platform specific reference for a window object if a
+ *                          display sink , otherwise this field is 0x0.
+ */
+typedef struct HW_OMX_IMAGE_PORTDEFINITIONTYPE {
+    HW_OMX_STRING cMIMEType;
+    HW_OMX_NATIVE_DEVICETYPE pNativeRender;
+    HW_OMX_U32 nFrameWidth;
+    HW_OMX_U32 nFrameHeight;
+    HW_OMX_S32 nStride;
+    HW_OMX_U32 nSliceHeight;
+    HW_OMX_BOOL bFlagErrorConcealment;
+    HW_OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    HW_OMX_COLOR_FORMATTYPE eColorFormat;
+    HW_OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} HW_OMX_IMAGE_PORTDEFINITIONTYPE;
+
+
+/**
+ * Port format parameter.  This structure is used to enumerate the various
+ * data input/output format supported by the port.
+ *
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the
+ *                       component. When HW_OMX_IMAGE_CodingUnused is specified,
+ *                       eColorFormat is valid
+ *  eColorFormat       : Decompressed format used by this component
+ */
+typedef struct HW_OMX_IMAGE_PARAM_PORTFORMATTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nIndex;
+    HW_OMX_IMAGE_CODINGTYPE eCompressionFormat;
+    HW_OMX_COLOR_FORMATTYPE eColorFormat;
+} HW_OMX_IMAGE_PARAM_PORTFORMATTYPE;
+
+
+/**
+ * Flash control type
+ *
+ * ENUMS
+ *  Torch : Flash forced constantly on
+ */
+typedef enum HW_OMX_IMAGE_FLASHCONTROLTYPE {
+    HW_OMX_IMAGE_FlashControlOn = 0,
+    HW_OMX_IMAGE_FlashControlOff,
+    HW_OMX_IMAGE_FlashControlAuto,
+    HW_OMX_IMAGE_FlashControlRedEyeReduction,
+    HW_OMX_IMAGE_FlashControlFillin,
+    HW_OMX_IMAGE_FlashControlTorch,
+    HW_OMX_IMAGE_FlashControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_IMAGE_FlashControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_IMAGE_FlashControlMax = 0x7FFFFFFF
+} HW_OMX_IMAGE_FLASHCONTROLTYPE;
+
+
+/**
+ * Flash control configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize         : Size of the structure in bytes
+ *  nVersion      : OMX specification version information
+ *  nPortIndex    : Port that this structure applies to
+ *  eFlashControl : Flash control type
+ */
+typedef struct HW_OMX_IMAGE_PARAM_FLASHCONTROLTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_IMAGE_FLASHCONTROLTYPE eFlashControl;
+} HW_OMX_IMAGE_PARAM_FLASHCONTROLTYPE;
+
+
+/**
+ * Focus control type
+ */
+typedef enum HW_OMX_IMAGE_FOCUSCONTROLTYPE {
+    HW_OMX_IMAGE_FocusControlOn = 0,
+    HW_OMX_IMAGE_FocusControlOff,
+    HW_OMX_IMAGE_FocusControlAuto,
+    HW_OMX_IMAGE_FocusControlAutoLock,
+    HW_OMX_IMAGE_FocusControlKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_IMAGE_FocusControlVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_IMAGE_FocusControlMax = 0x7FFFFFFF
+} HW_OMX_IMAGE_FOCUSCONTROLTYPE;
+
+
+/**
+ * Focus control configuration
+ *
+ * STRUCT MEMBERS:
+ *  nSize           : Size of the structure in bytes
+ *  nVersion        : OMX specification version information
+ *  nPortIndex      : Port that this structure applies to
+ *  eFocusControl   : Focus control
+ *  nFocusSteps     : Focus can take on values from 0 mm to infinity.
+ *                    Interest is only in number of steps over this range.
+ *  nFocusStepIndex : Current focus step index
+ */
+typedef struct HW_OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_IMAGE_FOCUSCONTROLTYPE eFocusControl;
+    HW_OMX_U32 nFocusSteps;
+    HW_OMX_U32 nFocusStepIndex;
+} HW_OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE;
+
+
+/**
+ * Q Factor for JPEG compression, which controls the tradeoff between image
+ * quality and size.  Q Factor provides a more simple means of controlling
+ * JPEG compression quality, without directly programming Quantization
+ * tables for chroma and luma
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nQFactor   : JPEG Q factor value in the range of 1-100. A factor of 1
+ *               produces the smallest, worst quality images, and a factor
+ *               of 100 produces the largest, best quality images.  A
+ *               typical default is 75 for small good quality images
+ */
+typedef struct HW_OMX_IMAGE_PARAM_QFACTORTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nQFactor;
+} HW_OMX_IMAGE_PARAM_QFACTORTYPE;
+
+/**
+ * Quantization table type
+ */
+
+typedef enum HW_OMX_IMAGE_QUANTIZATIONTABLETYPE {
+    HW_OMX_IMAGE_QuantizationTableLuma = 0,
+    HW_OMX_IMAGE_QuantizationTableChroma,
+    HW_OMX_IMAGE_QuantizationTableChromaCb,
+    HW_OMX_IMAGE_QuantizationTableChromaCr,
+    HW_OMX_IMAGE_QuantizationTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_IMAGE_QuantizationTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_IMAGE_QuantizationTableMax = 0x7FFFFFFF
+} HW_OMX_IMAGE_QUANTIZATIONTABLETYPE;
+
+/**
+ * JPEG quantization tables are used to determine DCT compression for
+ * YUV data, as an alternative to specifying Q factor, providing exact
+ * control of compression
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information
+ *  nPortIndex              : Port that this structure applies to
+ *  eQuantizationTable      : Quantization table type
+ *  nQuantizationMatrix[64] : JPEG quantization table of coefficients stored
+ *                            in increasing columns then by rows of data (i.e.
+ *                            row 1, ... row 8). Quantization values are in
+ *                            the range 0-255 and stored in linear order
+ *                            (i.e. the component will zig-zag the
+ *                            quantization table data if required internally)
+ */
+typedef struct HW_OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_IMAGE_QUANTIZATIONTABLETYPE eQuantizationTable;
+    HW_OMX_U8 nQuantizationMatrix[64];
+} HW_OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE;
+
+
+/**
+ * Huffman table type, the same Huffman table is applied for chroma and
+ * luma component
+ */
+typedef enum HW_OMX_IMAGE_HUFFMANTABLETYPE {
+    HW_OMX_IMAGE_HuffmanTableAC = 0,
+    HW_OMX_IMAGE_HuffmanTableDC,
+    HW_OMX_IMAGE_HuffmanTableACLuma,
+    HW_OMX_IMAGE_HuffmanTableACChroma,
+    HW_OMX_IMAGE_HuffmanTableDCLuma,
+    HW_OMX_IMAGE_HuffmanTableDCChroma,
+    HW_OMX_IMAGE_HuffmanTableKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_IMAGE_HuffmanTableVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_IMAGE_HuffmanTableMax = 0x7FFFFFFF
+} HW_OMX_IMAGE_HUFFMANTABLETYPE;
+
+/**
+ * JPEG Huffman table
+ *
+ * STRUCT MEMBERS:
+ *  nSize                            : Size of the structure in bytes
+ *  nVersion                         : OMX specification version information
+ *  nPortIndex                       : Port that this structure applies to
+ *  eHuffmanTable                    : Huffman table type
+ *  nNumberOfHuffmanCodeOfLength[16] : 0-16, number of Huffman codes of each
+ *                                     possible length
+ *  nHuffmanTable[256]               : 0-255, the size used for AC and DC
+ *                                     HuffmanTable are 16 and 162
+ */
+typedef struct HW_OMX_IMAGE_PARAM_HUFFMANTTABLETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_IMAGE_HUFFMANTABLETYPE eHuffmanTable;
+    HW_OMX_U8 nNumberOfHuffmanCodeOfLength[16];
+    HW_OMX_U8 nHuffmanTable[256];
+}HW_OMX_IMAGE_PARAM_HUFFMANTTABLETYPE;
+
+/** @} */
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_Index.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_Index.h
@@ -0,0 +1,280 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file HW_OMX_Index.h - OpenMax IL version 1.1.2
+ *  The HW_OMX_Index header file contains the definitions for both applications
+ *  and components .
+ */
+
+
+#ifndef HW_OMX_Index_h
+#define HW_OMX_Index_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+#include "HW_OMX_Types.h"
+
+/** The HW_OMX_INDEXTYPE enumeration is used to select a structure when either
+ *  getting or setting parameters and/or configuration data.  Each entry in
+ *  this enumeration maps to an OMX specified structure.  When the
+ *  HW_OMX_GetParameter, HW_OMX_SetParameter, HW_OMX_GetConfig or HW_OMX_SetConfig methods
+ *  are used, the second parameter will always be an entry from this enumeration
+ *  and the third entry will be the structure shown in the comments for the entry.
+ *  For example, if the application is initializing a cropping function, the
+ *  HW_OMX_SetConfig command would have HW_OMX_IndexConfigCommonInputCrop as the second parameter
+ *  and would send a pointer to an initialized HW_OMX_RECTTYPE structure as the
+ *  third parameter.
+ *
+ *  The enumeration entries named with the HW_OMX_Config prefix are sent using
+ *  the HW_OMX_SetConfig command and the enumeration entries named with the
+ *  HW_OMX_PARAM_ prefix are sent using the HW_OMX_SetParameter command.
+ */
+typedef enum HW_OMX_INDEXTYPE {
+
+    HW_OMX_IndexComponentStartUnused = 0x01000000,
+    HW_OMX_IndexParamPriorityMgmt,             /**< reference: HW_OMX_PRIORITYMGMTTYPE */
+    HW_OMX_IndexParamAudioInit,                /**< reference: HW_OMX_PORT_PARAM_TYPE */
+    HW_OMX_IndexParamImageInit,                /**< reference: HW_OMX_PORT_PARAM_TYPE */
+    HW_OMX_IndexParamVideoInit,                /**< reference: HW_OMX_PORT_PARAM_TYPE */
+    HW_OMX_IndexParamOtherInit,                /**< reference: HW_OMX_PORT_PARAM_TYPE */
+    HW_OMX_IndexParamNumAvailableStreams,      /**< reference: HW_OMX_PARAM_U32TYPE */
+    HW_OMX_IndexParamActiveStream,             /**< reference: HW_OMX_PARAM_U32TYPE */
+    HW_OMX_IndexParamSuspensionPolicy,         /**< reference: HW_OMX_PARAM_SUSPENSIONPOLICYTYPE */
+    HW_OMX_IndexParamComponentSuspended,       /**< reference: HW_OMX_PARAM_SUSPENSIONTYPE */
+    HW_OMX_IndexConfigCapturing,               /**< reference: HW_OMX_CONFIG_BOOLEANTYPE */
+    HW_OMX_IndexConfigCaptureMode,             /**< reference: HW_OMX_CONFIG_CAPTUREMODETYPE */
+    HW_OMX_IndexAutoPauseAfterCapture,         /**< reference: HW_OMX_CONFIG_BOOLEANTYPE */
+    HW_OMX_IndexParamContentURI,               /**< reference: HW_OMX_PARAM_CONTENTURITYPE */
+    HW_OMX_IndexParamCustomContentPipe,        /**< reference: HW_OMX_PARAM_CONTENTPIPETYPE */
+    HW_OMX_IndexParamDisableResourceConcealment, /**< reference: HW_OMX_RESOURCECONCEALMENTTYPE */
+    HW_OMX_IndexConfigMetadataItemCount,       /**< reference: HW_OMX_CONFIG_METADATAITEMCOUNTTYPE */
+    HW_OMX_IndexConfigContainerNodeCount,      /**< reference: HW_OMX_CONFIG_CONTAINERNODECOUNTTYPE */
+    HW_OMX_IndexConfigMetadataItem,            /**< reference: HW_OMX_CONFIG_METADATAITEMTYPE */
+    HW_OMX_IndexConfigCounterNodeID,           /**< reference: HW_OMX_CONFIG_CONTAINERNODEIDTYPE */
+    HW_OMX_IndexParamMetadataFilterType,       /**< reference: HW_OMX_PARAM_METADATAFILTERTYPE */
+    HW_OMX_IndexParamMetadataKeyFilter,        /**< reference: HW_OMX_PARAM_METADATAFILTERTYPE */
+    HW_OMX_IndexConfigPriorityMgmt,            /**< reference: HW_OMX_PRIORITYMGMTTYPE */
+    HW_OMX_IndexParamStandardComponentRole,    /**< reference: HW_OMX_PARAM_COMPONENTROLETYPE */
+    HW_OMX_IndexComponentEndUnused,
+
+    HW_OMX_IndexPortStartUnused = 0x02000000,
+    HW_OMX_IndexParamPortDefinition,           /**< reference: HW_OMX_PARAM_PORTDEFINITIONTYPE */
+    HW_OMX_IndexParamCompBufferSupplier,       /**< reference: HW_OMX_PARAM_BUFFERSUPPLIERTYPE */
+    HW_OMX_IndexPortEndUnused,
+
+    HW_OMX_IndexReservedStartUnused = 0x03000000,
+
+    /* Audio parameters and configurations */
+    HW_OMX_IndexAudioStartUnused = 0x04000000,
+    HW_OMX_IndexParamAudioPortFormat,          /**< reference: HW_OMX_AUDIO_PARAM_PORTFORMATTYPE */
+    HW_OMX_IndexParamAudioPcm,                 /**< reference: HW_OMX_AUDIO_PARAM_PCMMODETYPE */
+    HW_OMX_IndexParamAudioAac,                 /**< reference: HW_OMX_AUDIO_PARAM_AACPROFILETYPE */
+    HW_OMX_IndexParamAudioRa,                  /**< reference: HW_OMX_AUDIO_PARAM_RATYPE */
+    HW_OMX_IndexParamAudioMp3,                 /**< reference: HW_OMX_AUDIO_PARAM_MP3TYPE */
+    HW_OMX_IndexParamAudioAdpcm,               /**< reference: HW_OMX_AUDIO_PARAM_ADPCMTYPE */
+    HW_OMX_IndexParamAudioG723,                /**< reference: HW_OMX_AUDIO_PARAM_G723TYPE */
+    HW_OMX_IndexParamAudioG729,                /**< reference: HW_OMX_AUDIO_PARAM_G729TYPE */
+    HW_OMX_IndexParamAudioAmr,                 /**< reference: HW_OMX_AUDIO_PARAM_AMRTYPE */
+    HW_OMX_IndexParamAudioWma,                 /**< reference: HW_OMX_AUDIO_PARAM_WMATYPE */
+    HW_OMX_IndexParamAudioSbc,                 /**< reference: HW_OMX_AUDIO_PARAM_SBCTYPE */
+    HW_OMX_IndexParamAudioMidi,                /**< reference: HW_OMX_AUDIO_PARAM_MIDITYPE */
+    HW_OMX_IndexParamAudioGsm_FR,              /**< reference: HW_OMX_AUDIO_PARAM_GSMFRTYPE */
+    HW_OMX_IndexParamAudioMidiLoadUserSound,   /**< reference: HW_OMX_AUDIO_PARAM_MIDILOADUSERSOUNDTYPE */
+    HW_OMX_IndexParamAudioG726,                /**< reference: HW_OMX_AUDIO_PARAM_G726TYPE */
+    HW_OMX_IndexParamAudioGsm_EFR,             /**< reference: HW_OMX_AUDIO_PARAM_GSMEFRTYPE */
+    HW_OMX_IndexParamAudioGsm_HR,              /**< reference: HW_OMX_AUDIO_PARAM_GSMHRTYPE */
+    HW_OMX_IndexParamAudioPdc_FR,              /**< reference: HW_OMX_AUDIO_PARAM_PDCFRTYPE */
+    HW_OMX_IndexParamAudioPdc_EFR,             /**< reference: HW_OMX_AUDIO_PARAM_PDCEFRTYPE */
+    HW_OMX_IndexParamAudioPdc_HR,              /**< reference: HW_OMX_AUDIO_PARAM_PDCHRTYPE */
+    HW_OMX_IndexParamAudioTdma_FR,             /**< reference: HW_OMX_AUDIO_PARAM_TDMAFRTYPE */
+    HW_OMX_IndexParamAudioTdma_EFR,            /**< reference: HW_OMX_AUDIO_PARAM_TDMAEFRTYPE */
+    HW_OMX_IndexParamAudioQcelp8,              /**< reference: HW_OMX_AUDIO_PARAM_QCELP8TYPE */
+    HW_OMX_IndexParamAudioQcelp13,             /**< reference: HW_OMX_AUDIO_PARAM_QCELP13TYPE */
+    HW_OMX_IndexParamAudioEvrc,                /**< reference: HW_OMX_AUDIO_PARAM_EVRCTYPE */
+    HW_OMX_IndexParamAudioSmv,                 /**< reference: HW_OMX_AUDIO_PARAM_SMVTYPE */
+    HW_OMX_IndexParamAudioVorbis,              /**< reference: HW_OMX_AUDIO_PARAM_VORBISTYPE */
+    HW_OMX_IndexParamAudioFlac,                /**< reference: HW_OMX_AUDIO_PARAM_FLACTYPE */
+    HW_OMX_IndexAudioEndUnused,
+
+    HW_OMX_IndexConfigAudioMidiImmediateEvent, /**< reference: HW_OMX_AUDIO_CONFIG_MIDIIMMEDIATEEVENTTYPE */
+    HW_OMX_IndexConfigAudioMidiControl,        /**< reference: HW_OMX_AUDIO_CONFIG_MIDICONTROLTYPE */
+    HW_OMX_IndexConfigAudioMidiSoundBankProgram, /**< reference: HW_OMX_AUDIO_CONFIG_MIDISOUNDBANKPROGRAMTYPE */
+    HW_OMX_IndexConfigAudioMidiStatus,         /**< reference: HW_OMX_AUDIO_CONFIG_MIDISTATUSTYPE */
+    HW_OMX_IndexConfigAudioMidiMetaEvent,      /**< reference: HW_OMX_AUDIO_CONFIG_MIDIMETAEVENTTYPE */
+    HW_OMX_IndexConfigAudioMidiMetaEventData,  /**< reference: HW_OMX_AUDIO_CONFIG_MIDIMETAEVENTDATATYPE */
+    HW_OMX_IndexConfigAudioVolume,             /**< reference: HW_OMX_AUDIO_CONFIG_VOLUMETYPE */
+    HW_OMX_IndexConfigAudioBalance,            /**< reference: HW_OMX_AUDIO_CONFIG_BALANCETYPE */
+    HW_OMX_IndexConfigAudioChannelMute,        /**< reference: HW_OMX_AUDIO_CONFIG_CHANNELMUTETYPE */
+    HW_OMX_IndexConfigAudioMute,               /**< reference: HW_OMX_AUDIO_CONFIG_MUTETYPE */
+    HW_OMX_IndexConfigAudioLoudness,           /**< reference: HW_OMX_AUDIO_CONFIG_LOUDNESSTYPE */
+    HW_OMX_IndexConfigAudioEchoCancelation,    /**< reference: HW_OMX_AUDIO_CONFIG_ECHOCANCELATIONTYPE */
+    HW_OMX_IndexConfigAudioNoiseReduction,     /**< reference: HW_OMX_AUDIO_CONFIG_NOISEREDUCTIONTYPE */
+    HW_OMX_IndexConfigAudioBass,               /**< reference: HW_OMX_AUDIO_CONFIG_BASSTYPE */
+    HW_OMX_IndexConfigAudioTreble,             /**< reference: HW_OMX_AUDIO_CONFIG_TREBLETYPE */
+    HW_OMX_IndexConfigAudioStereoWidening,     /**< reference: HW_OMX_AUDIO_CONFIG_STEREOWIDENINGTYPE */
+    HW_OMX_IndexConfigAudioChorus,             /**< reference: HW_OMX_AUDIO_CONFIG_CHORUSTYPE */
+    HW_OMX_IndexConfigAudioEqualizer,          /**< reference: HW_OMX_AUDIO_CONFIG_EQUALIZERTYPE */
+    HW_OMX_IndexConfigAudioReverberation,      /**< reference: HW_OMX_AUDIO_CONFIG_REVERBERATIONTYPE */
+    HW_OMX_IndexConfigAudioChannelVolume,      /**< reference: HW_OMX_AUDIO_CONFIG_CHANNELVOLUMETYPE */
+
+    /* Image specific parameters and configurations */
+    HW_OMX_IndexImageStartUnused = 0x05000000,
+    HW_OMX_IndexParamImagePortFormat,          /**< reference: HW_OMX_IMAGE_PARAM_PORTFORMATTYPE */
+    HW_OMX_IndexParamFlashControl,             /**< reference: HW_OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+    HW_OMX_IndexConfigFocusControl,            /**< reference: HW_OMX_IMAGE_CONFIG_FOCUSCONTROLTYPE */
+    HW_OMX_IndexParamQFactor,                  /**< reference: HW_OMX_IMAGE_PARAM_QFACTORTYPE */
+    HW_OMX_IndexParamQuantizationTable,        /**< reference: HW_OMX_IMAGE_PARAM_QUANTIZATIONTABLETYPE */
+    HW_OMX_IndexParamHuffmanTable,             /**< reference: HW_OMX_IMAGE_PARAM_HUFFMANTTABLETYPE */
+    HW_OMX_IndexConfigFlashControl,            /**< reference: HW_OMX_IMAGE_PARAM_FLASHCONTROLTYPE */
+
+    /* Video specific parameters and configurations */
+    HW_OMX_IndexVideoStartUnused = 0x06000000,
+    HW_OMX_IndexParamVideoPortFormat,          /**< reference: HW_OMX_VIDEO_PARAM_PORTFORMATTYPE */
+    HW_OMX_IndexParamVideoQuantization,        /**< reference: HW_OMX_VIDEO_PARAM_QUANTIZATIONTYPE */
+    HW_OMX_IndexParamVideoFastUpdate,          /**< reference: HW_OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE */
+    HW_OMX_IndexParamVideoBitrate,             /**< reference: HW_OMX_VIDEO_PARAM_BITRATETYPE */
+    HW_OMX_IndexParamVideoMotionVector,        /**< reference: HW_OMX_VIDEO_PARAM_MOTIONVECTORTYPE */
+    HW_OMX_IndexParamVideoIntraRefresh,        /**< reference: HW_OMX_VIDEO_PARAM_INTRAREFRESHTYPE */
+    HW_OMX_IndexParamVideoErrorCorrection,     /**< reference: HW_OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE */
+    HW_OMX_IndexParamVideoVBSMC,               /**< reference: HW_OMX_VIDEO_PARAM_VBSMCTYPE */
+    HW_OMX_IndexParamVideoMpeg2,               /**< reference: HW_OMX_VIDEO_PARAM_MPEG2TYPE */
+    HW_OMX_IndexParamVideoMpeg4,               /**< reference: HW_OMX_VIDEO_PARAM_MPEG4TYPE */
+    HW_OMX_IndexParamVideoWmv,                 /**< reference: HW_OMX_VIDEO_PARAM_WMVTYPE */
+    HW_OMX_IndexParamVideoRv,                  /**< reference: HW_OMX_VIDEO_PARAM_RVTYPE */
+    HW_OMX_IndexParamVideoAvc,                 /**< reference: HW_OMX_VIDEO_PARAM_AVCTYPE */
+    HW_OMX_IndexParamVideoH263,                /**< reference: HW_OMX_VIDEO_PARAM_H263TYPE */
+    HW_OMX_IndexParamVideoProfileLevelQuerySupported, /**< reference: HW_OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    HW_OMX_IndexParamVideoProfileLevelCurrent, /**< reference: HW_OMX_VIDEO_PARAM_PROFILELEVELTYPE */
+    HW_OMX_IndexConfigVideoBitrate,            /**< reference: HW_OMX_VIDEO_CONFIG_BITRATETYPE */
+    HW_OMX_IndexConfigVideoFramerate,          /**< reference: HW_OMX_CONFIG_FRAMERATETYPE */
+    HW_OMX_IndexConfigVideoIntraVOPRefresh,    /**< reference: HW_OMX_CONFIG_INTRAREFRESHVOPTYPE */
+    HW_OMX_IndexConfigVideoIntraMBRefresh,     /**< reference: HW_OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    HW_OMX_IndexConfigVideoMBErrorReporting,   /**< reference: HW_OMX_CONFIG_MBERRORREPORTINGTYPE */
+    HW_OMX_IndexParamVideoMacroblocksPerFrame, /**< reference: HW_OMX_PARAM_MACROBLOCKSTYPE */
+    HW_OMX_IndexConfigVideoMacroBlockErrorMap, /**< reference: HW_OMX_CONFIG_MACROBLOCKERRORMAPTYPE */
+    HW_OMX_IndexParamVideoSliceFMO,            /**< reference: HW_OMX_VIDEO_PARAM_AVCSLICEFMO */
+    HW_OMX_IndexConfigVideoAVCIntraPeriod,     /**< reference: HW_OMX_VIDEO_CONFIG_AVCINTRAPERIOD */
+    HW_OMX_IndexConfigVideoNalSize,            /**< reference: HW_OMX_VIDEO_CONFIG_NALSIZE */
+    HW_OMX_IndexVideoEndUnused,
+
+    /* Image & Video common Configurations */
+    HW_OMX_IndexCommonStartUnused = 0x07000000,
+    HW_OMX_IndexParamCommonDeblocking,         /**< reference: HW_OMX_PARAM_DEBLOCKINGTYPE */
+    HW_OMX_IndexParamCommonSensorMode,         /**< reference: HW_OMX_PARAM_SENSORMODETYPE */
+    HW_OMX_IndexParamCommonInterleave,         /**< reference: HW_OMX_PARAM_INTERLEAVETYPE */
+    HW_OMX_IndexConfigCommonColorFormatConversion, /**< reference: HW_OMX_CONFIG_COLORCONVERSIONTYPE */
+    HW_OMX_IndexConfigCommonScale,             /**< reference: HW_OMX_CONFIG_SCALEFACTORTYPE */
+    HW_OMX_IndexConfigCommonImageFilter,       /**< reference: HW_OMX_CONFIG_IMAGEFILTERTYPE */
+    HW_OMX_IndexConfigCommonColorEnhancement,  /**< reference: HW_OMX_CONFIG_COLORENHANCEMENTTYPE */
+    HW_OMX_IndexConfigCommonColorKey,          /**< reference: HW_OMX_CONFIG_COLORKEYTYPE */
+    HW_OMX_IndexConfigCommonColorBlend,        /**< reference: HW_OMX_CONFIG_COLORBLENDTYPE */
+    HW_OMX_IndexConfigCommonFrameStabilisation,/**< reference: HW_OMX_CONFIG_FRAMESTABTYPE */
+    HW_OMX_IndexConfigCommonRotate,            /**< reference: HW_OMX_CONFIG_ROTATIONTYPE */
+    HW_OMX_IndexConfigCommonMirror,            /**< reference: HW_OMX_CONFIG_MIRRORTYPE */
+    HW_OMX_IndexConfigCommonOutputPosition,    /**< reference: HW_OMX_CONFIG_POINTTYPE */
+    HW_OMX_IndexConfigCommonInputCrop,         /**< reference: HW_OMX_CONFIG_RECTTYPE */
+    HW_OMX_IndexConfigCommonOutputCrop,        /**< reference: HW_OMX_CONFIG_RECTTYPE */
+    HW_OMX_IndexConfigCommonDigitalZoom,       /**< reference: HW_OMX_CONFIG_SCALEFACTORTYPE */
+    HW_OMX_IndexConfigCommonOpticalZoom,       /**< reference: HW_OMX_CONFIG_SCALEFACTORTYPE*/
+    HW_OMX_IndexConfigCommonWhiteBalance,      /**< reference: HW_OMX_CONFIG_WHITEBALCONTROLTYPE */
+    HW_OMX_IndexConfigCommonExposure,          /**< reference: HW_OMX_CONFIG_EXPOSURECONTROLTYPE */
+    HW_OMX_IndexConfigCommonContrast,          /**< reference: HW_OMX_CONFIG_CONTRASTTYPE */
+    HW_OMX_IndexConfigCommonBrightness,        /**< reference: HW_OMX_CONFIG_BRIGHTNESSTYPE */
+    HW_OMX_IndexConfigCommonBacklight,         /**< reference: HW_OMX_CONFIG_BACKLIGHTTYPE */
+    HW_OMX_IndexConfigCommonGamma,             /**< reference: HW_OMX_CONFIG_GAMMATYPE */
+    HW_OMX_IndexConfigCommonSaturation,        /**< reference: HW_OMX_CONFIG_SATURATIONTYPE */
+    HW_OMX_IndexConfigCommonLightness,         /**< reference: HW_OMX_CONFIG_LIGHTNESSTYPE */
+    HW_OMX_IndexConfigCommonExclusionRect,     /**< reference: HW_OMX_CONFIG_RECTTYPE */
+    HW_OMX_IndexConfigCommonDithering,         /**< reference: HW_OMX_CONFIG_DITHERTYPE */
+    HW_OMX_IndexConfigCommonPlaneBlend,        /**< reference: HW_OMX_CONFIG_PLANEBLENDTYPE */
+    HW_OMX_IndexConfigCommonExposureValue,     /**< reference: HW_OMX_CONFIG_EXPOSUREVALUETYPE */
+    HW_OMX_IndexConfigCommonOutputSize,        /**< reference: HW_OMX_FRAMESIZETYPE */
+    HW_OMX_IndexParamCommonExtraQuantData,     /**< reference: HW_OMX_OTHER_EXTRADATATYPE */
+    HW_OMX_IndexConfigCommonFocusRegion,       /**< reference: HW_OMX_CONFIG_FOCUSREGIONTYPE */
+    HW_OMX_IndexConfigCommonFocusStatus,       /**< reference: HW_OMX_PARAM_FOCUSSTATUSTYPE */
+    HW_OMX_IndexConfigCommonTransitionEffect,  /**< reference: HW_OMX_CONFIG_TRANSITIONEFFECTTYPE */
+    HW_OMX_IndexCommonEndUnused,
+
+    /* Reserved Configuration range */
+    HW_OMX_IndexOtherStartUnused = 0x08000000,
+    HW_OMX_IndexParamOtherPortFormat,          /**< reference: HW_OMX_OTHER_PARAM_PORTFORMATTYPE */
+    HW_OMX_IndexConfigOtherPower,              /**< reference: HW_OMX_OTHER_CONFIG_POWERTYPE */
+    HW_OMX_IndexConfigOtherStats,              /**< reference: HW_OMX_OTHER_CONFIG_STATSTYPE */
+
+
+    /* Reserved Time range */
+    HW_OMX_IndexTimeStartUnused = 0x09000000,
+    HW_OMX_IndexConfigTimeScale,               /**< reference: HW_OMX_TIME_CONFIG_SCALETYPE */
+    HW_OMX_IndexConfigTimeClockState,          /**< reference: HW_OMX_TIME_CONFIG_CLOCKSTATETYPE */
+    HW_OMX_IndexConfigTimeActiveRefClock,      /**< reference: HW_OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE */
+    HW_OMX_IndexConfigTimeCurrentMediaTime,    /**< reference: HW_OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    HW_OMX_IndexConfigTimeCurrentWallTime,     /**< reference: HW_OMX_TIME_CONFIG_TIMESTAMPTYPE (read only) */
+    HW_OMX_IndexConfigTimeCurrentAudioReference, /**< reference: HW_OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    HW_OMX_IndexConfigTimeCurrentVideoReference, /**< reference: HW_OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    HW_OMX_IndexConfigTimeMediaTimeRequest,    /**< reference: HW_OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE (write only) */
+    HW_OMX_IndexConfigTimeClientStartTime,     /**<reference:  HW_OMX_TIME_CONFIG_TIMESTAMPTYPE (write only) */
+    HW_OMX_IndexConfigTimePosition,            /**< reference: HW_OMX_TIME_CONFIG_TIMESTAMPTYPE */
+    HW_OMX_IndexConfigTimeSeekMode,            /**< reference: HW_OMX_TIME_CONFIG_SEEKMODETYPE */
+
+
+    HW_OMX_IndexKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    /* Vendor specific area */
+    HW_OMX_IndexVendorStartUnused = 0x7F000000,
+    /* Vendor specific structures should be in the range of 0x7F000000
+       to 0x7FFFFFFE.  This range is not broken out by vendor, so
+       private indexes are not guaranteed unique and therefore should
+       only be sent to the appropriate component. */
+
+    HW_OMX_IndexMax = 0x7FFFFFFF
+
+} HW_OMX_INDEXTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_IndexExt.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_IndexExt.h
@@ -0,0 +1,228 @@
+/*
+ * Copyright (c) 2010 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file HW_OMX_IndexExt.h - OpenMax IL version 1.1.2
+ * The HW_OMX_IndexExt header file contains extensions to the definitions
+ * for both applications and components .
+ */
+
+#ifndef HW_OMX_IndexExt_h
+#define HW_OMX_IndexExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include "HW_OMX_Index.h"
+
+
+/** Khronos standard extension indices.
+
+This enum lists the current Khronos extension indices to OpenMAX IL.
+*/
+typedef enum HW_OMX_INDEXEXTTYPE {
+
+    /* Component parameters and configurations */
+    HW_OMX_IndexExtComponentStartUnused = HW_OMX_IndexKhronosExtensions + 0x00100000,
+    HW_OMX_IndexConfigCallbackRequest,                 /**< reference: HW_OMX_CONFIG_CALLBACKREQUESTTYPE */
+    HW_OMX_IndexConfigCommitMode,                      /**< reference: HW_OMX_CONFIG_COMMITMODETYPE */
+    HW_OMX_IndexConfigCommit,                          /**< reference: HW_OMX_CONFIG_COMMITTYPE */
+    HW_OMX_IndexConfigAndroidVendorExtension,          /**< reference: HW_OMX_CONFIG_VENDOR_EXTENSIONTYPE */
+
+    /* Port parameters and configurations */
+    HW_OMX_IndexExtPortStartUnused = HW_OMX_IndexKhronosExtensions + 0x00200000,
+
+    /* Audio parameters and configurations */
+    HW_OMX_IndexExtAudioStartUnused = HW_OMX_IndexKhronosExtensions + 0x00400000,
+    HW_OMX_IndexParamAudioAndroidAc3,                  /**< reference: HW_OMX_AUDIO_PARAM_ANDROID_AC3TYPE */
+    HW_OMX_IndexParamAudioAndroidOpus,                 /**< reference: HW_OMX_AUDIO_PARAM_ANDROID_OPUSTYPE */
+    HW_OMX_IndexParamAudioAndroidAacPresentation,      /**< reference: HW_OMX_AUDIO_PARAM_ANDROID_AACPRESENTATIONTYPE */
+    HW_OMX_IndexParamAudioAndroidEac3,                 /**< reference: HW_OMX_AUDIO_PARAM_ANDROID_EAC3TYPE */
+    HW_OMX_IndexParamAudioProfileQuerySupported,       /**< reference: HW_OMX_AUDIO_PARAM_ANDROID_PROFILETYPE */
+    HW_OMX_IndexParamAudioAndroidAacDrcPresentation,   /**< reference: HW_OMX_AUDIO_PARAM_ANDROID_AACDRCPRESENTATIONTYPE */
+    HW_OMX_IndexParamAudioAndroidAc4,                  /**< reference: HW_OMX_AUDIO_PARAM_ANDROID_AC4TYPE */
+    HW_OMX_IndexConfigAudioPresentation,               /**< reference: HW_OMX_AUDIO_CONFIG_ANDROID_AUDIOPRESENTATION */
+    HW_OMX_IndexExtAudioEndUnused,
+
+    /* Image parameters and configurations */
+    HW_OMX_IndexExtImageStartUnused = HW_OMX_IndexKhronosExtensions + 0x00500000,
+
+    /* Video parameters and configurations */
+    HW_OMX_IndexExtVideoStartUnused = HW_OMX_IndexKhronosExtensions + 0x00600000,
+    HW_OMX_IndexParamNalStreamFormatSupported,         /**< reference: HW_OMX_NALSTREAMFORMATTYPE */
+    HW_OMX_IndexParamNalStreamFormat,                  /**< reference: HW_OMX_NALSTREAMFORMATTYPE */
+    HW_OMX_IndexParamNalStreamFormatSelect,            /**< reference: HW_OMX_NALSTREAMFORMATTYPE */
+    HW_OMX_IndexParamVideoVp8,                         /**< reference: HW_OMX_VIDEO_PARAM_VP8TYPE */
+    HW_OMX_IndexConfigVideoVp8ReferenceFrame,          /**< reference: HW_OMX_VIDEO_VP8REFERENCEFRAMETYPE */
+    HW_OMX_IndexConfigVideoVp8ReferenceFrameType,      /**< reference: HW_OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE */
+    HW_OMX_IndexParamVideoAndroidVp8Encoder,           /**< reference: HW_OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE */
+    HW_OMX_IndexParamVideoHevc,                        /**< reference: HW_OMX_VIDEO_PARAM_HEVCTYPE */
+    HW_OMX_IndexParamSliceSegments,                    /**< reference: HW_OMX_VIDEO_SLICESEGMENTSTYPE */
+    HW_OMX_IndexConfigAndroidIntraRefresh,             /**< reference: HW_OMX_VIDEO_CONFIG_ANDROID_INTRAREFRESHTYPE */
+    HW_OMX_IndexParamAndroidVideoTemporalLayering,     /**< reference: HW_OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE */
+    HW_OMX_IndexConfigAndroidVideoTemporalLayering,    /**< reference: HW_OMX_VIDEO_CONFIG_ANDROID_TEMPORALLAYERINGTYPE */
+    HW_OMX_IndexParamMaxFrameDurationForBitrateControl,/**< reference: HW_OMX_PARAM_U32TYPE */
+    HW_OMX_IndexParamVideoVp9,                         /**< reference: HW_OMX_VIDEO_PARAM_VP9TYPE */
+    HW_OMX_IndexParamVideoAndroidVp9Encoder,           /**< reference: HW_OMX_VIDEO_PARAM_ANDROID_VP9ENCODERTYPE */
+    HW_OMX_IndexParamVideoAndroidImageGrid,            /**< reference: HW_OMX_VIDEO_PARAM_ANDROID_IMAGEGRIDTYPE */
+    HW_OMX_IndexExtVideoEndUnused,
+
+    /* Image & Video common configurations */
+    HW_OMX_IndexExtCommonStartUnused = HW_OMX_IndexKhronosExtensions + 0x00700000,
+
+    /* Other configurations */
+    HW_OMX_IndexExtOtherStartUnused = HW_OMX_IndexKhronosExtensions + 0x00800000,
+    HW_OMX_IndexConfigAutoFramerateConversion,         /**< reference: HW_OMX_CONFIG_BOOLEANTYPE */
+    HW_OMX_IndexConfigPriority,                        /**< reference: HW_OMX_PARAM_U32TYPE */
+    HW_OMX_IndexConfigOperatingRate,                   /**< reference: HW_OMX_PARAM_U32TYPE in Q16 format for video and in Hz for audio */
+    HW_OMX_IndexParamConsumerUsageBits,                /**< reference: HW_OMX_PARAM_U32TYPE */
+    HW_OMX_IndexConfigLatency,                         /**< reference: HW_OMX_PARAM_U32TYPE */
+    HW_OMX_IndexExtOtherEndUnused,
+
+    /* Time configurations */
+    HW_OMX_IndexExtTimeStartUnused = HW_OMX_IndexKhronosExtensions + 0x00900000,
+
+    HW_OMX_IndexExtMax = 0x7FFFFFFF
+} HW_OMX_INDEXEXTTYPE;
+
+#define HW_OMX_MAX_STRINGVALUE_SIZE HW_OMX_MAX_STRINGNAME_SIZE
+#define HW_OMX_MAX_ANDROID_VENDOR_PARAMCOUNT 32
+
+typedef enum HW_OMX_ANDROID_VENDOR_VALUETYPE {
+    HW_OMX_AndroidVendorValueInt32 = 0,   /*<< int32_t value */
+    HW_OMX_AndroidVendorValueInt64,       /*<< int64_t value */
+    HW_OMX_AndroidVendorValueString,      /*<< string value */
+    HW_OMX_AndroidVendorValueEndUnused,
+} HW_OMX_ANDROID_VENDOR_VALUETYPE;
+
+/**
+ * Structure describing a single value of an Android vendor extension.
+ *
+ * STRUCTURE MEMBERS:
+ *  cKey        : parameter value name.
+ *  eValueType  : parameter value type
+ *  bSet        : if false, the parameter is not set (for HW_OMX_GetConfig) or is unset (HW_OMX_SetConfig)
+ *                if true, the parameter is set to the corresponding value below
+ *  nInt64      : int64 value
+ *  cString     : string value
+ */
+typedef struct HW_OMX_CONFIG_ANDROID_VENDOR_PARAMTYPE {
+    HW_OMX_U8 cKey[HW_OMX_MAX_STRINGNAME_SIZE];
+    HW_OMX_ANDROID_VENDOR_VALUETYPE eValueType;
+    HW_OMX_BOOL bSet;
+    union {
+        HW_OMX_S32 nInt32;
+        HW_OMX_S64 nInt64;
+        HW_OMX_U8 cString[HW_OMX_MAX_STRINGVALUE_SIZE];
+    };
+} HW_OMX_CONFIG_ANDROID_VENDOR_PARAMTYPE;
+
+/**
+ * HW_OMX_CONFIG_ANDROID_VENDOR_EXTENSIONTYPE is the structure for an Android vendor extension
+ * supported by the component. This structure enumerates the various extension parameters and their
+ * values.
+ *
+ * Android vendor extensions have a name and one or more parameter values - each with a string key -
+ * that are set together. The values are exposed to Android applications via a string key that is
+ * the concatenation of 'vendor', the extension name and the parameter key, each separated by dot
+ * (.), with any trailing '.value' suffix(es) removed (though optionally allowed).
+ *
+ * Extension names and parameter keys are subject to the following rules:
+ *   - Each SHALL contain a set of lowercase alphanumeric (underscore allowed) tags separated by
+ *     dot (.) or dash (-).
+ *   - The first character of the first tag, and any tag following a dot SHALL not start with a
+ *     digit.
+ *   - Tags 'value', 'vendor', 'omx' and 'android' (even if trailed and/or followed by any number
+ *     of underscores) are prohibited in the extension name.
+ *   - Tags 'vendor', 'omx' and 'android' (even if trailed and/or followed by any number
+ *     of underscores) are prohibited in parameter keys.
+ *   - The tag 'value' (even if trailed and/or followed by any number
+ *     of underscores) is prohibited in parameter keys with the following exception:
+ *     the parameter key may be exactly 'value'
+ *   - The parameter key for extensions with a single parameter value SHALL be 'value'
+ *   - No two extensions SHALL have the same name
+ *   - No extension's name SHALL start with another extension's NAME followed by a dot (.)
+ *   - No two parameters of an extension SHALL have the same key
+ *
+ * This config can be used with both HW_OMX_GetConfig and HW_OMX_SetConfig. In the HW_OMX_GetConfig
+ * case, the caller specifies nIndex and nParamSizeUsed. The component fills in cName,
+ * eDir and nParamCount. Additionally, if nParamSizeUsed is not less than nParamCount, the
+ * component fills out the parameter values (nParam) with the current values for each parameter
+ * of the vendor extension.
+ *
+ * The value of nIndex goes from 0 to N-1, where N is the number of Android vendor extensions
+ * supported by the component. The component does not need to report N as the caller can determine
+ * N by enumerating all extensions supported by the component. The component may not support any
+ * extensions. If there are no more extensions, HW_OMX_GetParameter returns HW_OMX_ErrorNoMore. The
+ * component supplies extensions in the order it wants clients to set them.
+ *
+ * The component SHALL return HW_OMX_ErrorNone for all cases where nIndex is less than N (specifically
+ * even in the case of where nParamCount is greater than nParamSizeUsed).
+ *
+ * In the HW_OMX_SetConfig case the field nIndex is ignored. If the component supports an Android
+ * vendor extension with the name in cName, it SHALL configure the parameter values for that
+ * extension according to the parameters in nParam. nParamCount is the number of valid parameters
+ * in the nParam array, and nParamSizeUsed is the size of the nParam array. (nParamSizeUsed
+ * SHALL be at least nParamCount) Parameters that are part of a vendor extension but are not
+ * in the nParam array are assumed to be unset (this is different from not changed).
+ * All parameter values SHALL have distinct keys in nParam (the component can assume that this
+ * is the case. Otherwise, the actual value for the parameters that are multiply defined can
+ * be any of the set values.)
+ *
+ * Return values in case of HW_OMX_SetConfig:
+ *   HW_OMX_ErrorUnsupportedIndex: the component does not support the extension specified by cName
+ *   HW_OMX_ErrorUnsupportedSetting: the component does not support some or any of the parameters
+ *       (names) specified in nParam
+ *   HW_OMX_ErrorBadParameter: the parameter is invalid (e.g. nParamCount is greater than
+ *       nParamSizeUsed, or some parameter value has invalid type)
+ *
+ * STRUCTURE MEMBERS:
+ *  nSize       : size of the structure in bytes
+ *  nVersion    : OMX specification version information
+ *  cName       : name of vendor extension
+ *  nParamCount : the number of parameter values that are part of this vendor extension
+ *  nParamSizeUsed : the size of nParam
+ *                (must be at least 1 and at most HW_OMX_MAX_ANDROID_VENDOR_PARAMCOUNT)
+ *  param       : the parameter values
+ */
+typedef struct HW_OMX_CONFIG_ANDROID_VENDOR_EXTENSIONTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nIndex;
+    HW_OMX_U8  cName[HW_OMX_MAX_STRINGNAME_SIZE];
+    HW_OMX_DIRTYPE eDir;
+    HW_OMX_U32 nParamCount;
+    HW_OMX_U32 nParamSizeUsed;
+    HW_OMX_CONFIG_ANDROID_VENDOR_PARAMTYPE param[1];
+} HW_OMX_CONFIG_ANDROID_VENDOR_EXTENSIONTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* HW_OMX_IndexExt_h */
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_Other.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_Other.h
@@ -0,0 +1,354 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** @file HW_OMX_Other.h - OpenMax IL version 1.1.2
+ *  The structures needed by Other components to exchange
+ *  parameters and configuration data with the components.
+ */
+
+#ifndef HW_OMX_Other_h
+#define HW_OMX_Other_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/* Each OMX header must include all required header files to allow the
+ *  header to compile without errors.  The includes below are required
+ *  for this header file to compile successfully
+ */
+
+#include "HW_OMX_Core.h"
+
+
+/**
+ * Enumeration of possible data types which match to multiple domains or no
+ * domain at all.  For types which are vendor specific, a value above
+ * HW_OMX_OTHER_VENDORTSTART should be used.
+ */
+typedef enum HW_OMX_OTHER_FORMATTYPE {
+    HW_OMX_OTHER_FormatTime = 0, /**< Transmission of various timestamps, elapsed time,
+                                   time deltas, etc */
+    HW_OMX_OTHER_FormatPower,    /**< Perhaps used for enabling/disabling power
+                                   management, setting clocks? */
+    HW_OMX_OTHER_FormatStats,    /**< Could be things such as frame rate, frames
+                                   dropped, etc */
+    HW_OMX_OTHER_FormatBinary,   /**< Arbitrary binary data */
+    HW_OMX_OTHER_FormatVendorReserved = 1000, /**< Starting value for vendor specific
+                                                formats */
+
+    HW_OMX_OTHER_FormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_OTHER_FormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_OTHER_FormatMax = 0x7FFFFFFF
+} HW_OMX_OTHER_FORMATTYPE;
+
+/**
+ * Enumeration of seek modes.
+ */
+typedef enum HW_OMX_TIME_SEEKMODETYPE {
+    HW_OMX_TIME_SeekModeFast = 0, /**< Prefer seeking to an approximation
+                                * of the requested seek position over
+                                * the actual seek position if it
+                                * results in a faster seek. */
+    HW_OMX_TIME_SeekModeAccurate, /**< Prefer seeking to the actual seek
+                                * position over an approximation
+                                * of the requested seek position even
+                                * if it results in a slower seek. */
+    HW_OMX_TIME_SeekModeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_TIME_SeekModeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_TIME_SeekModeMax = 0x7FFFFFFF
+} HW_OMX_TIME_SEEKMODETYPE;
+
+/* Structure representing the seekmode of the component */
+typedef struct HW_OMX_TIME_CONFIG_SEEKMODETYPE {
+    HW_OMX_U32 nSize;                  /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    HW_OMX_TIME_SEEKMODETYPE eType;    /**< The seek mode */
+} HW_OMX_TIME_CONFIG_SEEKMODETYPE;
+
+/** Structure representing a time stamp used with the following configs
+ * on the Clock Component (CC):
+ *
+ * HW_OMX_IndexConfigTimeCurrentWallTime: query of the CC's current wall
+ *     time
+ * HW_OMX_IndexConfigTimeCurrentMediaTime: query of the CC's current media
+ *     time
+ * HW_OMX_IndexConfigTimeCurrentAudioReference and
+ * HW_OMX_IndexConfigTimeCurrentVideoReference: audio/video reference
+ *     clock sending SC its reference time
+ * HW_OMX_IndexConfigTimeClientStartTime: a Clock Component client sends
+ *     this structure to the Clock Component via a SetConfig on its
+ *     client port when it receives a buffer with
+ *     HW_OMX_BUFFERFLAG_STARTTIME set. It must use the timestamp
+ *     specified by that buffer for nStartTimestamp.
+ *
+ * It's also used with the following config on components in general:
+ *
+ * HW_OMX_IndexConfigTimePosition: IL client querying component position
+ * (GetConfig) or commanding a component to seek to the given location
+ * (SetConfig)
+ */
+typedef struct HW_OMX_TIME_CONFIG_TIMESTAMPTYPE {
+    HW_OMX_U32 nSize;               /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;    /**< OMX specification version
+                                  *   information */
+    HW_OMX_U32 nPortIndex;          /**< port that this structure applies to */
+    HW_OMX_TICKS nTimestamp;        /**< timestamp .*/
+} HW_OMX_TIME_CONFIG_TIMESTAMPTYPE;
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum HW_OMX_TIME_UPDATETYPE {
+      HW_OMX_TIME_UpdateRequestFulfillment,    /**< Update is the fulfillment of a media time request. */
+      HW_OMX_TIME_UpdateScaleChanged,          /**< Update was generated because the scale chagned. */
+      HW_OMX_TIME_UpdateClockStateChanged,     /**< Update was generated because the clock state changed. */
+      HW_OMX_TIME_UpdateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+      HW_OMX_TIME_UpdateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      HW_OMX_TIME_UpdateMax = 0x7FFFFFFF
+} HW_OMX_TIME_UPDATETYPE;
+
+/** Enumeration of possible reference clocks to the media time. */
+typedef enum HW_OMX_TIME_REFCLOCKTYPE {
+      HW_OMX_TIME_RefClockNone,    /**< Use no references. */
+      HW_OMX_TIME_RefClockAudio,   /**< Use references sent through HW_OMX_IndexConfigTimeCurrentAudioReference */
+      HW_OMX_TIME_RefClockVideo,   /**< Use references sent through HW_OMX_IndexConfigTimeCurrentVideoReference */
+      HW_OMX_TIME_RefClockKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+      HW_OMX_TIME_RefClockVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      HW_OMX_TIME_RefClockMax = 0x7FFFFFFF
+} HW_OMX_TIME_REFCLOCKTYPE;
+
+/** Enumeration of clock states. */
+typedef enum HW_OMX_TIME_CLOCKSTATE {
+      HW_OMX_TIME_ClockStateRunning,             /**< Clock running. */
+      HW_OMX_TIME_ClockStateWaitingForStartTime, /**< Clock waiting until the
+                                               *   prescribed clients emit their
+                                               *   start time. */
+      HW_OMX_TIME_ClockStateStopped,             /**< Clock stopped. */
+      HW_OMX_TIME_ClockStateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+      HW_OMX_TIME_ClockStateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+      HW_OMX_TIME_ClockStateMax = 0x7FFFFFFF
+} HW_OMX_TIME_CLOCKSTATE;
+
+/** Structure representing a media time request to the clock component.
+ *
+ *  A client component sends this structure to the Clock Component via a SetConfig
+ *  on its client port to specify a media timestamp the Clock Component
+ *  should emit.  The Clock Component should fulfill the request by sending a
+ *  HW_OMX_TIME_MEDIATIMETYPE when its media clock matches the requested
+ *  timestamp.
+ *
+ *  The client may require a media time request be fulfilled slightly
+ *  earlier than the media time specified. In this case the client specifies
+ *  an offset which is equal to the difference between wall time corresponding
+ *  to the requested media time and the wall time when it will be
+ *  fulfilled.
+ *
+ *  A client component may uses these requests and the HW_OMX_TIME_MEDIATIMETYPE to
+ *  time events according to timestamps. If a client must perform an operation O at
+ *  a time T (e.g. deliver a video frame at its corresponding timestamp), it makes a
+ *  media time request at T (perhaps specifying an offset to ensure the request fulfillment
+ *  is a little early). When the clock component passes the resulting HW_OMX_TIME_MEDIATIMETYPE
+ *  structure back to the client component, the client may perform operation O (perhaps having
+ *  to wait a slight amount more time itself as specified by the return values).
+ */
+
+typedef struct HW_OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex;         /**< port that this structure applies to */
+    HW_OMX_PTR pClientPrivate;     /**< Client private data to disabiguate this media time
+                                 *   from others (e.g. the number of the frame to deliver).
+                                 *   Duplicated in the media time structure that fulfills
+                                 *   this request. A value of zero is reserved for time scale
+                                 *   updates. */
+    HW_OMX_TICKS nMediaTimestamp;  /**< Media timestamp requested.*/
+    HW_OMX_TICKS nOffset;          /**< Amount of wall clock time by which this
+                                 *   request should be fulfilled early */
+} HW_OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE;
+
+/**< Structure sent from the clock component client either when fulfilling
+ *   a media time request or when the time scale has changed.
+ *
+ *   In the former case the Clock Component fills this structure and times its emission
+ *   to a client component (via the client port) according to the corresponding media
+ *   time request sent by the client. The Clock Component should time the emission to occur
+ *   when the requested timestamp matches the Clock Component's media time but also the
+ *   prescribed offset early.
+ *
+ *   Upon scale changes the clock component clears the nClientPrivate data, sends the current
+ *   media time and sets the nScale to the new scale via the client port. It emits a
+ *   HW_OMX_TIME_MEDIATIMETYPE to all clients independent of any requests. This allows clients to
+ *   alter processing to accomodate scaling. For instance a video component might skip inter-frames
+ *   in the case of extreme fastforward. Likewise an audio component might add or remove samples
+ *   from an audio frame to scale audio data.
+ *
+ *   It is expected that some clock components may not be able to fulfill requests
+ *   at exactly the prescribed time. This is acceptable so long as the request is
+ *   fulfilled at least as early as described and not later. This structure provides
+ *   fields the client may use to wait for the remaining time.
+ *
+ *   The client may use either the nOffset or nWallTimeAtMedia fields to determine the
+ *   wall time until the nMediaTimestamp actually occurs. In the latter case the
+ *   client can get a more accurate value for offset by getting the current wall
+ *   from the cloc component and subtracting it from nWallTimeAtMedia.
+ */
+
+typedef struct HW_OMX_TIME_MEDIATIMETYPE {
+    HW_OMX_U32 nSize;                  /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    HW_OMX_U32 nClientPrivate;         /**< Client private data to disabiguate this media time
+                                     *   from others. Copied from the media time request.
+                                     *   A value of zero is reserved for time scale updates. */
+    HW_OMX_TIME_UPDATETYPE eUpdateType; /**< Reason for the update */
+    HW_OMX_TICKS nMediaTimestamp;      /**< Media time requested. If no media time was
+                                     *   requested then this is the current media time. */
+    HW_OMX_TICKS nOffset;              /**< Amount of wall clock time by which this
+                                     *   request was actually fulfilled early */
+
+    HW_OMX_TICKS nWallTimeAtMediaTime; /**< Wall time corresponding to nMediaTimeStamp.
+                                     *   A client may compare this value to current
+                                     *   media time obtained from the Clock Component to determine
+                                     *   the wall time until the media timestamp is really
+                                     *   current. */
+    HW_OMX_S32 xScale;                 /**< Current media time scale in Q16 format. */
+    HW_OMX_TIME_CLOCKSTATE eState;     /* Seeking Change. Added 7/12.*/
+                                    /**< State of the media time. */
+} HW_OMX_TIME_MEDIATIMETYPE;
+
+/** Structure representing the current media time scale factor. Applicable only to clock
+ *  component, other components see scale changes via HW_OMX_TIME_MEDIATIMETYPE buffers sent via
+ *  the clock component client ports. Upon recieving this config the clock component changes
+ *  the rate by which the media time increases or decreases effectively implementing trick modes.
+ */
+typedef struct HW_OMX_TIME_CONFIG_SCALETYPE {
+    HW_OMX_U32 nSize;                  /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    HW_OMX_S32 xScale;                 /**< This is a value in Q16 format which is used for
+                                     * scaling the media time */
+} HW_OMX_TIME_CONFIG_SCALETYPE;
+
+/** Bits used to identify a clock port. Used in HW_OMX_TIME_CONFIG_CLOCKSTATETYPE's nWaitMask field */
+#define HW_OMX_CLOCKPORT0 0x00000001
+#define HW_OMX_CLOCKPORT1 0x00000002
+#define HW_OMX_CLOCKPORT2 0x00000004
+#define HW_OMX_CLOCKPORT3 0x00000008
+#define HW_OMX_CLOCKPORT4 0x00000010
+#define HW_OMX_CLOCKPORT5 0x00000020
+#define HW_OMX_CLOCKPORT6 0x00000040
+#define HW_OMX_CLOCKPORT7 0x00000080
+
+/** Structure representing the current mode of the media clock.
+ *  IL Client uses this config to change or query the mode of the
+ *  media clock of the clock component. Applicable only to clock
+ *  component.
+ *
+ *  On a SetConfig if eState is HW_OMX_TIME_ClockStateRunning media time
+ *  starts immediately at the prescribed start time. If
+ *  HW_OMX_TIME_ClockStateWaitingForStartTime the Clock Component ignores
+ *  the given nStartTime and waits for all clients specified in the
+ *  nWaitMask to send starttimes (via
+ *  HW_OMX_IndexConfigTimeClientStartTime). The Clock Component then starts
+ *  the media clock using the earliest start time supplied. */
+typedef struct HW_OMX_TIME_CONFIG_CLOCKSTATETYPE {
+    HW_OMX_U32 nSize;              /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;   /**< OMX specification version
+                                 *   information */
+    HW_OMX_TIME_CLOCKSTATE eState; /**< State of the media time. */
+    HW_OMX_TICKS nStartTime;       /**< Start time of the media time. */
+    HW_OMX_TICKS nOffset;          /**< Time to offset the media time by
+                                 * (e.g. preroll). Media time will be
+                                 * reported to be nOffset ticks earlier.
+                                 */
+    HW_OMX_U32 nWaitMask;          /**< Mask of HW_OMX_CLOCKPORT values. */
+} HW_OMX_TIME_CONFIG_CLOCKSTATETYPE;
+
+/** Structure representing the reference clock currently being used to
+ *  compute media time. IL client uses this config to change or query the
+ *  clock component's active reference clock */
+typedef struct HW_OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE {
+    HW_OMX_U32 nSize;                  /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;       /**< OMX specification version information */
+    HW_OMX_TIME_REFCLOCKTYPE eClock;   /**< Reference clock used to compute media time */
+} HW_OMX_TIME_CONFIG_ACTIVEREFCLOCKTYPE;
+
+/** Descriptor for setting specifics of power type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct HW_OMX_OTHER_CONFIG_POWERTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_BOOL bEnablePM;       /**< Flag to enable Power Management */
+} HW_OMX_OTHER_CONFIG_POWERTYPE;
+
+
+/** Descriptor for setting specifics of stats type.
+ *  Note: this structure is listed for backwards compatibility. */
+typedef struct HW_OMX_OTHER_CONFIG_STATSTYPE {
+    HW_OMX_U32 nSize;            /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    /* what goes here */
+} HW_OMX_OTHER_CONFIG_STATSTYPE;
+
+
+/**
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output other
+ * path.
+ */
+typedef struct HW_OMX_OTHER_PORTDEFINITIONTYPE {
+    HW_OMX_OTHER_FORMATTYPE eFormat;  /**< Type of data expected for this channel */
+} HW_OMX_OTHER_PORTDEFINITIONTYPE;
+
+/**  Port format parameter.  This structure is used to enumerate
+  *  the various data input/output format supported by the port.
+  */
+typedef struct HW_OMX_OTHER_PARAM_PORTFORMATTYPE {
+    HW_OMX_U32 nSize; /**< size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion; /**< OMX specification version information */
+    HW_OMX_U32 nPortIndex; /**< Indicates which port to set */
+    HW_OMX_U32 nIndex; /**< Indicates the enumeration index for the format from 0x0 to N-1 */
+    HW_OMX_OTHER_FORMATTYPE eFormat; /**< Type of data expected for this channel */
+} HW_OMX_OTHER_PARAM_PORTFORMATTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_Types.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_Types.h
@@ -0,0 +1,393 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/*
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** HW_OMX_Types.h - OpenMax IL version 1.1.2
+ *  The HW_OMX_Types header file contains the primitive type definitions used by
+ *  the core, the application and the component.  This file may need to be
+ *  modified to be used on systems that do not have "char" set to 8 bits,
+ *  "short" set to 16 bits and "long" set to 32 bits.
+ */
+
+#ifndef HW_OMX_Types_h
+#define HW_OMX_Types_h
+
+#include <stdint.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/** The HW_OMX_API and HW_OMX_APIENTRY are platform specific definitions used
+ *  to declare OMX function prototypes.  They are modified to meet the
+ *  requirements for a particular platform */
+#ifdef __SYMBIAN32__
+#   ifdef __HW_OMX_EXPORTS
+#       define HW_OMX_API __declspec(dllexport)
+#   else
+#       ifdef _WIN32
+#           define HW_OMX_API __declspec(dllexport)
+#       else
+#           define HW_OMX_API __declspec(dllimport)
+#       endif
+#   endif
+#else
+#   ifdef _WIN32
+#      ifdef __HW_OMX_EXPORTS
+#          define HW_OMX_API __declspec(dllexport)
+#      else
+//#          define HW_OMX_API __declspec(dllimport)
+#define HW_OMX_API
+#      endif
+#   else
+#      ifdef __HW_OMX_EXPORTS
+#          define HW_OMX_API
+#      else
+#          define HW_OMX_API extern
+#      endif
+#   endif
+#endif
+
+#ifndef HW_OMX_APIENTRY
+#define HW_OMX_APIENTRY
+#endif
+
+/** HW_OMX_IN is used to identify inputs to an OMX function.  This designation
+    will also be used in the case of a pointer that points to a parameter
+    that is used as an output. */
+#ifndef HW_OMX_IN
+#define HW_OMX_IN
+#endif
+
+/** HW_OMX_OUT is used to identify outputs from an OMX function.  This
+    designation will also be used in the case of a pointer that points
+    to a parameter that is used as an input. */
+#ifndef HW_OMX_OUT
+#define HW_OMX_OUT
+#endif
+
+
+/** HW_OMX_INOUT is used to identify parameters that may be either inputs or
+    outputs from an OMX function at the same time.  This designation will
+    also be used in the case of a pointer that  points to a parameter that
+    is used both as an input and an output. */
+#ifndef HW_OMX_INOUT
+#define HW_OMX_INOUT
+#endif
+
+/** HW_OMX_ALL is used to as a wildcard to select all entities of the same type
+ *  when specifying the index, or referring to a object by an index.  (i.e.
+ *  use HW_OMX_ALL to indicate all N channels). When used as a port index
+ *  for a config or parameter this HW_OMX_ALL denotes that the config or
+ *  parameter applies to the entire component not just one port. */
+#define HW_OMX_ALL 0xFFFFFFFF
+
+/** In the following we define groups that help building doxygen documentation */
+
+/** @defgroup core OpenMAX IL core
+ * Functions and structure related to the OMX IL core
+ */
+
+ /** @defgroup comp OpenMAX IL component
+ * Functions and structure related to the OMX IL component
+ */
+
+/** @defgroup rpm Resource and Policy Management
+ * Structures for resource and policy management of components
+ */
+
+/** @defgroup buf Buffer Management
+ * Buffer handling functions and structures
+ */
+
+/** @defgroup tun Tunneling
+ * @ingroup core comp
+ * Structures and functions to manage tunnels among component ports
+ */
+
+/** @defgroup cp Content Pipes
+ *  @ingroup core
+ */
+
+ /** @defgroup metadata Metadata handling
+  *
+  */
+
+/** HW_OMX_U8 is an 8 bit unsigned quantity that is byte aligned */
+typedef unsigned char HW_OMX_U8;
+
+/** HW_OMX_S8 is an 8 bit signed quantity that is byte aligned */
+typedef signed char HW_OMX_S8;
+
+/** HW_OMX_U16 is a 16 bit unsigned quantity that is 16 bit word aligned */
+typedef unsigned short HW_OMX_U16;
+
+/** HW_OMX_S16 is a 16 bit signed quantity that is 16 bit word aligned */
+typedef signed short HW_OMX_S16;
+
+/** HW_OMX_U32 is a 32 bit unsigned quantity that is 32 bit word aligned */
+typedef uint32_t HW_OMX_U32;
+
+/** HW_OMX_S32 is a 32 bit signed quantity that is 32 bit word aligned */
+typedef int32_t HW_OMX_S32;
+
+
+/* Users with compilers that cannot accept the "long long" designation should
+   define the HW_OMX_SKIP64BIT macro.  It should be noted that this may cause
+   some components to fail to compile if the component was written to require
+   64 bit integral types.  However, these components would NOT compile anyway
+   since the compiler does not support the way the component was written.
+*/
+#ifndef HW_OMX_SKIP64BIT
+#ifdef __SYMBIAN32__
+/** HW_OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long HW_OMX_U64;
+
+/** HW_OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long HW_OMX_S64;
+
+#elif defined(WIN32)
+
+/** HW_OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned __int64  HW_OMX_U64;
+
+/** HW_OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed   __int64  HW_OMX_S64;
+
+#else /* WIN32 */
+
+/** HW_OMX_U64 is a 64 bit unsigned quantity that is 64 bit word aligned */
+typedef unsigned long long HW_OMX_U64;
+
+/** HW_OMX_S64 is a 64 bit signed quantity that is 64 bit word aligned */
+typedef signed long long HW_OMX_S64;
+
+#endif /* WIN32 */
+#endif
+
+
+/** The HW_OMX_BOOL type is intended to be used to represent a true or a false
+    value when passing parameters to and from the OMX core and components.  The
+    HW_OMX_BOOL is a 32 bit quantity and is aligned on a 32 bit word boundary.
+ */
+typedef enum HW_OMX_BOOL {
+    HW_OMX_FALSE = 0,
+    HW_OMX_TRUE = !HW_OMX_FALSE,
+    HW_OMX_BOOL_MAX = 0x7FFFFFFF
+} HW_OMX_BOOL;
+
+/*
+ * Temporary Android 64 bit modification
+ *
+ * #define HW_OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS
+ * overrides all OMX pointer types to be uint32_t.
+ *
+ * After this change, OMX codecs will work in 32 bit only, so 64 bit processes
+ * must communicate to a remote 32 bit process for OMX to work.
+ */
+
+#ifdef HW_OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS
+
+typedef uint32_t HW_OMX_PTR;
+typedef HW_OMX_PTR HW_OMX_STRING;
+typedef HW_OMX_PTR HW_OMX_BYTE;
+
+#else /* HW_OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS */
+
+/** The HW_OMX_PTR type is intended to be used to pass pointers between the OMX
+    applications and the OMX Core and components.  This is a 32 bit pointer and
+    is aligned on a 32 bit boundary.
+ */
+typedef void* HW_OMX_PTR;
+
+/** The HW_OMX_STRING type is intended to be used to pass "C" type strings between
+    the application and the core and component.  The HW_OMX_STRING type is a 32
+    bit pointer to a zero terminated string.  The  pointer is word aligned and
+    the string is byte aligned.
+ */
+typedef char* HW_OMX_STRING;
+
+/** The HW_OMX_BYTE type is intended to be used to pass arrays of bytes such as
+    buffers between the application and the component and core.  The HW_OMX_BYTE
+    type is a 32 bit pointer to a zero terminated string.  The  pointer is word
+    aligned and the string is byte aligned.
+ */
+typedef unsigned char* HW_OMX_BYTE;
+
+#endif /* HW_OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS */
+
+/** HW_OMX_UUIDTYPE is a very long unique identifier to uniquely identify
+    at runtime.  This identifier should be generated by a component in a way
+    that guarantees that every instance of the identifier running on the system
+    is unique. */
+typedef unsigned char HW_OMX_UUIDTYPE[128];
+
+/** The HW_OMX_DIRTYPE enumeration is used to indicate if a port is an input or
+    an output port.  This enumeration is common across all component types.
+ */
+typedef enum HW_OMX_DIRTYPE
+{
+    HW_OMX_DirInput,              /**< Port is an input port */
+    HW_OMX_DirOutput,             /**< Port is an output port */
+    HW_OMX_DirMax = 0x7FFFFFFF
+} HW_OMX_DIRTYPE;
+
+/** The HW_OMX_ENDIANTYPE enumeration is used to indicate the bit ordering
+    for numerical data (i.e. big endian, or little endian).
+ */
+typedef enum HW_OMX_ENDIANTYPE
+{
+    HW_OMX_EndianBig, /**< big endian */
+    HW_OMX_EndianLittle, /**< little endian */
+    HW_OMX_EndianMax = 0x7FFFFFFF
+} HW_OMX_ENDIANTYPE;
+
+
+/** The HW_OMX_NUMERICALDATATYPE enumeration is used to indicate if data
+    is signed, unsigned or floating point (Android extension).
+
+    Android floating point support policy:
+    If component does not support floating point raw audio, it can reset
+    configuration to signed 16-bit integer (support for which is required.)
+    nBitsPerSample will be set to 32 for float data.
+ */
+typedef enum HW_OMX_NUMERICALDATATYPE
+{
+    HW_OMX_NumericalDataSigned, /**< signed data */
+    HW_OMX_NumericalDataUnsigned, /**< unsigned data */
+    HW_OMX_NumericalDataFloat = 0x7F000001, /**< floating point data */
+    HW_OMX_NumercialDataMax = 0x7FFFFFFF
+} HW_OMX_NUMERICALDATATYPE;
+
+
+/** Unsigned bounded value type */
+typedef struct HW_OMX_BU32 {
+    HW_OMX_U32 nValue; /**< actual value */
+    HW_OMX_U32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    HW_OMX_U32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} HW_OMX_BU32;
+
+
+/** Signed bounded value type */
+typedef struct HW_OMX_BS32 {
+    HW_OMX_S32 nValue; /**< actual value */
+    HW_OMX_S32 nMin;   /**< minimum for value (i.e. nValue >= nMin) */
+    HW_OMX_S32 nMax;   /**< maximum for value (i.e. nValue <= nMax) */
+} HW_OMX_BS32;
+
+
+/** Structure representing some time or duration in microseconds. This structure
+  *  must be interpreted as a signed 64 bit value. The quantity is signed to accommodate
+  *  negative deltas and preroll scenarios. The quantity is represented in microseconds
+  *  to accomodate high resolution timestamps (e.g. DVD presentation timestamps based
+  *  on a 90kHz clock) and to allow more accurate and synchronized delivery (e.g.
+  *  individual audio samples delivered at 192 kHz). The quantity is 64 bit to
+  *  accommodate a large dynamic range (signed 32 bit values would allow only for plus
+  *  or minus 35 minutes).
+  *
+  *  Implementations with limited precision may convert the signed 64 bit value to
+  *  a signed 32 bit value internally but risk loss of precision.
+  */
+#ifndef HW_OMX_SKIP64BIT
+typedef HW_OMX_S64 HW_OMX_TICKS;
+#else
+typedef struct HW_OMX_TICKS
+{
+    HW_OMX_U32 nLowPart;    /** low bits of the signed 64 bit tick value */
+    HW_OMX_U32 nHighPart;   /** high bits of the signed 64 bit tick value */
+} HW_OMX_TICKS;
+#endif
+#define HW_OMX_TICKS_PER_SECOND 1000000
+
+/** Define the public interface for the OMX Handle.  The core will not use
+    this value internally, but the application should only use this value.
+ */
+typedef HW_OMX_PTR HW_OMX_HANDLETYPE;
+
+typedef struct HW_OMX_MARKTYPE
+{
+    HW_OMX_HANDLETYPE hMarkTargetComponent;   /**< The component that will
+                                                generate a mark event upon
+                                                processing the mark. */
+    HW_OMX_PTR pMarkData;   /**< Application specific data associated with
+                              the mark sent on a mark event to disambiguate
+                              this mark from others. */
+} HW_OMX_MARKTYPE;
+
+
+/** HW_OMX_NATIVE_DEVICETYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the display
+ *  or can be used by a audio port for native audio rendering */
+typedef HW_OMX_PTR HW_OMX_NATIVE_DEVICETYPE;
+
+/** HW_OMX_NATIVE_WINDOWTYPE is used to map a OMX video port to the
+ *  platform & operating specific object used to reference the window */
+typedef HW_OMX_PTR HW_OMX_NATIVE_WINDOWTYPE;
+
+/** The HW_OMX_VERSIONTYPE union is used to specify the version for
+    a structure or component.  For a component, the version is entirely
+    specified by the component vendor.  Components doing the same function
+    from different vendors may or may not have the same version.  For
+    structures, the version shall be set by the entity that allocates the
+    structure.  For structures specified in the OMX 1.1 specification, the
+    value of the version shall be set to 1.1.0.0 in all cases.  Access to the
+    HW_OMX_VERSIONTYPE can be by a single 32 bit access (e.g. by nVersion) or
+    by accessing one of the structure elements to, for example, check only
+    the Major revision.
+ */
+typedef union HW_OMX_VERSIONTYPE
+{
+    struct
+    {
+        HW_OMX_U8 nVersionMajor;   /**< Major version accessor element */
+        HW_OMX_U8 nVersionMinor;   /**< Minor version accessor element */
+        HW_OMX_U8 nRevision;       /**< Revision version accessor element */
+        HW_OMX_U8 nStep;           /**< Step version accessor element */
+    } s;
+    HW_OMX_U32 nVersion;           /**< 32 bit value to make accessing the
+                                    version easily done in a single word
+                                    size copy/compare operation */
+} HW_OMX_VERSIONTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
Index: ffmpeg/libavcodec/HW_OMX_Video.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_Video.h
@@ -0,0 +1,1097 @@
+/* ------------------------------------------------------------------
+ * Copyright (C) 1998-2009 PacketVideo
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
+ * express or implied.
+ * See the License for the specific language governing permissions
+ * and limitations under the License.
+ * -------------------------------------------------------------------
+ */
+/**
+ * Copyright (c) 2008 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/**
+ *  @file HW_OMX_Video.h - OpenMax IL version 1.1.2
+ *  The structures is needed by Video components to exchange parameters
+ *  and configuration data with OMX components.
+ */
+#ifndef HW_OMX_Video_h
+#define HW_OMX_Video_h
+
+/** @defgroup video OpenMAX IL Video Domain
+ * @ingroup iv
+ * Structures for OpenMAX IL Video domain
+ * @{
+ */
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+/**
+ * Each OMX header must include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+
+#include "HW_OMX_IVCommon.h"
+
+
+/**
+ * Enumeration used to define the possible video compression codings.
+ * NOTE:  This essentially refers to file extensions. If the coding is
+ *        being used to specify the ENCODE type, then additional work
+ *        must be done to configure the exact flavor of the compression
+ *        to be used.  For decode cases where the user application can
+ *        not differentiate between MPEG-4 and H.264 bit streams, it is
+ *        up to the codec to handle this.
+ */
+typedef enum HW_OMX_VIDEO_CODINGTYPE {
+    HW_OMX_VIDEO_CodingUnused,     /**< Value when coding is N/A */
+    HW_OMX_VIDEO_CodingAutoDetect, /**< Autodetection of coding type */
+    HW_OMX_VIDEO_CodingMPEG2,      /**< AKA: H.262 */
+    HW_OMX_VIDEO_CodingH263,       /**< H.263 */
+    HW_OMX_VIDEO_CodingMPEG4,      /**< MPEG-4 */
+    HW_OMX_VIDEO_CodingWMV,        /**< all versions of Windows Media Video */
+    HW_OMX_VIDEO_CodingRV,         /**< all versions of Real Video */
+    HW_OMX_VIDEO_CodingAVC,        /**< H.264/AVC */
+    HW_OMX_VIDEO_CodingMJPEG,      /**< Motion JPEG */
+    HW_OMX_VIDEO_CodingVP8,        /**< Google VP8, formerly known as On2 VP8 */
+    HW_OMX_VIDEO_CodingVP9,        /**< Google VP9 */
+    HW_OMX_VIDEO_CodingHEVC,       /**< ITU H.265/HEVC */
+    HW_OMX_VIDEO_CodingDolbyVision,/**< Dolby Vision */
+    HW_OMX_VIDEO_CodingImageHEIC,  /**< HEIF image encoded with HEVC */
+    HW_OMX_VIDEO_CodingKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_CodingVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_CodingMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_CODINGTYPE;
+
+
+/**
+ * Data structure used to define a video path.  The number of Video paths for
+ * input and output will vary by type of the Video component.
+ *
+ *    Input (aka Source) : zero Inputs, one Output,
+ *    Splitter           : one Input, 2 or more Outputs,
+ *    Processing Element : one Input, one output,
+ *    Mixer              : 2 or more inputs, one output,
+ *    Output (aka Sink)  : one Input, zero outputs.
+ *
+ * The PortDefinition structure is used to define all of the parameters
+ * necessary for the compliant component to setup an input or an output video
+ * path.  If additional vendor specific data is required, it should be
+ * transmitted to the component using the CustomCommand function.  Compliant
+ * components will prepopulate this structure with optimal values during the
+ * GetDefaultInitParams command.
+ *
+ * STRUCT MEMBERS:
+ *  cMIMEType             : MIME type of data for the port
+ *  pNativeRender         : Platform specific reference for a display if a
+ *                          sync, otherwise this field is 0
+ *  nFrameWidth           : Width of frame to be used on channel if
+ *                          uncompressed format is used.  Use 0 for unknown,
+ *                          don't care or variable
+ *  nFrameHeight          : Height of frame to be used on channel if
+ *                          uncompressed format is used. Use 0 for unknown,
+ *                          don't care or variable
+ *  nStride               : Number of bytes per span of an image
+ *                          (i.e. indicates the number of bytes to get
+ *                          from span N to span N+1, where negative stride
+ *                          indicates the image is bottom up
+ *  nSliceHeight          : Height used when encoding in slices
+ *  nBitrate              : Bit rate of frame to be used on channel if
+ *                          compressed format is used. Use 0 for unknown,
+ *                          don't care or variable
+ *  xFramerate            : Frame rate to be used on channel if uncompressed
+ *                          format is used. Use 0 for unknown, don't care or
+ *                          variable.  Units are Q16 frames per second.
+ *  bFlagErrorConcealment : Turns on error concealment if it is supported by
+ *                          the OMX component
+ *  eCompressionFormat    : Compression format used in this instance of the
+ *                          component. When HW_OMX_VIDEO_CodingUnused is
+ *                          specified, eColorFormat is used
+ *  eColorFormat : Decompressed format used by this component
+ *  pNativeWindow : Platform specific reference for a window object if a
+ *                          display sink , otherwise this field is 0x0.
+ */
+typedef struct HW_OMX_VIDEO_PORTDEFINITIONTYPE {
+    HW_OMX_STRING cMIMEType;
+    HW_OMX_NATIVE_DEVICETYPE pNativeRender;
+    HW_OMX_U32 nFrameWidth;
+    HW_OMX_U32 nFrameHeight;
+    HW_OMX_S32 nStride;
+    HW_OMX_U32 nSliceHeight;
+    HW_OMX_U32 nBitrate;
+    HW_OMX_U32 xFramerate;
+    HW_OMX_BOOL bFlagErrorConcealment;
+    HW_OMX_VIDEO_CODINGTYPE eCompressionFormat;
+    HW_OMX_COLOR_FORMATTYPE eColorFormat;
+    HW_OMX_NATIVE_WINDOWTYPE pNativeWindow;
+} HW_OMX_VIDEO_PORTDEFINITIONTYPE;
+
+/**
+ * Port format parameter.  This structure is used to enumerate the various
+ * data input/output format supported by the port.
+ *
+ * STRUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Indicates which port to set
+ *  nIndex             : Indicates the enumeration index for the format from
+ *                       0x0 to N-1
+ *  eCompressionFormat : Compression format used in this instance of the
+ *                       component. When HW_OMX_VIDEO_CodingUnused is specified,
+ *                       eColorFormat is used
+ *  eColorFormat       : Decompressed format used by this component
+ *  xFrameRate         : Indicates the video frame rate in Q16 format
+ */
+typedef struct HW_OMX_VIDEO_PARAM_PORTFORMATTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nIndex;
+    HW_OMX_VIDEO_CODINGTYPE eCompressionFormat;
+    HW_OMX_COLOR_FORMATTYPE eColorFormat;
+    HW_OMX_U32 xFramerate;
+} HW_OMX_VIDEO_PARAM_PORTFORMATTYPE;
+
+
+/**
+ * This is a structure for configuring video compression quantization
+ * parameter values.  Codecs may support different QP values for different
+ * frame types.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info
+ *  nPortIndex : Port that this structure applies to
+ *  nQpI       : QP value to use for index frames
+ *  nQpP       : QP value to use for P frames
+ *  nQpB       : QP values to use for bidirectional frames
+ */
+typedef struct HW_OMX_VIDEO_PARAM_QUANTIZATIONTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nQpI;
+    HW_OMX_U32 nQpP;
+    HW_OMX_U32 nQpB;
+} HW_OMX_VIDEO_PARAM_QUANTIZATIONTYPE;
+
+
+/**
+ * Structure for configuration of video fast update parameters.
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version info
+ *  nPortIndex : Port that this structure applies to
+ *  bEnableVFU : Enable/Disable video fast update
+ *  nFirstGOB  : Specifies the number of the first macroblock row
+ *  nFirstMB   : specifies the first MB relative to the specified first GOB
+ *  nNumMBs    : Specifies the number of MBs to be refreshed from nFirstGOB
+ *               and nFirstMB
+ */
+typedef struct HW_OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bEnableVFU;
+    HW_OMX_U32 nFirstGOB;
+    HW_OMX_U32 nFirstMB;
+    HW_OMX_U32 nNumMBs;
+} HW_OMX_VIDEO_PARAM_VIDEOFASTUPDATETYPE;
+
+
+/**
+ * Enumeration of possible bitrate control types
+ */
+typedef enum HW_OMX_VIDEO_CONTROLRATETYPE {
+    HW_OMX_Video_ControlRateDisable,
+    HW_OMX_Video_ControlRateVariable,
+    HW_OMX_Video_ControlRateConstant,
+    HW_OMX_Video_ControlRateVariableSkipFrames,
+    HW_OMX_Video_ControlRateConstantSkipFrames,
+    HW_OMX_Video_ControlRateConstantQuality,
+    HW_OMX_Video_ControlRateKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_Video_ControlRateVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_Video_ControlRateMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_CONTROLRATETYPE;
+
+
+/**
+ * Structure for configuring bitrate mode of a codec.
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  eControlRate   : Control rate type enum
+ *  nTargetBitrate : Target bitrate to encode with (used when eControlRate is
+ *                   not HW_OMX_Video_ControlRateConstantQuality)
+ *  nQualityFactor : Quality to encode with (used when eControlRate is
+ *                   HW_OMX_Video_ControlRateConstantQuality only)
+ */
+typedef struct HW_OMX_VIDEO_PARAM_BITRATETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_CONTROLRATETYPE eControlRate;
+    union {
+        HW_OMX_U32 nTargetBitrate;
+        HW_OMX_U32 nQualityFactor;
+    };
+} HW_OMX_VIDEO_PARAM_BITRATETYPE;
+
+
+/**
+ * Enumeration of possible motion vector (MV) types
+ */
+typedef enum HW_OMX_VIDEO_MOTIONVECTORTYPE {
+    HW_OMX_Video_MotionVectorPixel,
+    HW_OMX_Video_MotionVectorHalfPel,
+    HW_OMX_Video_MotionVectorQuarterPel,
+    HW_OMX_Video_MotionVectorEighthPel,
+    HW_OMX_Video_MotionVectorKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_Video_MotionVectorVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_Video_MotionVectorMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_MOTIONVECTORTYPE;
+
+
+/**
+ * Structure for configuring the number of motion vectors used as well
+ * as their accuracy.
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the struct in bytes
+ *  nVersion         : OMX spec version info
+ *  nPortIndex       : port that this structure applies to
+ *  eAccuracy        : Enumerated MV accuracy
+ *  bUnrestrictedMVs : Allow unrestricted MVs
+ *  bFourMV          : Allow use of 4 MVs
+ *  sXSearchRange    : Search range in horizontal direction for MVs
+ *  sYSearchRange    : Search range in vertical direction for MVs
+ */
+typedef struct HW_OMX_VIDEO_PARAM_MOTIONVECTORTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_MOTIONVECTORTYPE eAccuracy;
+    HW_OMX_BOOL bUnrestrictedMVs;
+    HW_OMX_BOOL bFourMV;
+    HW_OMX_S32 sXSearchRange;
+    HW_OMX_S32 sYSearchRange;
+} HW_OMX_VIDEO_PARAM_MOTIONVECTORTYPE;
+
+
+/**
+ * Enumeration of possible methods to use for Intra Refresh
+ */
+typedef enum HW_OMX_VIDEO_INTRAREFRESHTYPE {
+    HW_OMX_VIDEO_IntraRefreshCyclic,
+    HW_OMX_VIDEO_IntraRefreshAdaptive,
+    HW_OMX_VIDEO_IntraRefreshBoth,
+    HW_OMX_VIDEO_IntraRefreshKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_IntraRefreshVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_IntraRefreshMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for configuring intra refresh mode
+ *
+ * STRUCT MEMBERS:
+ *  nSize        : Size of the structure in bytes
+ *  nVersion     : OMX specification version information
+ *  nPortIndex   : Port that this structure applies to
+ *  eRefreshMode : Cyclic, Adaptive, or Both
+ *  nAirMBs      : Number of intra macroblocks to refresh in a frame when
+ *                 AIR is enabled
+ *  nAirRef      : Number of times a motion marked macroblock has to be
+ *                 intra coded
+ *  nCirMBs      : Number of consecutive macroblocks to be coded as "intra"
+ *                 when CIR is enabled
+ */
+typedef struct HW_OMX_VIDEO_PARAM_INTRAREFRESHTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_INTRAREFRESHTYPE eRefreshMode;
+    HW_OMX_U32 nAirMBs;
+    HW_OMX_U32 nAirRef;
+    HW_OMX_U32 nCirMBs;
+} HW_OMX_VIDEO_PARAM_INTRAREFRESHTYPE;
+
+
+/**
+ * Structure for enabling various error correction methods for video
+ * compression.
+ *
+ * STRUCT MEMBERS:
+ *  nSize                   : Size of the structure in bytes
+ *  nVersion                : OMX specification version information
+ *  nPortIndex              : Port that this structure applies to
+ *  bEnableHEC              : Enable/disable header extension codes (HEC)
+ *  bEnableResync           : Enable/disable resynchronization markers
+ *  nResynchMarkerSpacing   : Resynch markers interval (in bits) to be
+ *                            applied in the stream
+ *  bEnableDataPartitioning : Enable/disable data partitioning
+ *  bEnableRVLC             : Enable/disable reversible variable length
+ *                            coding
+ */
+typedef struct HW_OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bEnableHEC;
+    HW_OMX_BOOL bEnableResync;
+    HW_OMX_U32  nResynchMarkerSpacing;
+    HW_OMX_BOOL bEnableDataPartitioning;
+    HW_OMX_BOOL bEnableRVLC;
+} HW_OMX_VIDEO_PARAM_ERRORCORRECTIONTYPE;
+
+
+/**
+ * Configuration of variable block-size motion compensation (VBSMC)
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  b16x16     : Enable inter block search 16x16
+ *  b16x8      : Enable inter block search 16x8
+ *  b8x16      : Enable inter block search 8x16
+ *  b8x8       : Enable inter block search 8x8
+ *  b8x4       : Enable inter block search 8x4
+ *  b4x8       : Enable inter block search 4x8
+ *  b4x4       : Enable inter block search 4x4
+ */
+typedef struct HW_OMX_VIDEO_PARAM_VBSMCTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL b16x16;
+    HW_OMX_BOOL b16x8;
+    HW_OMX_BOOL b8x16;
+    HW_OMX_BOOL b8x8;
+    HW_OMX_BOOL b8x4;
+    HW_OMX_BOOL b4x8;
+    HW_OMX_BOOL b4x4;
+} HW_OMX_VIDEO_PARAM_VBSMCTYPE;
+
+
+/**
+ * H.263 profile types, each profile indicates support for various
+ * performance bounds and different annexes.
+ *
+ * ENUMS:
+ *  Baseline           : Baseline Profile: H.263 (V1), no optional modes
+ *  H320 Coding        : H.320 Coding Efficiency Backward Compatibility
+ *                       Profile: H.263+ (V2), includes annexes I, J, L.4
+ *                       and T
+ *  BackwardCompatible : Backward Compatibility Profile: H.263 (V1),
+ *                       includes annex F
+ *  ISWV2              : Interactive Streaming Wireless Profile: H.263+
+ *                       (V2), includes annexes I, J, K and T
+ *  ISWV3              : Interactive Streaming Wireless Profile: H.263++
+ *                       (V3), includes profile 3 and annexes V and W.6.3.8
+ *  HighCompression    : Conversational High Compression Profile: H.263++
+ *                       (V3), includes profiles 1 & 2 and annexes D and U
+ *  Internet           : Conversational Internet Profile: H.263++ (V3),
+ *                       includes profile 5 and annex K
+ *  Interlace          : Conversational Interlace Profile: H.263++ (V3),
+ *                       includes profile 5 and annex W.6.3.11
+ *  HighLatency        : High Latency Profile: H.263++ (V3), includes
+ *                       profile 6 and annexes O.1 and P.5
+ */
+typedef enum HW_OMX_VIDEO_H263PROFILETYPE {
+    HW_OMX_VIDEO_H263ProfileBaseline            = 0x01,
+    HW_OMX_VIDEO_H263ProfileH320Coding          = 0x02,
+    HW_OMX_VIDEO_H263ProfileBackwardCompatible  = 0x04,
+    HW_OMX_VIDEO_H263ProfileISWV2               = 0x08,
+    HW_OMX_VIDEO_H263ProfileISWV3               = 0x10,
+    HW_OMX_VIDEO_H263ProfileHighCompression     = 0x20,
+    HW_OMX_VIDEO_H263ProfileInternet            = 0x40,
+    HW_OMX_VIDEO_H263ProfileInterlace           = 0x80,
+    HW_OMX_VIDEO_H263ProfileHighLatency         = 0x100,
+    HW_OMX_VIDEO_H263ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_H263ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_H263ProfileMax                 = 0x7FFFFFFF
+} HW_OMX_VIDEO_H263PROFILETYPE;
+
+
+/**
+ * H.263 level types, each level indicates support for various frame sizes,
+ * bit rates, decoder frame rates.
+ */
+typedef enum HW_OMX_VIDEO_H263LEVELTYPE {
+    HW_OMX_VIDEO_H263Level10  = 0x01,
+    HW_OMX_VIDEO_H263Level20  = 0x02,
+    HW_OMX_VIDEO_H263Level30  = 0x04,
+    HW_OMX_VIDEO_H263Level40  = 0x08,
+    HW_OMX_VIDEO_H263Level45  = 0x10,
+    HW_OMX_VIDEO_H263Level50  = 0x20,
+    HW_OMX_VIDEO_H263Level60  = 0x40,
+    HW_OMX_VIDEO_H263Level70  = 0x80,
+    HW_OMX_VIDEO_H263LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_H263LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_H263LevelMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_H263LEVELTYPE;
+
+
+/**
+ * Specifies the picture type. These values should be OR'd to signal all
+ * pictures types which are allowed.
+ *
+ * ENUMS:
+ *  Generic Picture Types:          I, P and B
+ *  H.263 Specific Picture Types:   SI and SP
+ *  H.264 Specific Picture Types:   EI and EP
+ *  MPEG-4 Specific Picture Types:  S
+ */
+typedef enum HW_OMX_VIDEO_PICTURETYPE {
+    HW_OMX_VIDEO_PictureTypeI   = 0x01,
+    HW_OMX_VIDEO_PictureTypeP   = 0x02,
+    HW_OMX_VIDEO_PictureTypeB   = 0x04,
+    HW_OMX_VIDEO_PictureTypeSI  = 0x08,
+    HW_OMX_VIDEO_PictureTypeSP  = 0x10,
+    HW_OMX_VIDEO_PictureTypeEI  = 0x11,
+    HW_OMX_VIDEO_PictureTypeEP  = 0x12,
+    HW_OMX_VIDEO_PictureTypeS   = 0x14,
+    HW_OMX_VIDEO_PictureTypeKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_PictureTypeVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_PictureTypeMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_PICTURETYPE;
+
+
+/**
+ * H.263 Params
+ *
+ * STRUCT MEMBERS:
+ *  nSize                    : Size of the structure in bytes
+ *  nVersion                 : OMX specification version information
+ *  nPortIndex               : Port that this structure applies to
+ *  nPFrames                 : Number of P frames between each I frame
+ *  nBFrames                 : Number of B frames between each I frame
+ *  eProfile                 : H.263 profile(s) to use
+ *  eLevel                   : H.263 level(s) to use
+ *  bPLUSPTYPEAllowed        : Indicating that it is allowed to use PLUSPTYPE
+ *                             (specified in the 1998 version of H.263) to
+ *                             indicate custom picture sizes or clock
+ *                             frequencies
+ *  nAllowedPictureTypes     : Specifies the picture types allowed in the
+ *                             bitstream
+ *  bForceRoundingTypeToZero : value of the RTYPE bit (bit 6 of MPPTYPE) is
+ *                             not constrained. It is recommended to change
+ *                             the value of the RTYPE bit for each reference
+ *                             picture in error-free communication
+ *  nPictureHeaderRepetition : Specifies the frequency of picture header
+ *                             repetition
+ *  nGOBHeaderInterval       : Specifies the interval of non-empty GOB
+ *                             headers in units of GOBs
+ */
+typedef struct HW_OMX_VIDEO_PARAM_H263TYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nPFrames;
+    HW_OMX_U32 nBFrames;
+    HW_OMX_VIDEO_H263PROFILETYPE eProfile;
+    HW_OMX_VIDEO_H263LEVELTYPE eLevel;
+    HW_OMX_BOOL bPLUSPTYPEAllowed;
+    HW_OMX_U32 nAllowedPictureTypes;
+    HW_OMX_BOOL bForceRoundingTypeToZero;
+    HW_OMX_U32 nPictureHeaderRepetition;
+    HW_OMX_U32 nGOBHeaderInterval;
+} HW_OMX_VIDEO_PARAM_H263TYPE;
+
+
+/**
+ * MPEG-2 profile types, each profile indicates support for various
+ * performance bounds and different annexes.
+ */
+typedef enum HW_OMX_VIDEO_MPEG2PROFILETYPE {
+    HW_OMX_VIDEO_MPEG2ProfileSimple = 0,  /**< Simple Profile */
+    HW_OMX_VIDEO_MPEG2ProfileMain,        /**< Main Profile */
+    HW_OMX_VIDEO_MPEG2Profile422,         /**< 4:2:2 Profile */
+    HW_OMX_VIDEO_MPEG2ProfileSNR,         /**< SNR Profile */
+    HW_OMX_VIDEO_MPEG2ProfileSpatial,     /**< Spatial Profile */
+    HW_OMX_VIDEO_MPEG2ProfileHigh,        /**< High Profile */
+    HW_OMX_VIDEO_MPEG2ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_MPEG2ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_MPEG2ProfileMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_MPEG2PROFILETYPE;
+
+
+/**
+ * MPEG-2 level types, each level indicates support for various frame
+ * sizes, bit rates, decoder frame rates.  No need
+ */
+typedef enum HW_OMX_VIDEO_MPEG2LEVELTYPE {
+    HW_OMX_VIDEO_MPEG2LevelLL = 0,  /**< Low Level */
+    HW_OMX_VIDEO_MPEG2LevelML,      /**< Main Level */
+    HW_OMX_VIDEO_MPEG2LevelH14,     /**< High 1440 */
+    HW_OMX_VIDEO_MPEG2LevelHL,      /**< High Level */
+    HW_OMX_VIDEO_MPEG2LevelHP,      /**< HighP Level */
+    HW_OMX_VIDEO_MPEG2LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_MPEG2LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_MPEG2LevelMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_MPEG2LEVELTYPE;
+
+
+/**
+ * MPEG-2 params
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nPFrames   : Number of P frames between each I frame
+ *  nBFrames   : Number of B frames between each I frame
+ *  eProfile   : MPEG-2 profile(s) to use
+ *  eLevel     : MPEG-2 levels(s) to use
+ */
+typedef struct HW_OMX_VIDEO_PARAM_MPEG2TYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nPFrames;
+    HW_OMX_U32 nBFrames;
+    HW_OMX_VIDEO_MPEG2PROFILETYPE eProfile;
+    HW_OMX_VIDEO_MPEG2LEVELTYPE eLevel;
+} HW_OMX_VIDEO_PARAM_MPEG2TYPE;
+
+
+/**
+ * MPEG-4 profile types, each profile indicates support for various
+ * performance bounds and different annexes.
+ *
+ * ENUMS:
+ *  - Simple Profile, Levels 1-3
+ *  - Simple Scalable Profile, Levels 1-2
+ *  - Core Profile, Levels 1-2
+ *  - Main Profile, Levels 2-4
+ *  - N-bit Profile, Level 2
+ *  - Scalable Texture Profile, Level 1
+ *  - Simple Face Animation Profile, Levels 1-2
+ *  - Simple Face and Body Animation (FBA) Profile, Levels 1-2
+ *  - Basic Animated Texture Profile, Levels 1-2
+ *  - Hybrid Profile, Levels 1-2
+ *  - Advanced Real Time Simple Profiles, Levels 1-4
+ *  - Core Scalable Profile, Levels 1-3
+ *  - Advanced Coding Efficiency Profile, Levels 1-4
+ *  - Advanced Core Profile, Levels 1-2
+ *  - Advanced Scalable Texture, Levels 2-3
+ */
+typedef enum HW_OMX_VIDEO_MPEG4PROFILETYPE {
+    HW_OMX_VIDEO_MPEG4ProfileSimple           = 0x01,
+    HW_OMX_VIDEO_MPEG4ProfileSimpleScalable   = 0x02,
+    HW_OMX_VIDEO_MPEG4ProfileCore             = 0x04,
+    HW_OMX_VIDEO_MPEG4ProfileMain             = 0x08,
+    HW_OMX_VIDEO_MPEG4ProfileNbit             = 0x10,
+    HW_OMX_VIDEO_MPEG4ProfileScalableTexture  = 0x20,
+    HW_OMX_VIDEO_MPEG4ProfileSimpleFace       = 0x40,
+    HW_OMX_VIDEO_MPEG4ProfileSimpleFBA        = 0x80,
+    HW_OMX_VIDEO_MPEG4ProfileBasicAnimated    = 0x100,
+    HW_OMX_VIDEO_MPEG4ProfileHybrid           = 0x200,
+    HW_OMX_VIDEO_MPEG4ProfileAdvancedRealTime = 0x400,
+    HW_OMX_VIDEO_MPEG4ProfileCoreScalable     = 0x800,
+    HW_OMX_VIDEO_MPEG4ProfileAdvancedCoding   = 0x1000,
+    HW_OMX_VIDEO_MPEG4ProfileAdvancedCore     = 0x2000,
+    HW_OMX_VIDEO_MPEG4ProfileAdvancedScalable = 0x4000,
+    HW_OMX_VIDEO_MPEG4ProfileAdvancedSimple   = 0x8000,
+    HW_OMX_VIDEO_MPEG4ProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_MPEG4ProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_MPEG4ProfileMax              = 0x7FFFFFFF
+} HW_OMX_VIDEO_MPEG4PROFILETYPE;
+
+
+/**
+ * MPEG-4 level types, each level indicates support for various frame
+ * sizes, bit rates, decoder frame rates.  No need
+ */
+typedef enum HW_OMX_VIDEO_MPEG4LEVELTYPE {
+    HW_OMX_VIDEO_MPEG4Level0  = 0x01,   /**< Level 0 */
+    HW_OMX_VIDEO_MPEG4Level0b = 0x02,   /**< Level 0b */
+    HW_OMX_VIDEO_MPEG4Level1  = 0x04,   /**< Level 1 */
+    HW_OMX_VIDEO_MPEG4Level2  = 0x08,   /**< Level 2 */
+    HW_OMX_VIDEO_MPEG4Level3  = 0x10,   /**< Level 3 */
+    /* normally levels are powers of 2s, but 3b was missed and levels must be properly ordered */
+    HW_OMX_VIDEO_MPEG4Level3b = 0x18,   /**< Level 3a */
+    HW_OMX_VIDEO_MPEG4Level4  = 0x20,   /**< Level 4 */
+    HW_OMX_VIDEO_MPEG4Level4a = 0x40,   /**< Level 4a */
+    HW_OMX_VIDEO_MPEG4Level5  = 0x80,   /**< Level 5 */
+    HW_OMX_VIDEO_MPEG4Level6  = 0x100,  /**< Level 6 */
+    HW_OMX_VIDEO_MPEG4LevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_MPEG4LevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_MPEG4LevelMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_MPEG4LEVELTYPE;
+
+
+/**
+ * MPEG-4 configuration.  This structure handles configuration options
+ * which are specific to MPEG4 algorithms
+ *
+ * STRUCT MEMBERS:
+ *  nSize                : Size of the structure in bytes
+ *  nVersion             : OMX specification version information
+ *  nPortIndex           : Port that this structure applies to
+ *  nSliceHeaderSpacing  : Number of macroblocks between slice header (H263+
+ *                         Annex K). Put zero if not used
+ *  bSVH                 : Enable Short Video Header mode
+ *  bGov                 : Flag to enable GOV
+ *  nPFrames             : Number of P frames between each I frame (also called
+ *                         GOV period)
+ *  nBFrames             : Number of B frames between each I frame
+ *  nIDCVLCThreshold     : Value of intra DC VLC threshold
+ *  bACPred              : Flag to use ac prediction
+ *  nMaxPacketSize       : Maximum size of packet in bytes.
+ *  nTimeIncRes          : Used to pass VOP time increment resolution for MPEG4.
+ *                         Interpreted as described in MPEG4 standard.
+ *  eProfile             : MPEG-4 profile(s) to use.
+ *  eLevel               : MPEG-4 level(s) to use.
+ *  nAllowedPictureTypes : Specifies the picture types allowed in the bitstream
+ *  nHeaderExtension     : Specifies the number of consecutive video packet
+ *                         headers within a VOP
+ *  bReversibleVLC       : Specifies whether reversible variable length coding
+ *                         is in use
+ */
+typedef struct HW_OMX_VIDEO_PARAM_MPEG4TYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nSliceHeaderSpacing;
+    HW_OMX_BOOL bSVH;
+    HW_OMX_BOOL bGov;
+    HW_OMX_U32 nPFrames;
+    HW_OMX_U32 nBFrames;
+    HW_OMX_U32 nIDCVLCThreshold;
+    HW_OMX_BOOL bACPred;
+    HW_OMX_U32 nMaxPacketSize;
+    HW_OMX_U32 nTimeIncRes;
+    HW_OMX_VIDEO_MPEG4PROFILETYPE eProfile;
+    HW_OMX_VIDEO_MPEG4LEVELTYPE eLevel;
+    HW_OMX_U32 nAllowedPictureTypes;
+    HW_OMX_U32 nHeaderExtension;
+    HW_OMX_BOOL bReversibleVLC;
+} HW_OMX_VIDEO_PARAM_MPEG4TYPE;
+
+
+/**
+ * WMV Versions
+ */
+typedef enum HW_OMX_VIDEO_WMVFORMATTYPE {
+    HW_OMX_VIDEO_WMVFormatUnused = 0x01,   /**< Format unused or unknown */
+    HW_OMX_VIDEO_WMVFormat7      = 0x02,   /**< Windows Media Video format 7 */
+    HW_OMX_VIDEO_WMVFormat8      = 0x04,   /**< Windows Media Video format 8 */
+    HW_OMX_VIDEO_WMVFormat9      = 0x08,   /**< Windows Media Video format 9 */
+    HW_OMX_VIDEO_WMFFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_WMFFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_WMVFormatMax    = 0x7FFFFFFF
+} HW_OMX_VIDEO_WMVFORMATTYPE;
+
+
+/**
+ * WMV Params
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  eFormat    : Version of WMV stream / data
+ */
+typedef struct HW_OMX_VIDEO_PARAM_WMVTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_WMVFORMATTYPE eFormat;
+} HW_OMX_VIDEO_PARAM_WMVTYPE;
+
+
+/**
+ * Real Video Version
+ */
+typedef enum HW_OMX_VIDEO_RVFORMATTYPE {
+    HW_OMX_VIDEO_RVFormatUnused = 0, /**< Format unused or unknown */
+    HW_OMX_VIDEO_RVFormat8,          /**< Real Video format 8 */
+    HW_OMX_VIDEO_RVFormat9,          /**< Real Video format 9 */
+    HW_OMX_VIDEO_RVFormatG2,         /**< Real Video Format G2 */
+    HW_OMX_VIDEO_RVFormatKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_RVFormatVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_RVFormatMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_RVFORMATTYPE;
+
+
+/**
+ * Real Video Params
+ *
+ * STUCT MEMBERS:
+ *  nSize              : Size of the structure in bytes
+ *  nVersion           : OMX specification version information
+ *  nPortIndex         : Port that this structure applies to
+ *  eFormat            : Version of RV stream / data
+ *  nBitsPerPixel      : Bits per pixel coded in the frame
+ *  nPaddedWidth       : Padded width in pixel of a video frame
+ *  nPaddedHeight      : Padded Height in pixels of a video frame
+ *  nFrameRate         : Rate of video in frames per second
+ *  nBitstreamFlags    : Flags which internal information about the bitstream
+ *  nBitstreamVersion  : Bitstream version
+ *  nMaxEncodeFrameSize: Max encoded frame size
+ *  bEnablePostFilter  : Turn on/off post filter
+ *  bEnableTemporalInterpolation : Turn on/off temporal interpolation
+ *  bEnableLatencyMode : When enabled, the decoder does not display a decoded
+ *                       frame until it has detected that no enhancement layer
+ *                       frames or dependent B frames will be coming. This
+ *                       detection usually occurs when a subsequent non-B
+ *                       frame is encountered
+ */
+typedef struct HW_OMX_VIDEO_PARAM_RVTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_RVFORMATTYPE eFormat;
+    HW_OMX_U16 nBitsPerPixel;
+    HW_OMX_U16 nPaddedWidth;
+    HW_OMX_U16 nPaddedHeight;
+    HW_OMX_U32 nFrameRate;
+    HW_OMX_U32 nBitstreamFlags;
+    HW_OMX_U32 nBitstreamVersion;
+    HW_OMX_U32 nMaxEncodeFrameSize;
+    HW_OMX_BOOL bEnablePostFilter;
+    HW_OMX_BOOL bEnableTemporalInterpolation;
+    HW_OMX_BOOL bEnableLatencyMode;
+} HW_OMX_VIDEO_PARAM_RVTYPE;
+
+
+/**
+ * AVC profile types, each profile indicates support for various
+ * performance bounds and different annexes.
+ */
+typedef enum HW_OMX_VIDEO_AVCPROFILETYPE {
+    HW_OMX_VIDEO_AVCProfileBaseline = 0x01,   /**< Baseline profile */
+    HW_OMX_VIDEO_AVCProfileMain     = 0x02,   /**< Main profile */
+    HW_OMX_VIDEO_AVCProfileExtended = 0x04,   /**< Extended profile */
+    HW_OMX_VIDEO_AVCProfileHigh     = 0x08,   /**< High profile */
+    HW_OMX_VIDEO_AVCProfileHigh10   = 0x10,   /**< High 10 profile */
+    HW_OMX_VIDEO_AVCProfileHigh422  = 0x20,   /**< High 4:2:2 profile */
+    HW_OMX_VIDEO_AVCProfileHigh444  = 0x40,   /**< High 4:4:4 profile */
+    HW_OMX_VIDEO_AVCProfileKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_AVCProfileVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_AVCProfileMax      = 0x7FFFFFFF
+} HW_OMX_VIDEO_AVCPROFILETYPE;
+
+
+/**
+ * AVC level types, each level indicates support for various frame sizes,
+ * bit rates, decoder frame rates.  No need
+ */
+typedef enum HW_OMX_VIDEO_AVCLEVELTYPE {
+    HW_OMX_VIDEO_AVCLevel1   = 0x01,     /**< Level 1 */
+    HW_OMX_VIDEO_AVCLevel1b  = 0x02,     /**< Level 1b */
+    HW_OMX_VIDEO_AVCLevel11  = 0x04,     /**< Level 1.1 */
+    HW_OMX_VIDEO_AVCLevel12  = 0x08,     /**< Level 1.2 */
+    HW_OMX_VIDEO_AVCLevel13  = 0x10,     /**< Level 1.3 */
+    HW_OMX_VIDEO_AVCLevel2   = 0x20,     /**< Level 2 */
+    HW_OMX_VIDEO_AVCLevel21  = 0x40,     /**< Level 2.1 */
+    HW_OMX_VIDEO_AVCLevel22  = 0x80,     /**< Level 2.2 */
+    HW_OMX_VIDEO_AVCLevel3   = 0x100,    /**< Level 3 */
+    HW_OMX_VIDEO_AVCLevel31  = 0x200,    /**< Level 3.1 */
+    HW_OMX_VIDEO_AVCLevel32  = 0x400,    /**< Level 3.2 */
+    HW_OMX_VIDEO_AVCLevel4   = 0x800,    /**< Level 4 */
+    HW_OMX_VIDEO_AVCLevel41  = 0x1000,   /**< Level 4.1 */
+    HW_OMX_VIDEO_AVCLevel42  = 0x2000,   /**< Level 4.2 */
+    HW_OMX_VIDEO_AVCLevel5   = 0x4000,   /**< Level 5 */
+    HW_OMX_VIDEO_AVCLevel51  = 0x8000,   /**< Level 5.1 */
+    HW_OMX_VIDEO_AVCLevel52  = 0x10000,  /**< Level 5.2 */
+    HW_OMX_VIDEO_AVCLevel6   = 0x20000,  /**< Level 6 */
+    HW_OMX_VIDEO_AVCLevel61  = 0x40000,  /**< Level 6.1 */
+    HW_OMX_VIDEO_AVCLevel62  = 0x80000,  /**< Level 6.2 */
+    HW_OMX_VIDEO_AVCLevelKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_AVCLevelVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_AVCLevelMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_AVCLEVELTYPE;
+
+
+/**
+ * AVC loop filter modes
+ *
+ * HW_OMX_VIDEO_AVCLoopFilterEnable               : Enable
+ * HW_OMX_VIDEO_AVCLoopFilterDisable              : Disable
+ * HW_OMX_VIDEO_AVCLoopFilterDisableSliceBoundary : Disabled on slice boundaries
+ */
+typedef enum HW_OMX_VIDEO_AVCLOOPFILTERTYPE {
+    HW_OMX_VIDEO_AVCLoopFilterEnable = 0,
+    HW_OMX_VIDEO_AVCLoopFilterDisable,
+    HW_OMX_VIDEO_AVCLoopFilterDisableSliceBoundary,
+    HW_OMX_VIDEO_AVCLoopFilterKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_AVCLoopFilterVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_AVCLoopFilterMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_AVCLOOPFILTERTYPE;
+
+
+/**
+ * AVC params
+ *
+ * STRUCT MEMBERS:
+ *  nSize                     : Size of the structure in bytes
+ *  nVersion                  : OMX specification version information
+ *  nPortIndex                : Port that this structure applies to
+ *  nSliceHeaderSpacing       : Number of macroblocks between slice header, put
+ *                              zero if not used
+ *  nPFrames                  : Number of P frames between each I frame
+ *  nBFrames                  : Number of B frames between each I frame
+ *  bUseHadamard              : Enable/disable Hadamard transform
+ *  nRefFrames                : Max number of reference frames to use for inter
+ *                              motion search (1-16)
+ *  nRefIdxTrailing           : Pic param set ref frame index (index into ref
+ *                              frame buffer of trailing frames list), B frame
+ *                              support
+ *  nRefIdxForward            : Pic param set ref frame index (index into ref
+ *                              frame buffer of forward frames list), B frame
+ *                              support
+ *  bEnableUEP                : Enable/disable unequal error protection. This
+ *                              is only valid of data partitioning is enabled.
+ *  bEnableFMO                : Enable/disable flexible macroblock ordering
+ *  bEnableASO                : Enable/disable arbitrary slice ordering
+ *  bEnableRS                 : Enable/disable sending of redundant slices
+ *  eProfile                  : AVC profile(s) to use
+ *  eLevel                    : AVC level(s) to use
+ *  nAllowedPictureTypes      : Specifies the picture types allowed in the
+ *                              bitstream
+ *  bFrameMBsOnly             : specifies that every coded picture of the
+ *                              coded video sequence is a coded frame
+ *                              containing only frame macroblocks
+ *  bMBAFF                    : Enable/disable switching between frame and
+ *                              field macroblocks within a picture
+ *  bEntropyCodingCABAC       : Entropy decoding method to be applied for the
+ *                              syntax elements for which two descriptors appear
+ *                              in the syntax tables
+ *  bWeightedPPrediction      : Enable/disable weighted prediction shall not
+ *                              be applied to P and SP slices
+ *  nWeightedBipredicitonMode : Default weighted prediction is applied to B
+ *                              slices
+ *  bconstIpred               : Enable/disable intra prediction
+ *  bDirect8x8Inference       : Specifies the method used in the derivation
+ *                              process for luma motion vectors for B_Skip,
+ *                              B_Direct_16x16 and B_Direct_8x8 as specified
+ *                              in subclause 8.4.1.2 of the AVC spec
+ *  bDirectSpatialTemporal    : Flag indicating spatial or temporal direct
+ *                              mode used in B slice coding (related to
+ *                              bDirect8x8Inference) . Spatial direct mode is
+ *                              more common and should be the default.
+ *  nCabacInitIdx             : Index used to init CABAC contexts
+ *  eLoopFilterMode           : Enable/disable loop filter
+ */
+typedef struct HW_OMX_VIDEO_PARAM_AVCTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nSliceHeaderSpacing;
+    HW_OMX_U32 nPFrames;
+    HW_OMX_U32 nBFrames;
+    HW_OMX_BOOL bUseHadamard;
+    HW_OMX_U32 nRefFrames;
+    HW_OMX_U32 nRefIdx10ActiveMinus1;
+    HW_OMX_U32 nRefIdx11ActiveMinus1;
+    HW_OMX_BOOL bEnableUEP;
+    HW_OMX_BOOL bEnableFMO;
+    HW_OMX_BOOL bEnableASO;
+    HW_OMX_BOOL bEnableRS;
+    HW_OMX_VIDEO_AVCPROFILETYPE eProfile;
+    HW_OMX_VIDEO_AVCLEVELTYPE eLevel;
+    HW_OMX_U32 nAllowedPictureTypes;
+    HW_OMX_BOOL bFrameMBsOnly;
+    HW_OMX_BOOL bMBAFF;
+    HW_OMX_BOOL bEntropyCodingCABAC;
+    HW_OMX_BOOL bWeightedPPrediction;
+    HW_OMX_U32 nWeightedBipredicitonMode;
+    HW_OMX_BOOL bconstIpred ;
+    HW_OMX_BOOL bDirect8x8Inference;
+    HW_OMX_BOOL bDirectSpatialTemporal;
+    HW_OMX_U32 nCabacInitIdc;
+    HW_OMX_VIDEO_AVCLOOPFILTERTYPE eLoopFilterMode;
+} HW_OMX_VIDEO_PARAM_AVCTYPE;
+
+typedef struct HW_OMX_VIDEO_PARAM_PROFILELEVELTYPE {
+   HW_OMX_U32 nSize;
+   HW_OMX_VERSIONTYPE nVersion;
+   HW_OMX_U32 nPortIndex;
+   HW_OMX_U32 eProfile;      /**< type is HW_OMX_VIDEO_AVCPROFILETYPE, HW_OMX_VIDEO_H263PROFILETYPE,
+                                 or HW_OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   HW_OMX_U32 eLevel;        /**< type is HW_OMX_VIDEO_AVCLEVELTYPE, HW_OMX_VIDEO_H263LEVELTYPE,
+                                 or HW_OMX_VIDEO_MPEG4PROFILETYPE depending on context */
+   HW_OMX_U32 nProfileIndex; /**< Used to query for individual profile support information,
+                               This parameter is valid only for
+                               HW_OMX_IndexParamVideoProfileLevelQuerySupported index,
+                               For all other indices this parameter is to be ignored. */
+} HW_OMX_VIDEO_PARAM_PROFILELEVELTYPE;
+
+/**
+ * Structure for dynamically configuring bitrate mode of a codec.
+ *
+ * STRUCT MEMBERS:
+ *  nSize          : Size of the struct in bytes
+ *  nVersion       : OMX spec version info
+ *  nPortIndex     : Port that this struct applies to
+ *  nEncodeBitrate : Target average bitrate to be generated in bps
+ */
+typedef struct HW_OMX_VIDEO_CONFIG_BITRATETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nEncodeBitrate;
+} HW_OMX_VIDEO_CONFIG_BITRATETYPE;
+
+/**
+ * Defines Encoder Frame Rate setting
+ *
+ * STRUCT MEMBERS:
+ *  nSize            : Size of the structure in bytes
+ *  nVersion         : OMX specification version information
+ *  nPortIndex       : Port that this structure applies to
+ *  xEncodeFramerate : Encoding framerate represented in Q16 format
+ */
+typedef struct HW_OMX_CONFIG_FRAMERATETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 xEncodeFramerate; /* Q16 format */
+} HW_OMX_CONFIG_FRAMERATETYPE;
+
+typedef struct HW_OMX_CONFIG_INTRAREFRESHVOPTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL IntraRefreshVOP;
+} HW_OMX_CONFIG_INTRAREFRESHVOPTYPE;
+
+typedef struct HW_OMX_CONFIG_MACROBLOCKERRORMAPTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nErrMapSize;           /* Size of the Error Map in bytes */
+    HW_OMX_U8  ErrMap[1];             /* Error map hint */
+} HW_OMX_CONFIG_MACROBLOCKERRORMAPTYPE;
+
+typedef struct HW_OMX_CONFIG_MBERRORREPORTINGTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bEnabled;
+} HW_OMX_CONFIG_MBERRORREPORTINGTYPE;
+
+typedef struct HW_OMX_PARAM_MACROBLOCKSTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nMacroblocks;
+} HW_OMX_PARAM_MACROBLOCKSTYPE;
+
+/**
+ * AVC Slice Mode modes
+ *
+ * HW_OMX_VIDEO_SLICEMODE_AVCDefault   : Normal frame encoding, one slice per frame
+ * HW_OMX_VIDEO_SLICEMODE_AVCMBSlice   : NAL mode, number of MBs per frame
+ * HW_OMX_VIDEO_SLICEMODE_AVCByteSlice : NAL mode, number of bytes per frame
+ */
+typedef enum HW_OMX_VIDEO_AVCSLICEMODETYPE {
+    HW_OMX_VIDEO_SLICEMODE_AVCDefault = 0,
+    HW_OMX_VIDEO_SLICEMODE_AVCMBSlice,
+    HW_OMX_VIDEO_SLICEMODE_AVCByteSlice,
+    HW_OMX_VIDEO_SLICEMODE_AVCKhronosExtensions = 0x6F000000, /**< Reserved region for introducing Khronos Standard Extensions */
+    HW_OMX_VIDEO_SLICEMODE_AVCVendorStartUnused = 0x7F000000, /**< Reserved region for introducing Vendor Extensions */
+    HW_OMX_VIDEO_SLICEMODE_AVCLevelMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_AVCSLICEMODETYPE;
+
+/**
+ * AVC FMO Slice Mode Params
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNumSliceGroups : Specifies the number of slice groups
+ *  nSliceGroupMapType : Specifies the type of slice groups
+ *  eSliceMode : Specifies the type of slice
+ */
+typedef struct HW_OMX_VIDEO_PARAM_AVCSLICEFMO {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U8 nNumSliceGroups;
+    HW_OMX_U8 nSliceGroupMapType;
+    HW_OMX_VIDEO_AVCSLICEMODETYPE eSliceMode;
+} HW_OMX_VIDEO_PARAM_AVCSLICEFMO;
+
+/**
+ * AVC IDR Period Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nIDRPeriod : Specifies periodicity of IDR frames
+ *  nPFrames : Specifies internal of coding Intra frames
+ */
+typedef struct HW_OMX_VIDEO_CONFIG_AVCINTRAPERIOD {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nIDRPeriod;
+    HW_OMX_U32 nPFrames;
+} HW_OMX_VIDEO_CONFIG_AVCINTRAPERIOD;
+
+/**
+ * AVC NAL Size Configs
+ *
+ * STRUCT MEMBERS:
+ *  nSize      : Size of the structure in bytes
+ *  nVersion   : OMX specification version information
+ *  nPortIndex : Port that this structure applies to
+ *  nNaluBytes : Specifies the NAL unit size
+ */
+typedef struct HW_OMX_VIDEO_CONFIG_NALSIZE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nNaluBytes;
+} HW_OMX_VIDEO_CONFIG_NALSIZE;
+
+/** @} */
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
+/* File EOF */
+
Index: ffmpeg/libavcodec/HW_OMX_VideoExt.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/HW_OMX_VideoExt.h
@@ -0,0 +1,476 @@
+/*
+ * Copyright (c) 2010 The Khronos Group Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject
+ * to the following conditions:
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ */
+
+/** HW_OMX_VideoExt.h - OpenMax IL version 1.1.2
+ * The HW_OMX_VideoExt header file contains extensions to the
+ * definitions used by both the application and the component to
+ * access video items.
+ */
+
+#ifndef HW_OMX_VideoExt_h
+#define HW_OMX_VideoExt_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* Each OMX header shall include all required header files to allow the
+ * header to compile without errors.  The includes below are required
+ * for this header file to compile successfully
+ */
+#include "HW_OMX_Core.h"
+
+/** NALU Formats */
+typedef enum HW_OMX_NALUFORMATSTYPE {
+    HW_OMX_NaluFormatStartCodes = 1,
+    HW_OMX_NaluFormatOneNaluPerBuffer = 2,
+    HW_OMX_NaluFormatOneByteInterleaveLength = 4,
+    HW_OMX_NaluFormatTwoByteInterleaveLength = 8,
+    HW_OMX_NaluFormatFourByteInterleaveLength = 16,
+    HW_OMX_NaluFormatCodingMax = 0x7FFFFFFF
+} HW_OMX_NALUFORMATSTYPE;
+
+/** NAL Stream Format */
+typedef struct HW_OMX_NALSTREAMFORMATTYPE{
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_NALUFORMATSTYPE eNaluFormat;
+} HW_OMX_NALSTREAMFORMATTYPE;
+
+/** AVC additional profiles */
+typedef enum HW_OMX_VIDEO_AVCPROFILEEXTTYPE {
+    HW_OMX_VIDEO_AVCProfileConstrainedBaseline = 0x10000,   /**< Constrained baseline profile */
+    HW_OMX_VIDEO_AVCProfileConstrainedHigh     = 0x80000,   /**< Constrained high profile */
+} HW_OMX_VIDEO_AVCPROFILEEXTTYPE;
+
+/** VP8 profiles */
+typedef enum HW_OMX_VIDEO_VP8PROFILETYPE {
+    HW_OMX_VIDEO_VP8ProfileMain = 0x01,
+    HW_OMX_VIDEO_VP8ProfileUnknown = 0x6EFFFFFF,
+    HW_OMX_VIDEO_VP8ProfileMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_VP8PROFILETYPE;
+
+/** VP8 levels */
+typedef enum HW_OMX_VIDEO_VP8LEVELTYPE {
+    HW_OMX_VIDEO_VP8Level_Version0 = 0x01,
+    HW_OMX_VIDEO_VP8Level_Version1 = 0x02,
+    HW_OMX_VIDEO_VP8Level_Version2 = 0x04,
+    HW_OMX_VIDEO_VP8Level_Version3 = 0x08,
+    HW_OMX_VIDEO_VP8LevelUnknown = 0x6EFFFFFF,
+    HW_OMX_VIDEO_VP8LevelMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_VP8LEVELTYPE;
+
+/** VP8 Param */
+typedef struct HW_OMX_VIDEO_PARAM_VP8TYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_VP8PROFILETYPE eProfile;
+    HW_OMX_VIDEO_VP8LEVELTYPE eLevel;
+    HW_OMX_U32 nDCTPartitions;
+    HW_OMX_BOOL bErrorResilientMode;
+} HW_OMX_VIDEO_PARAM_VP8TYPE;
+
+/** Structure for configuring VP8 reference frames */
+typedef struct HW_OMX_VIDEO_VP8REFERENCEFRAMETYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bPreviousFrameRefresh;
+    HW_OMX_BOOL bGoldenFrameRefresh;
+    HW_OMX_BOOL bAlternateFrameRefresh;
+    HW_OMX_BOOL bUsePreviousFrame;
+    HW_OMX_BOOL bUseGoldenFrame;
+    HW_OMX_BOOL bUseAlternateFrame;
+} HW_OMX_VIDEO_VP8REFERENCEFRAMETYPE;
+
+/** Structure for querying VP8 reference frame type */
+typedef struct HW_OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bIsIntraFrame;
+    HW_OMX_BOOL bIsGoldenOrAlternateFrame;
+} HW_OMX_VIDEO_VP8REFERENCEFRAMEINFOTYPE;
+
+/** Maximum number of VP8 temporal layers */
+#define HW_OMX_VIDEO_ANDROID_MAXVP8TEMPORALLAYERS 3
+
+/** VP8 temporal layer patterns */
+typedef enum HW_OMX_VIDEO_ANDROID_VPXTEMPORALLAYERPATTERNTYPE {
+    HW_OMX_VIDEO_VPXTemporalLayerPatternNone = 0,
+    HW_OMX_VIDEO_VPXTemporalLayerPatternWebRTC = 1,
+    HW_OMX_VIDEO_VPXTemporalLayerPatternMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_ANDROID_VPXTEMPORALLAYERPATTERNTYPE;
+
+/**
+ * Android specific VP8/VP9 encoder params
+ *
+ * STRUCT MEMBERS:
+ *  nSize                      : Size of the structure in bytes
+ *  nVersion                   : OMX specification version information
+ *  nPortIndex                 : Port that this structure applies to
+ *  nKeyFrameInterval          : Key frame interval in frames
+ *  eTemporalPattern           : Type of temporal layer pattern
+ *  nTemporalLayerCount        : Number of temporal coding layers
+ *  nTemporalLayerBitrateRatio : Bitrate ratio allocation between temporal
+ *                               streams in percentage
+ *  nMinQuantizer              : Minimum (best quality) quantizer
+ *  nMaxQuantizer              : Maximum (worst quality) quantizer
+ */
+typedef struct HW_OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nKeyFrameInterval;        // distance between consecutive key_frames (including one
+                                      // of the key_frames). 0 means interval is unspecified and
+                                      // can be freely chosen by the codec. 1 means a stream of
+                                      // only key_frames.
+
+    HW_OMX_VIDEO_ANDROID_VPXTEMPORALLAYERPATTERNTYPE eTemporalPattern;
+    HW_OMX_U32 nTemporalLayerCount;
+    HW_OMX_U32 nTemporalLayerBitrateRatio[HW_OMX_VIDEO_ANDROID_MAXVP8TEMPORALLAYERS];
+    HW_OMX_U32 nMinQuantizer;
+    HW_OMX_U32 nMaxQuantizer;
+} HW_OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE;
+
+/** VP9 profiles */
+typedef enum HW_OMX_VIDEO_VP9PROFILETYPE {
+    HW_OMX_VIDEO_VP9Profile0 = 0x1,
+    HW_OMX_VIDEO_VP9Profile1 = 0x2,
+    HW_OMX_VIDEO_VP9Profile2 = 0x4,
+    HW_OMX_VIDEO_VP9Profile3 = 0x8,
+    // HDR profiles also support passing HDR metadata
+    HW_OMX_VIDEO_VP9Profile2HDR = 0x1000,
+    HW_OMX_VIDEO_VP9Profile3HDR = 0x2000,
+    HW_OMX_VIDEO_VP9Profile2HDR10Plus = 0x4000,
+    HW_OMX_VIDEO_VP9Profile3HDR10Plus = 0x8000,
+    HW_OMX_VIDEO_VP9ProfileUnknown = 0x6EFFFFFF,
+    HW_OMX_VIDEO_VP9ProfileMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_VP9PROFILETYPE;
+
+/** VP9 levels */
+typedef enum HW_OMX_VIDEO_VP9LEVELTYPE {
+    HW_OMX_VIDEO_VP9Level1  = 0x1,
+    HW_OMX_VIDEO_VP9Level11 = 0x2,
+    HW_OMX_VIDEO_VP9Level2  = 0x4,
+    HW_OMX_VIDEO_VP9Level21 = 0x8,
+    HW_OMX_VIDEO_VP9Level3  = 0x10,
+    HW_OMX_VIDEO_VP9Level31 = 0x20,
+    HW_OMX_VIDEO_VP9Level4  = 0x40,
+    HW_OMX_VIDEO_VP9Level41 = 0x80,
+    HW_OMX_VIDEO_VP9Level5  = 0x100,
+    HW_OMX_VIDEO_VP9Level51 = 0x200,
+    HW_OMX_VIDEO_VP9Level52 = 0x400,
+    HW_OMX_VIDEO_VP9Level6  = 0x800,
+    HW_OMX_VIDEO_VP9Level61 = 0x1000,
+    HW_OMX_VIDEO_VP9Level62 = 0x2000,
+    HW_OMX_VIDEO_VP9LevelUnknown = 0x6EFFFFFF,
+    HW_OMX_VIDEO_VP9LevelMax = 0x7FFFFFFF
+} HW_OMX_VIDEO_VP9LEVELTYPE;
+
+/**
+* VP9 Parameters.
+*   Encoder specific parameters (decoders should ignore these fields):
+*     - bErrorResilientMode
+*     - nTileRows
+*     - nTileColumns
+*     - bEnableFrameParallelDecoding
+*/
+typedef struct HW_OMX_VIDEO_PARAM_VP9TYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_VP9PROFILETYPE eProfile;
+    HW_OMX_VIDEO_VP9LEVELTYPE eLevel;
+    HW_OMX_BOOL bErrorResilientMode;
+    HW_OMX_U32 nTileRows;
+    HW_OMX_U32 nTileColumns;
+    HW_OMX_BOOL bEnableFrameParallelDecoding;
+} HW_OMX_VIDEO_PARAM_VP9TYPE;
+
+/** HEVC Profile enum type */
+typedef enum HW_OMX_VIDEO_HEVCPROFILETYPE {
+    HW_OMX_VIDEO_HEVCProfileUnknown      = 0x0,
+    HW_OMX_VIDEO_HEVCProfileMain         = 0x1,
+    HW_OMX_VIDEO_HEVCProfileMain10       = 0x2,
+    HW_OMX_VIDEO_HEVCProfileMainStill    = 0x4,
+    // Main10 profile with HDR SEI support.
+    HW_OMX_VIDEO_HEVCProfileMain10HDR10  = 0x1000,
+    HW_OMX_VIDEO_HEVCProfileMain10HDR10Plus  = 0x2000,
+    HW_OMX_VIDEO_HEVCProfileMax          = 0x7FFFFFFF
+} HW_OMX_VIDEO_HEVCPROFILETYPE;
+
+/** HEVC Level enum type */
+typedef enum HW_OMX_VIDEO_HEVCLEVELTYPE {
+    HW_OMX_VIDEO_HEVCLevelUnknown    = 0x0,
+    HW_OMX_VIDEO_HEVCMainTierLevel1  = 0x1,
+    HW_OMX_VIDEO_HEVCHighTierLevel1  = 0x2,
+    HW_OMX_VIDEO_HEVCMainTierLevel2  = 0x4,
+    HW_OMX_VIDEO_HEVCHighTierLevel2  = 0x8,
+    HW_OMX_VIDEO_HEVCMainTierLevel21 = 0x10,
+    HW_OMX_VIDEO_HEVCHighTierLevel21 = 0x20,
+    HW_OMX_VIDEO_HEVCMainTierLevel3  = 0x40,
+    HW_OMX_VIDEO_HEVCHighTierLevel3  = 0x80,
+    HW_OMX_VIDEO_HEVCMainTierLevel31 = 0x100,
+    HW_OMX_VIDEO_HEVCHighTierLevel31 = 0x200,
+    HW_OMX_VIDEO_HEVCMainTierLevel4  = 0x400,
+    HW_OMX_VIDEO_HEVCHighTierLevel4  = 0x800,
+    HW_OMX_VIDEO_HEVCMainTierLevel41 = 0x1000,
+    HW_OMX_VIDEO_HEVCHighTierLevel41 = 0x2000,
+    HW_OMX_VIDEO_HEVCMainTierLevel5  = 0x4000,
+    HW_OMX_VIDEO_HEVCHighTierLevel5  = 0x8000,
+    HW_OMX_VIDEO_HEVCMainTierLevel51 = 0x10000,
+    HW_OMX_VIDEO_HEVCHighTierLevel51 = 0x20000,
+    HW_OMX_VIDEO_HEVCMainTierLevel52 = 0x40000,
+    HW_OMX_VIDEO_HEVCHighTierLevel52 = 0x80000,
+    HW_OMX_VIDEO_HEVCMainTierLevel6  = 0x100000,
+    HW_OMX_VIDEO_HEVCHighTierLevel6  = 0x200000,
+    HW_OMX_VIDEO_HEVCMainTierLevel61 = 0x400000,
+    HW_OMX_VIDEO_HEVCHighTierLevel61 = 0x800000,
+    HW_OMX_VIDEO_HEVCMainTierLevel62 = 0x1000000,
+    HW_OMX_VIDEO_HEVCHighTierLevel62 = 0x2000000,
+    HW_OMX_VIDEO_HEVCHighTiermax     = 0x7FFFFFFF
+} HW_OMX_VIDEO_HEVCLEVELTYPE;
+
+/** Structure for controlling HEVC video encoding */
+typedef struct HW_OMX_VIDEO_PARAM_HEVCTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_HEVCPROFILETYPE eProfile;
+    HW_OMX_VIDEO_HEVCLEVELTYPE eLevel;
+    HW_OMX_U32 nKeyFrameInterval;        // distance between consecutive I-frames (including one
+                                      // of the I frames). 0 means interval is unspecified and
+                                      // can be freely chosen by the codec. 1 means a stream of
+                                      // only I frames.
+} HW_OMX_VIDEO_PARAM_HEVCTYPE;
+
+/** Structure to define if dependent slice segments should be used */
+typedef struct HW_OMX_VIDEO_SLICESEGMENTSTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bDepedentSegments;
+    HW_OMX_BOOL bEnableLoopFilterAcrossSlices;
+} HW_OMX_VIDEO_SLICESEGMENTSTYPE;
+
+/** Structure to return timestamps of rendered output frames as well as EOS
+ *  for tunneled components.
+ */
+typedef struct HW_OMX_VIDEO_RENDEREVENTTYPE {
+    HW_OMX_S64 nMediaTimeUs;  // timestamp of rendered video frame
+    HW_OMX_S64 nSystemTimeNs; // system monotonic time at the time frame was rendered
+                           // Use INT64_MAX for nMediaTimeUs to signal that the EOS
+                           // has been reached. In this case, nSystemTimeNs MUST be
+                           // the system time when the last frame was rendered.
+                           // This MUST be done in addition to returning (and
+                           // following) the render information for the last frame.
+} HW_OMX_VIDEO_RENDEREVENTTYPE;
+
+/** Dolby Vision Profile enum type */
+typedef enum HW_OMX_VIDEO_DOLBYVISIONPROFILETYPE {
+    HW_OMX_VIDEO_DolbyVisionProfileUnknown = 0x0,
+    HW_OMX_VIDEO_DolbyVisionProfileDvavPer = 0x1,
+    HW_OMX_VIDEO_DolbyVisionProfileDvavPen = 0x2,
+    HW_OMX_VIDEO_DolbyVisionProfileDvheDer = 0x4,
+    HW_OMX_VIDEO_DolbyVisionProfileDvheDen = 0x8,
+    HW_OMX_VIDEO_DolbyVisionProfileDvheDtr = 0x10,
+    HW_OMX_VIDEO_DolbyVisionProfileDvheStn = 0x20,
+    HW_OMX_VIDEO_DolbyVisionProfileDvheDth = 0x40,
+    HW_OMX_VIDEO_DolbyVisionProfileDvheDtb = 0x80,
+    HW_OMX_VIDEO_DolbyVisionProfileDvheSt  = 0x100,
+    HW_OMX_VIDEO_DolbyVisionProfileDvavSe  = 0x200,
+    HW_OMX_VIDEO_DolbyVisionProfileMax     = 0x7FFFFFFF
+} HW_OMX_VIDEO_DOLBYVISIONPROFILETYPE;
+
+/** Dolby Vision Level enum type */
+typedef enum HW_OMX_VIDEO_DOLBYVISIONLEVELTYPE {
+    HW_OMX_VIDEO_DolbyVisionLevelUnknown = 0x0,
+    HW_OMX_VIDEO_DolbyVisionLevelHd24    = 0x1,
+    HW_OMX_VIDEO_DolbyVisionLevelHd30    = 0x2,
+    HW_OMX_VIDEO_DolbyVisionLevelFhd24   = 0x4,
+    HW_OMX_VIDEO_DolbyVisionLevelFhd30   = 0x8,
+    HW_OMX_VIDEO_DolbyVisionLevelFhd60   = 0x10,
+    HW_OMX_VIDEO_DolbyVisionLevelUhd24   = 0x20,
+    HW_OMX_VIDEO_DolbyVisionLevelUhd30   = 0x40,
+    HW_OMX_VIDEO_DolbyVisionLevelUhd48   = 0x80,
+    HW_OMX_VIDEO_DolbyVisionLevelUhd60   = 0x100,
+    HW_OMX_VIDEO_DolbyVisionLevelmax     = 0x7FFFFFFF
+} HW_OMX_VIDEO_DOLBYVISIONLEVELTYPE;
+
+/**
+ * Structure for configuring video compression intra refresh period
+ *
+ * STRUCT MEMBERS:
+ *  nSize               : Size of the structure in bytes
+ *  nVersion            : OMX specification version information
+ *  nPortIndex          : Port that this structure applies to
+ *  nRefreshPeriod      : Intra refreh period in frames. Value 0 means disable intra refresh
+ */
+typedef struct HW_OMX_VIDEO_CONFIG_ANDROID_INTRAREFRESHTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_U32 nRefreshPeriod;
+} HW_OMX_VIDEO_CONFIG_ANDROID_INTRAREFRESHTYPE;
+
+/** Maximum number of temporal layers supported by AVC/HEVC */
+#define HW_OMX_VIDEO_ANDROID_MAXTEMPORALLAYERS 8
+
+/** temporal layer patterns */
+typedef enum HW_OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE {
+    HW_OMX_VIDEO_AndroidTemporalLayeringPatternNone = 0,
+    // pattern as defined by WebRTC
+    HW_OMX_VIDEO_AndroidTemporalLayeringPatternWebRTC = 1 << 0,
+    // pattern where frames in any layer other than the base layer only depend on at most the very
+    // last frame from each preceding layer (other than the base layer.)
+    HW_OMX_VIDEO_AndroidTemporalLayeringPatternAndroid = 1 << 1,
+} HW_OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE;
+
+/**
+ * Android specific param for configuration of temporal layering.
+ * Android only supports temporal layering where successive layers each double the
+ * previous layer's framerate.
+ * NOTE: Reading this parameter at run-time SHALL return actual run-time values.
+ *
+ *  nSize                      : Size of the structure in bytes
+ *  nVersion                   : OMX specification version information
+ *  nPortIndex                 : Port that this structure applies to (output port for encoders)
+ *  eSupportedPatterns         : A bitmask of supported layering patterns
+ *  nLayerCountMax             : Max number of temporal coding layers supported
+ *                               by the encoder (must be at least 1, 1 meaning temporal layering
+ *                               is NOT supported)
+ *  nBLayerCountMax            : Max number of layers that can contain B frames
+ *                               (0) to (nLayerCountMax - 1)
+ *  ePattern                   : Layering pattern.
+ *  nPLayerCountActual         : Number of temporal layers to be coded with non-B frames,
+ *                               starting from and including the base-layer.
+ *                               (1 to nLayerCountMax - nBLayerCountActual)
+ *                               If nPLayerCountActual is 1 and nBLayerCountActual is 0, temporal
+ *                               layering is disabled. Otherwise, it is enabled.
+ *  nBLayerCountActual         : Number of temporal layers to be coded with B frames,
+ *                               starting after non-B layers.
+ *                               (0 to nBLayerCountMax)
+ *  bBitrateRatiosSpecified    : Flag to indicate if layer-wise bitrate
+ *                               distribution is specified.
+ *  nBitrateRatios             : Bitrate ratio (100 based) per layer (index 0 is base layer).
+ *                               Honored if bBitrateRatiosSpecified is set.
+ *                               i.e for 4 layers with desired distribution (25% 25% 25% 25%),
+ *                               nBitrateRatio = {25, 50, 75, 100, ... }
+ *                               Values in indices not less than 'the actual number of layers
+ *                               minus 1' MAY be ignored and assumed to be 100.
+ */
+typedef struct HW_OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE eSupportedPatterns;
+    HW_OMX_U32 nLayerCountMax;
+    HW_OMX_U32 nBLayerCountMax;
+    HW_OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE ePattern;
+    HW_OMX_U32 nPLayerCountActual;
+    HW_OMX_U32 nBLayerCountActual;
+    HW_OMX_BOOL bBitrateRatiosSpecified;
+    HW_OMX_U32 nBitrateRatios[HW_OMX_VIDEO_ANDROID_MAXTEMPORALLAYERS];
+} HW_OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE;
+
+/**
+ * Android specific config for changing the temporal-layer count or
+ * bitrate-distribution at run-time.
+ *
+ *  nSize                      : Size of the structure in bytes
+ *  nVersion                   : OMX specification version information
+ *  nPortIndex                 : Port that this structure applies to (output port for encoders)
+ *  ePattern                   : Layering pattern.
+ *  nPLayerCountActual         : Number of temporal layers to be coded with non-B frames.
+ *                               (same HW_OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE limits apply.)
+ *  nBLayerCountActual         : Number of temporal layers to be coded with B frames.
+ *                               (same HW_OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE limits apply.)
+ *  bBitrateRatiosSpecified    : Flag to indicate if layer-wise bitrate
+ *                               distribution is specified.
+ *  nBitrateRatios             : Bitrate ratio (100 based, Q16 values) per layer (0 is base layer).
+ *                               Honored if bBitrateRatiosSpecified is set.
+ *                               (same HW_OMX_VIDEO_PARAM_ANDROID_TEMPORALLAYERINGTYPE limits apply.)
+ */
+typedef struct HW_OMX_VIDEO_CONFIG_ANDROID_TEMPORALLAYERINGTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_VIDEO_ANDROID_TEMPORALLAYERINGPATTERNTYPE ePattern;
+    HW_OMX_U32 nPLayerCountActual;
+    HW_OMX_U32 nBLayerCountActual;
+    HW_OMX_BOOL bBitrateRatiosSpecified;
+    HW_OMX_U32 nBitrateRatios[HW_OMX_VIDEO_ANDROID_MAXTEMPORALLAYERS];
+} HW_OMX_VIDEO_CONFIG_ANDROID_TEMPORALLAYERINGTYPE;
+
+/**
+ * Android specific param for specifying image grid layout information for image encoding
+ * use cases, corresponding to index HW_OMX_IndexParamVideoAndroidImageGrid.
+ *
+ * HW_OMX_VIDEO_CodingImageHEIC encoders must handle this param type. When this param is set
+ * on the component with bEnabled set to true, nTileWidth, nTileHeight, nGridRows,
+ * nGridCols indicates the desired grid config by the client. The component can use this
+ * as a heuristic, and is free to choose any suitable grid configs. The client shall
+ * always get the actual from the component after the param is set. Encoder will receive
+ * each input image in full, and shall encode it into tiles in row-major, top-row first,
+ * left-to-right order, and send each encoded tile in a separate output buffer. All output
+ * buffers for the same input buffer shall carry the same timestamp as the input buffer.
+ * If the input buffer is marked EOS, the EOS should only appear on the last output buffer
+ * for that input buffer.
+ *
+ * HW_OMX_VIDEO_CodingHEVC encoders might also receive this param when it's used for image
+ * encoding, although in this case the param only serves as a hint. The encoder will
+ * receive the input image tiles in row-major, top-row first, left-to-right order.
+ * The grid config can be used for quality control, or optimizations.
+ *
+ * If this param is not set, the component shall assume that grid option is disabled.
+ *
+ *  nSize                      : Size of the structure in bytes
+ *  nVersion                   : OMX specification version information
+ *  nPortIndex                 : Port that this structure applies to (output port for encoders)
+ *  bEnabled                   : Whether grid is enabled. If true, the other parameters
+ *                               specifies the grid config; otherwise they shall be ignored.
+ *  nTileWidth                 : Width of each tile.
+ *  nTileHeight                : Height of each tile.
+ *  nGridRows                  : Number of rows in the grid.
+ *  nGridCols                  : Number of cols in the grid.
+ */
+typedef struct HW_OMX_VIDEO_PARAM_ANDROID_IMAGEGRIDTYPE {
+    HW_OMX_U32 nSize;
+    HW_OMX_VERSIONTYPE nVersion;
+    HW_OMX_U32 nPortIndex;
+    HW_OMX_BOOL bEnabled;
+    HW_OMX_U32 nTileWidth;
+    HW_OMX_U32 nTileHeight;
+    HW_OMX_U32 nGridRows;
+    HW_OMX_U32 nGridCols;
+} HW_OMX_VIDEO_PARAM_ANDROID_IMAGEGRIDTYPE;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* HW_OMX_VideoExt_h */
+/* File EOF */
Index: ffmpeg/libavcodec/Makefile
===================================================================
--- ffmpeg.orig/libavcodec/Makefile
+++ ffmpeg/libavcodec/Makefile
@@ -357,6 +357,7 @@ OBJS-$(CONFIG_NVENC_ENCODER)           +
 OBJS-$(CONFIG_NVENC_H264_ENCODER)      += nvenc_h264.o
 OBJS-$(CONFIG_H264_OMX_ENCODER)        += omx.o
 OBJS-$(CONFIG_H264_FTOMX_DECODER)      += ftomx.o
+OBJS-$(CONFIG_H264_OMX_DECODER)        += omx_dec.o omx_dec_wrapper.o omx_dec_common.o omx_dec_to_annexb.o omx_dec_log.o omx_profile_level.o
 OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec_h2645.o
 OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
 OBJS-$(CONFIG_H264_RKMPP_DECODER)      += rkmppdec.o
@@ -366,6 +367,7 @@ OBJS-$(CONFIG_H264_V4L2M2M_DECODER)    +
 OBJS-$(CONFIG_H264_V4L2M2M_ENCODER)    += v4l2_m2m_enc.o
 OBJS-$(CONFIG_HAP_DECODER)             += hapdec.o hap.o
 OBJS-$(CONFIG_HAP_ENCODER)             += hapenc.o hap.o
+OBJS-$(CONFIG_HEVC_OMX_DECODER)        += omx_dec.o omx_dec_wrapper.o omx_dec_common.o omx_dec_to_annexb.o omx_dec_log.o omx_profile_level.o
 OBJS-$(CONFIG_HEVC_DECODER)            += hevcdec.o hevc_mvs.o \
                                           hevc_cabac.o hevc_refs.o hevcpred.o    \
                                           hevcdsp.o hevc_filter.o hevc_data.o
@@ -454,10 +456,13 @@ OBJS-$(CONFIG_MP3ON4FLOAT_DECODER)     +
 OBJS-$(CONFIG_MPC7_DECODER)            += mpc7.o mpc.o
 OBJS-$(CONFIG_MPC8_DECODER)            += mpc8.o mpc.o
 OBJS-$(CONFIG_MPEGVIDEO_DECODER)       += mpeg12dec.o mpeg12.o mpeg12data.o
+OBJS-$(CONFIG_MPEG1_OMX_DECODER)       += omx_dec.o omx_dec_wrapper.o omx_dec_common.o omx_dec_to_annexb.o omx_dec_log.o omx_profile_level.o
 OBJS-$(CONFIG_MPEG1VIDEO_DECODER)      += mpeg12dec.o mpeg12.o mpeg12data.o
 OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o
 OBJS-$(CONFIG_MPEG1_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG1_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
+OBJS-$(CONFIG_MPEG2_OMX_DECODER)       += omx_dec.o omx_dec_wrapper.o omx_dec_common.o omx_dec_to_annexb.o omx_dec_log.o omx_profile_level.o
+OBJS-$(CONFIG_MPEG4_OMX_DECODER)       += omx_dec.o omx_dec_wrapper.o omx_dec_common.o omx_dec_to_annexb.o omx_dec_log.o omx_profile_level.o
 OBJS-$(CONFIG_MPEG2_MMAL_DECODER)      += mmaldec.o
 OBJS-$(CONFIG_MPEG2_QSV_DECODER)       += qsvdec_other.o
 OBJS-$(CONFIG_MPEG2_QSV_ENCODER)       += qsvenc_mpeg2.o
@@ -681,6 +686,7 @@ OBJS-$(CONFIG_VP8_RKMPP_DECODER)       +
 OBJS-$(CONFIG_VP8_VAAPI_ENCODER)       += vaapi_encode_vp8.o
 OBJS-$(CONFIG_VP8_V4L2M2M_DECODER)     += v4l2_m2m_dec.o
 OBJS-$(CONFIG_VP8_V4L2M2M_ENCODER)     += v4l2_m2m_enc.o
+OBJS-$(CONFIG_VP9_OMX_DECODER)       += omx_dec.o omx_dec_wrapper.o omx_dec_common.o omx_dec_to_annexb.o omx_dec_log.o omx_profile_level.o
 OBJS-$(CONFIG_VP9_DECODER)             += vp9.o vp9data.o vp9dsp.o vp9lpf.o vp9recon.o \
                                           vp9block.o vp9prob.o vp9mvs.o vp56rac.o \
                                           vp9dsp_8bpp.o vp9dsp_10bpp.o vp9dsp_12bpp.o
@@ -1138,6 +1144,12 @@ SKIPHEADERS-$(CONFIG_VAAPI)            +
 SKIPHEADERS-$(CONFIG_VDPAU)            += vdpau.h vdpau_internal.h
 SKIPHEADERS-$(CONFIG_VIDEOTOOLBOX)     += videotoolbox.h vt_internal.h
 SKIPHEADERS-$(CONFIG_V4L2_M2M)         += v4l2_buffers.h v4l2_context.h v4l2_m2m.h
+SKIPHEADERS-$(CONFIG_H264_OMX_DECODER)            += omx_dec_wrapper.h omx_dec_common.h omx_dec_to_annexb.h omx_dec_log.h omx_profile_level.h
+SKIPHEADERS-$(CONFIG_HEVC_OMX_DECODER)            += omx_dec_wrapper.h omx_dec_common.h omx_dec_to_annexb.h omx_dec_log.h omx_profile_level.H
+SKIPHEADERS-$(CONFIG_MPEG2_OMX_DECODER)            += omx_dec_wrapper.h omx_dec_common.h omx_dec_to_annexb.h omx_dec_log.h omx_profile_level.h
+SKIPHEADERS-$(CONFIG_MPEG4_OMX_DECODER)            += omx_dec_wrapper.h omx_dec_common.h omx_dec_to_annexb.h omx_dec_log.h omx_profile_level.h
+SKIPHEADERS-$(CONFIG_MPEG1_OMX_DECODER)            += omx_dec_wrapper.h omx_dec_common.h omx_dec_to_annexb.h omx_dec_log.h omx_profile_level.h
+SKIPHEADERS-$(CONFIG_VP9_OMX_DECODER)            += omx_dec_wrapper.h omx_dec_common.h omx_dec_to_annexb.h omx_dec_log.h omx_profile_level.h
 
 TESTPROGS = avpacket                                                    \
             celp_math                                                   \
Index: ffmpeg/libavcodec/allcodecs.c
===================================================================
--- ffmpeg.orig/libavcodec/allcodecs.c
+++ ffmpeg/libavcodec/allcodecs.c
@@ -139,6 +139,7 @@ extern AVCodec ff_h263p_encoder;
 extern AVCodec ff_h263p_decoder;
 extern AVCodec ff_h263_v4l2m2m_decoder;
 extern AVCodec ff_h264_decoder;
+extern AVCodec ff_h264_omx_decoder;
 extern AVCodec ff_h264_ftomx_decoder;
 extern AVCodec ff_h264_crystalhd_decoder;
 extern AVCodec ff_h264_v4l2m2m_decoder;
@@ -149,6 +150,7 @@ extern AVCodec ff_h264_rkmpp_decoder;
 extern AVCodec ff_hap_encoder;
 extern AVCodec ff_hap_decoder;
 extern AVCodec ff_hevc_decoder;
+extern AVCodec ff_hevc_omx_decoder;
 extern AVCodec ff_hevc_ftomx_decoder;
 extern AVCodec ff_hevc_qsv_decoder;
 extern AVCodec ff_hevc_rkmpp_decoder;
@@ -189,11 +191,14 @@ extern AVCodec ff_mmvideo_decoder;
 extern AVCodec ff_motionpixels_decoder;
 extern AVCodec ff_mpeg1video_encoder;
 extern AVCodec ff_mpeg1video_decoder;
+extern AVCodec ff_mpeg1_omx_decoder;
 extern AVCodec ff_mpeg2video_encoder;
 extern AVCodec ff_mpeg2video_decoder;
+extern AVCodec ff_mpeg2_omx_decoder;
 extern AVCodec ff_mpeg2_ftomx_decoder;
 extern AVCodec ff_mpeg4_encoder;
 extern AVCodec ff_mpeg4_decoder;
+extern AVCodec ff_mpeg4_omx_decoder;
 extern AVCodec ff_mpeg4_ftomx_decoder;
 extern AVCodec ff_mpeg4_crystalhd_decoder;
 extern AVCodec ff_mpeg4_v4l2m2m_decoder;
@@ -349,6 +354,7 @@ extern AVCodec ff_vp8_ftomx_decoder;
 extern AVCodec ff_vp8_rkmpp_decoder;
 extern AVCodec ff_vp8_v4l2m2m_decoder;
 extern AVCodec ff_vp9_decoder;
+extern AVCodec ff_vp9_omx_decoder;
 extern AVCodec ff_vp9_rkmpp_decoder;
 extern AVCodec ff_vp9_v4l2m2m_decoder;
 extern AVCodec ff_vqa_decoder;
Index: ffmpeg/libavcodec/bellagio/OMXComponentRMExt.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/OMXComponentRMExt.h
@@ -0,0 +1,57 @@
+/**
+  src/base/OMXComponentRMExt.h
+
+  This extension of the core provides functions for the resource manager used to retrieve
+	the quality levels of the components available.
+
+  Copyright (C) 2008-2010 STMicroelectronics
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __OMXCOMPONENTRMEXT_H__
+#define __OMXCOMPONENTRMEXT_H__
+
+#include "HW_OMX_Core.h"
+/**
+ * @file
+ * @brief Extended OMXIL component interface for quality-of-service
+ */
+
+/**
+ * @brief Returns the currently installed quality level of a OMXIL component
+ * instance
+ * @param hComponent [IN] Component handle
+ * @param pQualityLevel [OUT] Current quality level
+ * @return HW_OMX_ErrorNone
+ * @remark This function should move to a HW_OMX_GetParameter call with appropriate
+ * structure.
+ */
+HW_OMX_ERRORTYPE getQualityLevel(HW_OMX_HANDLETYPE hComponent, HW_OMX_U32* pQualityLevel);
+/**
+ * @brief Sets the quality level on a OMXIL component instance
+ * @param hComponent [IN] Component handle
+ * @param nQualityLevel [IN] New quality level
+ * @return HW_OMX_ErrorNone
+ * @remark This function should move to a HW_OMX_GetParameter call with appropriate
+ * structure.
+ */
+HW_OMX_ERRORTYPE setQualityLevel(HW_OMX_HANDLETYPE hComponent, HW_OMX_U32 nQualityLevel);
+
+
+#endif
+
Index: ffmpeg/libavcodec/bellagio/OMXCoreRMExt.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/OMXCoreRMExt.h
@@ -0,0 +1,69 @@
+/**
+  src/core_extensions/OMXCoreRMExt.h
+
+  This extension of the core provides functions for the resource manager used to retrieve
+	the quality levels of the components available.
+
+  Copyright (C) 2008-2010 STMicroelectronics
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __OMXCORERMEXT_H__
+#define __OMXCORERMEXT_H__
+
+#include "HW_OMX_Core.h"
+#include "extension_struct.h"
+
+enum HW_OMX_RESOURCETYPE
+{
+	HW_OMX_ResourceTypeMemory,
+	HW_OMX_ResourceTypeCpu
+};
+
+/**
+ * @brief Returns the supported quality levels for a scalable OMXIL component.
+ * @param cComponentName [IN] Component name
+ * @param ppQualityLevel [OUT] List of supported quality levels
+ * @param pNrOfQualityLevels [OUT] Number of quality levels in the list
+ * @return HW_OMX_ErrorNone
+ * @return HW_OMX_ErrorInvalidComponentName
+ * @return HW_OMX_ErrorComponentNotFound
+ * @pre ppQualityLevel != NULL
+ * @pre pNrOfQualityLevels !=NULL
+ */
+HW_OMX_ERRORTYPE getSupportedQualityLevels(HW_OMX_STRING cComponentName, HW_OMX_U32** ppQualityLevel, HW_OMX_U32* pNrOfQualityLevels);
+/**
+ * @brief Returns the multiresource estimates for a given OMXIL component name and
+ * quality level.
+ * @param cComponentName [IN] Component name
+ * @param nQualityLevel [IN] quality level (applicable for scalable components)
+ * @param pMultiResourceEstimates [OUT] The multiresource estimates
+ * @return HW_OMX_ErrorNone
+ * @return HW_OMX_ErrorInvalidComponentName
+ * @return HW_OMX_ErrorComponentNotFound
+ * @verbatim
+ * * The resource estimates for a given quality level are the basis for generating
+ * * the resource budgets. Later on, when components are instantiated and the bit
+ * * stream properties are known, resource budget adaptations might be required,
+ * or * if not feasible, the quality level might need to be downgraded.
+ * @endverbatim
+ */
+HW_OMX_ERRORTYPE getMultiResourceEstimates(HW_OMX_STRING cComponentName, HW_OMX_U32 nQualityLevel, multiResourceDescriptor* pMultiResourceEstimates);
+HW_OMX_ERRORTYPE readRegistryFile();
+#endif
+
Index: ffmpeg/libavcodec/bellagio/common.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/common.h
@@ -0,0 +1,46 @@
+/**
+  src/common.h
+
+  OpenMAX Integration Layer Core. This library implements the OpenMAX core
+  responsible for environment setup, component tunneling and communication.
+
+  Copyright (C) 2007-2011 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+#define MAX_LINE_LENGTH 2048
+
+int makedir(const char *newdir);
+
+char *componentsRegistryGetFilename(void);
+char *componentsRegistryGetFilenameCheck(int check_exists);
+char* loadersRegistryGetFilename(char* registry_name);
+int exists(const char* fname);
+
+typedef struct nameList {
+	char* name;
+	struct nameList *next;
+} nameList;
+
+
+#endif
+
Index: ffmpeg/libavcodec/bellagio/component_loader.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/component_loader.h
@@ -0,0 +1,223 @@
+/**
+  src/component_loader.h
+
+  OpenMAX Component loader APIs. This header file specifies the entry point
+  that a component loader must provide.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __COMPONENT_LOADER_H__
+#define __COMPONENT_LOADER_H__
+
+#include "HW_OMX_Core.h"
+
+/** @brief Component loader entry points
+ *
+ * The component loader generic structure contains the entry points for
+ * each component loader. The list of component loaders is filled using
+ * a special function, called AddComponentLoader.
+ */
+typedef struct BOSA_COMPONENTLOADER
+{
+  /** @brief The constructor of the component loader
+   *
+   * The component loader creator is called by the HW_OMX_Init function. It is
+   * implemented by the specific component loader. It must allocate any
+   * resource needed by the component loader.
+   *
+   * @param loader A private data structure, if needed by the component loader.
+   * This data structure is passed every time a function of this loader is called.
+   * @return HW_OMX_ErrorInsufficientResources if the component loader can not be constructed
+   */
+  HW_OMX_ERRORTYPE (*BOSA_InitComponentLoader)(struct BOSA_COMPONENTLOADER *loader);
+
+  /** @brief The destructor of the component loader
+   *
+   * The component loader destructor is called by the HW_OMX_Deinit function. It is
+   * implemented by the specific component loader. It must free every specific
+   * resource used by the component loader.
+   *
+   * @param loader the specific component loader. This parameter is also specific
+   * to the component loader, and its structure is defined by each loader.
+   * @return HW_OMX_ErrorNone
+   */
+  HW_OMX_ERRORTYPE (*BOSA_DeInitComponentLoader)(struct BOSA_COMPONENTLOADER *loader);
+
+  /** @brief The component constructor of the current component loader
+   *
+   * This function implements the HW_OMX_GetHandle function for the
+   * specific component loader. Its interface is the same as the
+   * standard GetHandle function, except that the first parameter
+   * that contains the private data of the specific component loader.
+   *
+   * @param loader Private data of the component loader
+   * @param pHandle the openmax handle returned by the function, or NULL
+   * in case of failure.
+   * @param cComponentName A string that contains the standard
+   * component's name
+   * @param pAppData private data of the component (if needed)
+   * @param pCallBacks IL client callback function pointers passed
+   * to the component
+   *
+   * @return HW_OMX_ErrorNone if the component is correctly constructed and returned
+   * @return HW_OMX_ErrorComponentNotFound if the component is not found
+   * @return HW_OMX_ErrorInsufficientResources if the component exists but can not be allocated.
+   */
+  HW_OMX_ERRORTYPE (*BOSA_CreateComponent)(
+    struct BOSA_COMPONENTLOADER *loader,
+    HW_OMX_HANDLETYPE* pHandle,
+    HW_OMX_STRING cComponentName,
+    HW_OMX_PTR pAppData,
+    HW_OMX_CALLBACKTYPE* pCallBacks);
+
+  /** @brief The component destructor of the current component loader
+   *
+   * This function implements the HW_OMX_FreeHandle function for the
+   * specific component loader. Its interface is the same as the
+   * standard FreeHandle function, except that the first parameter
+   * that contains the private data of the specific component loader.
+   *
+   * @param loader Private data of the component loader
+   * @param pHandle the openmax handle returned by the function, or NULL
+   * in case of failure.
+   * @param cComponentName A string that contains the standard
+   * component's name
+   * @param pAppData private data of the component (if needed)
+   * @param pCallBacks IL client callback function pointers passed
+   * to the component
+   *
+   * @return HW_OMX_ErrorNone if the component is correctly constructed and returned
+   * @return HW_OMX_ErrorComponentNotFound if the component is not found
+   * @return HW_OMX_ErrorInsufficientResources if the component exists but can not be allocated.
+   */
+  HW_OMX_ERRORTYPE (*BOSA_DestroyComponent)(
+      struct BOSA_COMPONENTLOADER *loader,
+      HW_OMX_HANDLETYPE hComponent);
+
+  /** @brief An enumerator of the components handled by the current component loader.
+   *
+   * This function implements the HW_OMX_ComponentNameEnum function
+   * for the specific component loader
+   *
+   * @param loader Private data of the component loader
+   * @param cComponentName A pointer to a null terminated string
+   * with the component name.  The names of the components are
+   * strings less than 127 bytes in length plus the trailing null
+   * for a maximum size of 128 bytes (HW_OMX_MAX_STRINGNAME_SIZE).
+   * @param nNameLength The number of characters in the
+   * cComponentName string.  With all component name strings
+   * restricted to less than 128 characters (including the trailing null)
+   * it is recommended that the caller provide a input string for the
+   * cComponentName of 128 characters.
+   * @param nIndex A number containing the enumeration index
+   * for the component. Multiple calls to HW_OMX_ComponentNameEnum
+   * with increasing values of nIndex will enumerate through the
+   * component names in the system until HW_OMX_ErrorNoMore is returned.
+   * The value of nIndex is 0 to (N-1), where N is the number of
+   * valid installed components in the system.
+   *
+   * @return HW_OMX_ErrorNone If the command successfully executes
+   * @return HW_OMX_ErrorNoMore If the value of nIndex exceeds the
+   * number of components handled by the component loader minus 1
+   */
+  HW_OMX_ERRORTYPE (*BOSA_ComponentNameEnum)(
+    struct BOSA_COMPONENTLOADER *loader,
+    HW_OMX_STRING cComponentName,
+    HW_OMX_U32 nNameLength,
+    HW_OMX_U32 nIndex);
+
+  /** @brief This function implements the HW_OMX_GetRolesOfComponent standard function for the current component loader
+   *
+   * This function will return the number of roles supported by
+   * the given component and (if the roles field is non-NULL)
+   * the names of those roles. The call will fail if an insufficiently
+   * sized array of names is supplied.
+   * To ensure the array is sufficiently sized the client should:
+   * - first call this function with the roles field NULL to
+   *   determine the number of role names
+   * - second call this function with the roles field pointing to
+   *   an array of names allocated according to the number
+   *   returned by the first call.
+   *
+   * @param loader Private data of the component loader
+   * @param compName The name of the component being queried about.
+   * @param pNumRoles This parameter is used both as input and output.
+   * If roles is NULL, the input is ignored and the output specifies
+   * how many roles the component supports. If compNames is not NULL,
+   * on input it bounds the size of the input structure and on output,
+   * it specifies the number of roles string names listed within
+   * the roles parameter.
+   * @param roles If NULL this field is ignored. If non-NULL this points
+   * to an array of 128-byte strings which accepts a list of the names of
+   * all standard components roles implemented on the specified
+   * component name. numComps indicates the number of names.
+   */
+  HW_OMX_ERRORTYPE (*BOSA_GetRolesOfComponent)(
+    struct BOSA_COMPONENTLOADER *loader,
+    HW_OMX_STRING compName,
+    HW_OMX_U32 *pNumRoles,
+    HW_OMX_U8 **roles);
+
+  /** @brief This function implements the HW_OMX_GetComponentsOfRole
+   * standard function for the current component loader
+   *
+   * This function will return the number of components that support
+   * the given role and (if the compNames field is non-NULL) the names
+   * of those components. The call will fail if an insufficiently
+   * sized array of names is supplied. To ensure the array is
+   * sufficiently sized the client should:
+   * - first call this function with the compNames field NULL to
+   *   determine the number of component names
+   * - second call this function with the compNames field pointing
+   *   to an array of names allocated according to the number
+   *   returned by the first call.
+   *
+   * @param loader Private data of the component loader
+   * @param role This is generic standard component name consisting
+   * only of component class name and the type within that class
+   * (e.g. 'audio_decoder.aac').
+   * @param pNumComps This is used both as input and output. If compNames
+   * is NULL, the input is ignored and the output specifies how many
+   * components support the given role. If compNames is not NULL,
+   * on input it bounds the size of the input structure and on output,
+   * it specifies the number of components string names listed within
+   * the compNames parameter.
+   * @param compNames If NULL this field is ignored. If non-NULL this points
+   * to an array of 128-byte strings which accepts a list of the names of
+   * all physical components that implement the specified standard component
+   * name. Each name is NULL terminated. numComps indicates the number of names.
+   */
+  HW_OMX_ERRORTYPE (*BOSA_GetComponentsOfRole) (
+    struct BOSA_COMPONENTLOADER *loader,
+    HW_OMX_STRING role,
+    HW_OMX_U32 *pNumComps,
+    HW_OMX_U8  **compNames);
+
+  /** @brief The reference to the current component loader private data
+   *
+   * The current loader specified by this structure is described with this
+   * generic pointer that contains the private data of the loader.
+   */
+  void *loaderPrivate;
+
+} BOSA_COMPONENTLOADER;
+
+#endif
Index: ffmpeg/libavcodec/bellagio/extension_struct.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/extension_struct.h
@@ -0,0 +1,46 @@
+/**
+  src/extension_struct.h
+
+  This file will include all the extension structures defined in Bellagio
+  and not present in the OpenMAX spec. These structure will be used
+  with the function getExtensionIndex defined in the standard.
+
+  Copyright (C) 2009 STMicroelectronics
+  Copyright (C) 2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef EXTENSION_STRUCT_H_
+#define EXTENSION_STRUCT_H_
+
+/** This structure is threaded like a parameter with the
+ * extension index HW_OMX_IndexParameterThreadsID
+ */
+typedef struct HW_OMX_PARAM_BELLAGIOTHREADS_ID {
+    HW_OMX_U32 nSize;                 /**< Size of the structure in bytes */
+    HW_OMX_VERSIONTYPE nVersion;      /**< OMX specification version information */
+	long int nThreadBufferMngtID; /**< @param nThreadBufferMngtID the linux thread ID of the buffer management thread*/\
+	long int nThreadMessageID; /**< @param nThreadMessageID the linux thread ID of the message handler thread*/\
+} HW_OMX_PARAM_BELLAGIOTHREADS_ID;
+
+typedef struct multiResourceDescriptor {
+	int CPUResourceRequested;
+	int MemoryResourceRequested;
+} multiResourceDescriptor;
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_base_audio_port.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_audio_port.h
@@ -0,0 +1,84 @@
+/**
+  src/base/omx_base_audio_port.h
+    
+  Base Audio Port class for OpenMAX ports to be used in derived components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#include "omx_classmagic.h"
+#include "omx_base_port.h"
+
+#ifndef __HW_OMX_BASE_AUDIO_PORT_H__
+#define __HW_OMX_BASE_AUDIO_PORT_H__
+
+/**
+ * @brief the base audio domain structure that describes each port. 
+ * 
+ * The data structure is derived from base port class and contain audio 
+ * domain specific parameters.
+ * Other elements can be added in the derived components structures. 
+ */
+
+DERIVEDCLASS(omx_base_audio_PortType, omx_base_PortType)
+#define omx_base_audio_PortType_FIELDS omx_base_PortType_FIELDS \
+  /** @param sAudioParam Domain specific (audio) OpenMAX port parameter */ \
+  HW_OMX_AUDIO_PARAM_PORTFORMATTYPE sAudioParam; 
+ENDCLASS(omx_base_audio_PortType)
+
+/** 
+  * @brief the base contructor for the generic OpenMAX ST Audio port
+  * 
+  * This function is executed by the component that uses a port.
+  * The parameter contains the info about the component.
+  * It takes care of constructing the instance of the port and 
+  * every object needed by the base port.
+  *
+  * @param openmaxStandComp pointer to the Handle of the component
+  * @param openmaxStandPort the ST port to be initialized
+  * @param nPortIndex Index of the port to be constructed
+  * @param isInput specifices if the port is an input or an output
+  * 
+  * @return HW_OMX_ErrorInsufficientResources if a memory allocation fails
+  */
+
+HW_OMX_ERRORTYPE base_audio_port_Constructor(
+  HW_OMX_COMPONENTTYPE *openmaxStandComp,
+  omx_base_PortType **openmaxStandPort,
+  HW_OMX_U32 nPortIndex, 
+  HW_OMX_BOOL isInput);
+
+/** 
+  * @brief the base audio port destructor for the generic OpenMAX ST Audio port
+  * 
+  * This function is executed by the component that uses a port.
+  * The parameter contains the info about the port.
+  * It takes care of destructing the instance of the port
+  * 
+  * @param openmaxStandPort the ST port to be destructed
+  * 
+  * @return HW_OMX_ErrorNone 
+  */
+
+
+HW_OMX_ERRORTYPE base_audio_port_Destructor(
+  omx_base_PortType *openmaxStandPort);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_base_clock_port.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_clock_port.h
@@ -0,0 +1,91 @@
+/**
+  src/base/omx_base_clock_port.h
+    
+  Base Clock Port class for OpenMAX clock ports to be used in derived components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#include "omx_classmagic.h"
+#include "omx_base_port.h"
+
+#ifndef __HW_OMX_BASE_CLOCK_PORT_H__
+#define __HW_OMX_BASE_CLOCK_PORT_H__
+
+/**
+ * @brief the base clock domain structure that describes each port. 
+ * 
+ * The data structure is derived from base port class and contain clock 
+ * domain specific parameters.
+ * Other elements can be added in the derived components structures. 
+ *
+ * @param sOtherParam Domain specific (other) OpenMAX port parameter 
+ */
+
+DERIVEDCLASS(omx_base_clock_PortType, omx_base_PortType)
+#define omx_base_clock_PortType_FIELDS omx_base_PortType_FIELDS \
+  HW_OMX_TIME_CONFIG_TIMESTAMPTYPE        sTimeStamp;  /**< General OpenMAX configuration time stamp parameter */ \
+  HW_OMX_TIME_MEDIATIMETYPE               sMediaTime; \
+  HW_OMX_TIME_CONFIG_MEDIATIMEREQUESTTYPE sMediaTimeRequest; \
+  HW_OMX_OTHER_PARAM_PORTFORMATTYPE       sOtherParam; /**< Domain specific (other) OpenMAX port parameter */
+ENDCLASS(omx_base_clock_PortType)
+
+/** 
+  * @brief the base contructor for the generic openmax ST clock port
+  * 
+  * This function is executed by the component that uses a port.
+  * The parameter contains the info about the component.
+  * It takes care of constructing the instance of the port and 
+  * every object needed by the base port.
+  *
+  * @param openmaxStandComp pointer to the Handle of the component
+  * @param openmaxStandPort the ST port to be initialized
+  * @param nPortIndex Index of the port to be constructed
+  * @param isInput specifices if the port is an input or an output
+  * 
+  * @return HW_OMX_ErrorInsufficientResources if a memory allocation fails
+  */
+
+HW_OMX_ERRORTYPE base_clock_port_Constructor(
+  HW_OMX_COMPONENTTYPE *openmaxStandComp,
+  omx_base_PortType **openmaxStandPort,
+  HW_OMX_U32 nPortIndex, 
+  HW_OMX_BOOL isInput);
+
+/** 
+  * @brief the base clock port destructor for the generic openmax ST clock port
+  * 
+  * This function is executed by the component that uses a port.
+  * The parameter contains the info about the port.
+  * It takes care of destructing the instance of the port
+  * 
+  * @param openmaxStandPort the ST port to be destructed
+  * 
+  * @return HW_OMX_ErrorNone 
+  */
+
+HW_OMX_ERRORTYPE base_clock_port_Destructor(
+  omx_base_PortType *openmaxStandPort);
+
+HW_OMX_ERRORTYPE base_clock_port_SendBufferFunction(
+  omx_base_PortType *openmaxStandPort,
+  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_base_component.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_component.h
@@ -0,0 +1,434 @@
+/**
+  src/base/omx_base_component.h
+
+  OpenMAX base component. This component does not perform any multimedia
+  processing.It is used as a base component for new components development.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+#ifndef _HW_OMX_BASE_COMPONENT_H_
+#define _HW_OMX_BASE_COMPONENT_H_
+
+#include <stdlib.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#if defined(__linux__)
+#include <asm/unistd.h>
+#endif
+
+#ifdef ANDROID_COMPILATION
+#include <oscl_base_macros.h>
+#else
+#define OSCL_IMPORT_REF
+#define OSCL_EXPORT_REF
+#endif
+#include "omxcore.h"
+#include "OMXComponentRMExt.h"
+#include "tsemaphore.h"
+#include "queue.h"
+#include "omx_classmagic.h"
+#include "omx_base_port.h"
+#include "extension_struct.h"
+#include "omx_reference_resource_manager.h"
+
+
+/** Default size of the internal input buffer */
+#define DEFAULT_IN_BUFFER_SIZE  4 * 1024
+/** Default size of the internal output buffer */
+#define DEFAULT_OUT_BUFFER_SIZE 32 * 1024 /*16 * 1024 */ // TODO - check this size is ok
+/** Default MIME string length */
+#define DEFAULT_MIME_STRING_LENGTH 128
+
+#define NUM_DOMAINS 4
+
+#define HW_OMX_BUFFERFLAG_KEY_FRAME 0x11000000
+
+typedef struct HW_OMX_VENDOR_EXTRADATATYPE  {
+  HW_OMX_U32 nPortIndex;
+  HW_OMX_U32 nDataSize;   // Size of the supporting data to follow
+  HW_OMX_U8  *pData;     // Supporting data hint
+} HW_OMX_VENDOR_EXTRADATATYPE;
+
+typedef struct HW_OMX_VENDOR_PROP_TUNNELSETUPTYPE  {
+  HW_OMX_U32 nPortIndex;
+  HW_OMX_TUNNELSETUPTYPE nTunnelSetup;   // Tunnel setup flags
+} HW_OMX_VENDOR_PROP_TUNNELSETUPTYPE;
+
+/** this is the list of custom vendor index */
+typedef enum HW_OMX_INDEXVENDORTYPE {
+	/** only one index for file reader component input file */
+	HW_OMX_IndexVendorInputFilename = HW_OMX_IndexVendorStartUnused+1,
+	HW_OMX_IndexVendorOutputFilename,
+	HW_OMX_IndexVendorCompPropTunnelFlags, /* Will use HW_OMX_TUNNELSETUPTYPE structure*/
+	HW_OMX_IndexParameterThreadsID,
+	HW_OMX_VIDEO_CodingTheora
+} HW_OMX_INDEXVENDORTYPE;
+
+/** This enum defines the transition states of the Component*/
+typedef enum HW_OMX_TRANS_STATETYPE {
+    HW_OMX_TransStateInvalid,
+    HW_OMX_TransStateLoadedToIdle,
+    HW_OMX_TransStateIdleToPause,
+    HW_OMX_TransStatePauseToExecuting,
+    HW_OMX_TransStateIdleToExecuting,
+    HW_OMX_TransStateExecutingToIdle,
+    HW_OMX_TransStateExecutingToPause,
+    HW_OMX_TransStatePauseToIdle,
+    HW_OMX_TransStateIdleToLoaded,
+    HW_OMX_TransStateMax = 0X7FFFFFFF
+} HW_OMX_TRANS_STATETYPE;
+
+/** @brief Enumerates all the possible types of messages
+ * handled internally by the component
+ */
+typedef enum INTERNAL_MESSAGE_TYPE {
+  SENDCOMMAND_MSG_TYPE = 1,/**< this flag specifies that the message send is a command */
+  ERROR_MSG_TYPE,/**< this flag specifies that the message send is an error message */
+  WARNING_MSG_TYPE /**< this flag specifies that the message send is a warning message */
+} INTERNAL_MESSAGE_TYPE;
+
+/** @brief The container of an internal message
+ *
+ * This structure contains a generic OpenMAX request (from send command).
+ * It is processed by the internal message handler thread
+ */
+typedef struct internalRequestMessageType {
+  int messageType; /**< the flag that specifies if the message is a command, a warning or an error */
+  int messageParam; /**< the second field of the message. Its use is the same as specified for the command in OpenMAX spec */
+  HW_OMX_PTR pCmdData; /**< This pointer could contain some proprietary data not covered by the standard */
+} internalRequestMessageType;
+
+/**
+ * @brief the base descriptor for a ST component
+ */
+CLASS(omx_base_component_PrivateType)
+#define omx_base_component_PrivateType_FIELDS \
+	HW_OMX_COMPONENTTYPE *openmaxStandComp; /**< The OpenMAX standard data structure describing a component */ \
+	omx_base_PortType **ports; /** @param ports The ports of the component */ \
+	HW_OMX_PORT_PARAM_TYPE sPortTypesParam[NUM_DOMAINS]; /** @param sPortTypesParam OpenMAX standard parameter that contains a short description of the available ports */ \
+	char uniqueID; /**< ID code that identifies an ST static component*/ \
+	char* name; /**< component name */\
+	HW_OMX_STATETYPE state; /**< The state of the component */ \
+	HW_OMX_TRANS_STATETYPE transientState; /**< The transient state in case of transition between \
+                              Loaded/waitForResources - Idle. It is equal to  \
+                              Invalid if the state or transition are not corect \
+                              Loaded when the transition is from Idle to Loaded \
+                              Idle when the transition is from Loaded to Idle */ \
+	HW_OMX_CALLBACKTYPE* callbacks; /**< pointer to every client callback function, \
+                                as specified by the standard*/ \
+	HW_OMX_PTR callbackData;/**< Private data that can be send with \
+                        the client callbacks. Not specified by the standard */ \
+	queue_t* messageQueue;/**< the queue of all the messages recevied by the component */\
+	tsem_t* messageSem;/**< the semaphore that coordinates the access to the message queue */\
+	HW_OMX_U32 nGroupPriority; /**< @param nGroupPriority Resource management field: component priority (common to a group of components) */\
+	HW_OMX_U32 nGroupID; /**< @param nGroupID ID of a group of components that share the same logical chain */\
+	HW_OMX_PARAM_BELLAGIOTHREADS_ID* bellagioThreads;\
+	HW_OMX_BOOL bIsEOSReached; /** @param bIsEOSReached boolean flag is true when EOS has been reached */ \
+	HW_OMX_MARKTYPE pMark; /**< @param pMark This field holds the private data associated with a mark request, if any */\
+	pthread_mutex_t flush_mutex;  /** @param flush_mutex mutex for the flush condition from buffers */ \
+	tsem_t* flush_all_condition;  /** @param flush_all_condition condition for the flush all buffers */ \
+	tsem_t* flush_condition;  /** @param The flush_condition condition */ \
+	tsem_t* bMgmtSem;/**< @param bMgmtSem the semaphore that control BufferMgmtFunction processing */\
+	tsem_t* bStateSem;/**< @param bMgmtSem the semaphore that control BufferMgmtFunction processing */\
+	pthread_t messageHandlerThread; /** @param  messageHandlerThread This field contains the reference to the thread that receives messages for the components */ \
+	int bufferMgmtThreadID; /** @param  bufferMgmtThreadID The ID of the pthread that process buffers */ \
+	pthread_t bufferMgmtThread; /** @param  bufferMgmtThread This field contains the reference to the thread that process buffers */ \
+	void *loader; /**< pointer to the loader that created this component, used for destruction */ \
+	void* (*BufferMgmtFunction)(void* param); /** @param BufferMgmtFunction This function processes input output buffers */ \
+	HW_OMX_ERRORTYPE (*messageHandler)(HW_OMX_COMPONENTTYPE*,internalRequestMessageType*);/** This function receives messages from the message queue. It is needed for each Linux ST OpenMAX component */ \
+	HW_OMX_ERRORTYPE (*DoStateSet)(HW_OMX_COMPONENTTYPE *openmaxStandComp, HW_OMX_U32); /**< @param DoStateSet internal function called when a generic state transition is requested*/ \
+	HW_OMX_ERRORTYPE (*destructor)(HW_OMX_COMPONENTTYPE *openmaxStandComp); /** Component Destructor*/ \
+	HW_OMX_ERRORTYPE (*getQualityLevel)(HW_OMX_COMPONENTTYPE *openmaxStandComp, HW_OMX_U32* pQualityLevel); /** RM entry point. By default is not implemented */ \
+	HW_OMX_ERRORTYPE (*setQualityLevel)(HW_OMX_COMPONENTTYPE *openmaxStandComp, HW_OMX_U32 nQualityLevel); /** RM entry point. By default is not implemented */ \
+	HW_OMX_U32 nqualitylevels;/**< number of available quality levels */ \
+	multiResourceDescriptor** multiResourceLevel; \
+	int currentQualityLevel; /** if supported the current quality level set for this component */
+ENDCLASS(omx_base_component_PrivateType)
+
+void base_constructor_remove_garbage_collected(omx_base_component_PrivateType* omx_base_component_Private);
+
+/**
+ * @brief The base constructor for the OpenMAX ST components
+ *
+ * This function is executed by the ST static component loader.
+ * It takes care of constructing the instance of the component.
+ * For the base_component component, the following is done:
+ *
+ * 1) Fills the basic OpenMAX structure. The fields can be overwritten
+ *    by derived components.
+ * 2) Allocates (if needed) the omx_base_component_PrivateType private structure
+ *
+ * @param openmaxStandComp the ST component to be initialized
+ * @param cComponentName the OpenMAX string that describes the component
+ *
+ * @return HW_OMX_ErrorInsufficientResources if a memory allocation fails
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_Constructor(HW_OMX_COMPONENTTYPE *openmaxStandComp,HW_OMX_STRING cComponentName);
+
+/** @brief the base destructor for ST OpenMAX components
+ *
+ * This function is called by the standard function ComponentDeInit()
+ * that is called by the IL core during the execution of the  FreeHandle()
+ *
+ * @param openmaxStandComp the ST OpenMAX component to be disposed
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_Destructor(HW_OMX_COMPONENTTYPE *openmaxStandComp);
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_getQualityLevel(HW_OMX_COMPONENTTYPE *openmaxStandComp, HW_OMX_U32* pQualityLevel);
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_setQualityLevel(HW_OMX_COMPONENTTYPE *openmaxStandComp, HW_OMX_U32 nQualityLevel);
+
+/** Changes the state of a component taking proper actions depending on
+ * the transition requested. This base function cover only the state
+ * changes that do not involve any port
+ *
+ * @param openmaxStandComp the OpenMAX component which state is to be changed
+ * @param destinationState the requested target state
+ *
+ * @return HW_OMX_ErrorNotImplemented if the state change is noty handled
+ * in this base class, but needs a specific handling
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_DoStateSet(
+  HW_OMX_COMPONENTTYPE *openmaxStandComp,
+  HW_OMX_U32 destinationState);
+
+/** @brief Checks the header of a structure for consistency
+ * with size and spec version
+ *
+ * @param header Pointer to the structure to be checked
+ * @param size Size of the structure. it is in general obtained
+ * with a sizeof call applied to the structure
+ *
+ * @return OMX error code. If the header has failed the check,
+ * HW_OMX_ErrorVersionMismatch is returned.
+ * If the header fails the size check HW_OMX_ErrorBadParameter is returned
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE checkHeader(HW_OMX_PTR header, HW_OMX_U32 size);
+
+/** @brief Simply fills the first two fields in any OMX structure
+ * with the size and the version
+ *
+ * @param header pointer to the structure to be filled
+ * @param size size of the structure. It can be obtained with
+ * a call to sizeof of the structure type
+ */
+void setHeader(HW_OMX_PTR header, HW_OMX_U32 size);
+
+/** @brief standard openmax function
+ *
+ * it returns the version of the component. See HW_OMX_Core.h
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_GetComponentVersion(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_STRING pComponentName,
+  HW_OMX_VERSIONTYPE* pComponentVersion,
+  HW_OMX_VERSIONTYPE* pSpecVersion,
+  HW_OMX_UUIDTYPE* pComponentUUID);
+
+/** @brief Enumerates all the role of the component.
+ *
+ * This function is intended to be used only by a core. The ST static core
+ * in any case does not use this function, because it can not be used before the
+ * creation of the component, but uses a static list.
+ * It is implemented only for API completion, and it will be not overriden
+ * by a derived component.
+ *
+ * @param hComponent handle of the component
+ * @param cRole the output string containing the n-role of the component
+ * @param nIndex the index of the role requested
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_ComponentRoleEnum(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_U8 *cRole,
+  HW_OMX_U32 nIndex);
+
+/** @brief standard OpenMAX function
+ *
+ * it sets the callback functions given by the IL client.
+ * See HW_OMX_Component.h
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_SetCallbacks(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_CALLBACKTYPE* pCallbacks,
+  HW_OMX_PTR pAppData);
+
+/** @brief Part of the standard OpenMAX function
+ *
+ * This function return the parameters not related to any port.
+ * These parameters are handled in the derived components
+ * See HW_OMX_Core.h for standard reference.
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_GetParameter(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_INDEXTYPE nParamIndex,
+  HW_OMX_PTR ComponentParameterStructure);
+
+/** @brief part of the standard openmax function
+ *
+ * This function return the parameters not related to any port,
+ * These parameters are handled in the derived components
+ * See HW_OMX_Core.h for standard reference.
+ *
+ * @return HW_OMX_ErrorUnsupportedIndex if the index is not supported or not handled here
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_SetParameter(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_INDEXTYPE nParamIndex,
+  HW_OMX_PTR ComponentParameterStructure);
+
+/** @brief base GetConfig function
+ *
+ * This base function is not implemented. If a derived component
+ * needs to support any config, it must implement a derived
+ * version of this function and assign it to the correct pointer
+ * in the private component descriptor.
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_GetConfig(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_INDEXTYPE nIndex,
+  HW_OMX_PTR pComponentConfigStructure);
+
+/** @brief base SetConfig function
+ *
+ * This base function is not implemented. If a derived component
+ * needs to support any config, it must implement a derived
+ * version of this function and assign it to the correct pointer
+ * in the private component descriptor.
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_SetConfig(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_INDEXTYPE nIndex,
+  HW_OMX_PTR pComponentConfigStructure);
+
+/** @brief base function not implemented
+ *
+ * This function can be eventually implemented by a
+ * derived component if needed.
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_GetExtensionIndex(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_STRING cParameterName,
+  HW_OMX_INDEXTYPE* pIndexType);
+
+/** @returns the state of the component
+ *
+ * This function does not need any override by derived components.
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_GetState(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_STATETYPE* pState);
+
+/** @brief standard SendCommand function
+ *
+ * In general this function does not need a overwrite, but
+ * a special derived component could do it.
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_SendCommand(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_COMMANDTYPE Cmd,
+  HW_OMX_U32 nParam,
+  HW_OMX_PTR pCmdData);
+
+/** @brief This standard functionality is called when the component is
+ * destroyed in the FreeHandle standard call.
+ *
+ * In this way the implementation of the FreeHandle is standard,
+ * and it does not need a support by a specific component loader.
+ * The implementation of the ComponentDeInit contains the
+ * implementation specific part of the destroying phase.
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_ComponentDeInit(
+  HW_OMX_HANDLETYPE hComponent);
+
+/** @brief Component's message handler thread function
+ *
+ * Handles all messages coming from components and
+ * processes them by dispatching them back to the
+ * triggering component.
+ */
+void* compMessageHandlerFunction(void*);
+
+/** This is called by the component message entry point.
+ * In the base version this function is named compMessageHandlerFunction
+ *
+ * A request is made by the component when some asynchronous services are needed:
+ * 1) A SendCommand() is to be processed
+ * 2) An error needs to be notified
+ * 3) ...
+ *
+ * @param openmaxStandComp the component itself
+ * @param message the message that has been passed to core
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_MessageHandler(HW_OMX_COMPONENTTYPE *openmaxStandComp,internalRequestMessageType* message);
+
+/**
+ * This function verify Component State and Structure header
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_ParameterSanityCheck(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_U32 nPortIndex,
+  HW_OMX_PTR pStructure,
+  size_t size);
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_AllocateBuffer(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_BUFFERHEADERTYPE** ppBuffer,
+  HW_OMX_U32 nPortIndex,
+  HW_OMX_PTR pAppPrivate,
+  HW_OMX_U32 nSizeBytes);
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_UseBuffer(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_BUFFERHEADERTYPE** ppBufferHdr,
+  HW_OMX_U32 nPortIndex,
+  HW_OMX_PTR pAppPrivate,
+  HW_OMX_U32 nSizeBytes,
+  HW_OMX_U8* pBuffer);
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_UseEGLImage (
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_BUFFERHEADERTYPE** ppBufferHdr,
+  HW_OMX_U32 nPortIndex,
+  HW_OMX_PTR pAppPrivate,
+  void* eglImage);
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_FreeBuffer(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_U32 nPortIndex,
+  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_EmptyThisBuffer(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_FillThisBuffer(
+  HW_OMX_HANDLETYPE hComponent,
+  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_component_ComponentTunnelRequest(
+  HW_OMX_HANDLETYPE hComp,
+  HW_OMX_U32 nPort,
+  HW_OMX_HANDLETYPE hTunneledComp,
+  HW_OMX_U32 nTunneledPort,
+  HW_OMX_TUNNELSETUPTYPE* pTunnelSetup);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_base_filter.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_filter.h
@@ -0,0 +1,82 @@
+/**
+  src/base/omx_base_filter.h
+
+  OpenMAX Base Filter component. This component does not perform any multimedia
+  processing. It derives from base component and contains two ports. It can be used
+  as base class for codec and filter components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+
+#ifndef __HW_OMX_BASE_FILTER_H__
+#define __HW_OMX_BASE_FILTER_H__
+
+#include "HW_OMX_Types.h"
+#include "HW_OMX_Component.h"
+#include "HW_OMX_Core.h"
+#include "omx_base_component.h"
+
+/** HW_OMX_BASE_FILTER_INPUTPORT_INDEX is the index of any input port for the derived components
+ */
+#define HW_OMX_BASE_FILTER_INPUTPORT_INDEX 0
+
+/** HW_OMX_BASE_FILTER_OUTPUTPORT_INDEX is the index of any output port for the derived components
+ */
+#define HW_OMX_BASE_FILTER_OUTPUTPORT_INDEX 1
+
+/** HW_OMX_BASE_FILTER_ALLPORT_INDEX as the standard specifies, the -1 value for port index is used to point to all the ports
+ */
+#define HW_OMX_BASE_FILTER_ALLPORT_INDEX -1
+
+/** Base Filter component private structure.
+ */
+DERIVEDCLASS(omx_base_filter_PrivateType, omx_base_component_PrivateType)
+#define omx_base_filter_PrivateType_FIELDS omx_base_component_PrivateType_FIELDS \
+  /** @param pPendingOutputBuffer pending Output Buffer pointer */ \
+  HW_OMX_BUFFERHEADERTYPE* pPendingOutputBuffer; \
+  /** @param BufferMgmtCallback function pointer for algorithm callback */ \
+  void (*BufferMgmtCallback)(HW_OMX_COMPONENTTYPE* openmaxStandComp, HW_OMX_BUFFERHEADERTYPE* inputbuffer, HW_OMX_BUFFERHEADERTYPE* outputbuffer);
+ENDCLASS(omx_base_filter_PrivateType)
+
+/**
+ * @brief The base filter contructor for the OpenMAX ST components
+ *
+ * @param openmaxStandComp the ST component to be initialized
+ * @param cComponentName the OpenMAX string that describes the component
+ *
+ * @return HW_OMX_ErrorInsufficientResources if a memory allocation fails
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_filter_Constructor(HW_OMX_COMPONENTTYPE *openmaxStandComp,HW_OMX_STRING cComponentName);
+
+/** @brief the base filter destructor for ST OpenMAX components
+ *
+ * @param openmaxStandComp the ST OpenMAX component to be disposed
+ */
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE omx_base_filter_Destructor(HW_OMX_COMPONENTTYPE *openmaxStandComp);
+
+/** This is the central function for component processing. It
+ * is executed in a separate thread, is synchronized with
+ * semaphores at each port, those are released each time a new buffer
+ * is available on the given port.
+ */
+void* omx_base_filter_BufferMgmtFunction(void* param);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_base_image_port.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_image_port.h
@@ -0,0 +1,84 @@
+/**
+  src/base/omx_base_image_port.h
+    
+  Base Image Port class for OpenMAX ports to be used in derived components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#include "omx_classmagic.h"
+#include "omx_base_port.h"
+
+#ifndef __HW_OMX_BASE_IMAGE_PORT_H__
+#define __HW_OMX_BASE_IMAGE_PORT_H__
+
+/**
+ * @brief the base image domain structure that describes each port. 
+ * 
+ * The data structure is derived from base port class and contain image 
+ * domain specific parameters.
+ * Other elements can be added in the derived components structures. 
+ */
+
+DERIVEDCLASS(omx_base_image_PortType, omx_base_PortType)
+#define omx_base_image_PortType_FIELDS omx_base_PortType_FIELDS \
+  /** @param sImageParam Domain specific (image) OpenMAX port parameter */ \
+  HW_OMX_IMAGE_PARAM_PORTFORMATTYPE sImageParam; 
+ENDCLASS(omx_base_image_PortType)
+
+/** 
+  * @brief the base contructor for the generic OpenMAX ST Image port
+  * 
+  * This function is executed by the component that uses a port.
+  * The parameter contains the info about the component.
+  * It takes care of constructing the instance of the port and 
+  * every object needed by the base port.
+  *
+  * @param openmaxStandComp pointer to the Handle of the component
+  * @param openmaxStandPort the ST port to be initialized
+  * @param nPortIndex Index of the port to be constructed
+  * @param isInput specifices if the port is an input or an output
+  * 
+  * @return HW_OMX_ErrorInsufficientResources if a memory allocation fails
+  */
+
+HW_OMX_ERRORTYPE base_image_port_Constructor(
+  HW_OMX_COMPONENTTYPE *openmaxStandComp,
+  omx_base_PortType **openmaxStandPort,
+  HW_OMX_U32 nPortIndex, 
+  HW_OMX_BOOL isInput);
+
+/** 
+  * @brief the base image port destructor for the generic OpenMAX ST Image port
+  * 
+  * This function is executed by the component that uses a port.
+  * The parameter contains the info about the port.
+  * It takes care of destructing the instance of the port
+  * 
+  * @param openmaxStandPort the ST port to be destructed
+  * 
+  * @return HW_OMX_ErrorNone 
+  */
+
+
+HW_OMX_ERRORTYPE base_image_port_Destructor(
+  omx_base_PortType *openmaxStandPort);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_base_port.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_port.h
@@ -0,0 +1,275 @@
+/**
+  src/base/omx_base_port.h
+
+  Base class for OpenMAX ports to be used in derived components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#include "tsemaphore.h"
+#include "queue.h"
+#include "omx_classmagic.h"
+
+#ifndef __HW_OMX_BASE_PORT_H__
+#define __HW_OMX_BASE_PORT_H__
+
+#define TUNNEL_USE_BUFFER_RETRY 20
+#define TUNNEL_USE_BUFFER_RETRY_USLEEP_TIME 50000
+
+/**
+ * Port Specific Macro's
+ */
+#define PORT_IS_BEING_FLUSHED(pPort)                             (pPort->bIsPortFlushed == HW_OMX_TRUE)
+#define PORT_IS_BEING_DISABLED(pPort)                            (pPort->bIsTransientToDisabled == HW_OMX_TRUE)
+#define PORT_IS_ENABLED(pPort)                                   (pPort->sPortParam.bEnabled == HW_OMX_TRUE)
+#define PORT_IS_POPULATED(pPort)                                 (pPort->sPortParam.bPopulated == HW_OMX_TRUE)
+#define PORT_IS_TUNNELED(pPort)                                  (pPort->nTunnelFlags & TUNNEL_ESTABLISHED)
+#define PORT_IS_DEEP_TUNNELED(pPort)                             (pPort->nTunnelFlags & PROPRIETARY_COMMUNICATION_ESTABLISHED)
+#define PORT_IS_BUFFER_SUPPLIER(pPort)                           (pPort->nTunnelFlags & TUNNEL_IS_SUPPLIER)
+#define PORT_IS_TUNNELED_N_BUFFER_SUPPLIER(pPort)                ((pPort->nTunnelFlags & TUNNEL_ESTABLISHED) && (pPort->nTunnelFlags & TUNNEL_IS_SUPPLIER))
+
+/** The following enum values are used to characterize each buffer
+  * allocated or assigned to the component. A buffer list is
+  * created for each port of the component. The buffer can be assigned
+  * to the port, or owned by the port. The buffer flag are applied for each buffer
+  * in each port buffer list. The following use cases are currently implemented:
+  * - When the IL Client asks the component to allocate a buffer
+  *   for a given port, with the call to AllocateBuffer, the
+  *   buffer created is characterizeed by the flag BUFFER_ALLOCATED
+  * - When the IL Client asks the component to use a buffer allocated
+  *   by the client itself, the buffer flag is BUFFER_ASSIGNED
+  * - When the component is tunneled by another component, and the first
+  *   is supplier of the buffer, the buffer is marked with the
+  *   BUFFER_ALLOCATED flag.
+  * - When the component is tunneled by another component, and the second
+  *   is supplier of the buffer, the buffer is marked with the
+  *   BUFFER_ASSIGNED flag.
+  * - The case of a buffer supplied by the first component but allocated by another
+  *   component or another port inside the same component, as in the case
+  *   of shared buffers, is not yet implemented in these components
+  * - During hte deallocation phase each buffer is marked with the BUFFER_FREE
+  *   flag, so that the component can check if all the buffers have been deallocated
+  *   before switch the component state to Loaded, as specified by
+  *   the OpenMAX specs
+  */
+typedef enum BUFFER_STATUS_FLAG {
+  BUFFER_FREE = 0,
+  BUFFER_ALLOCATED = 0x0001,  /**< This flag is applied to a buffer when it is allocated
+                 by the given port of the component */
+  BUFFER_ASSIGNED = 0x0002, /**< This flag is applied to a buffer when it is assigned
+                from another port or by the IL client */
+  HEADER_ALLOCATED = 0x0004 /**< This flag is applied to a buffer when buffer header is allocated
+                by the given port of the component */
+  } BUFFER_STATUS_FLAG;
+
+/** @brief the status of a port related to the tunneling with another component
+ */
+typedef enum TUNNEL_STATUS_FLAG {
+  NO_TUNNEL = 0, /**< No tunnel established */
+  TUNNEL_ESTABLISHED = 0x0001, /**< the TUNNEL_ESTABLISHED specifies if a port is tunneled.
+                              * It is assigned to a private field of the port if it is tunneled
+                              */
+  TUNNEL_IS_SUPPLIER = 0x0002, /**< the TUNNEL_IS_SUPPLIER specifies if a tunneled port is the supplier.
+                              * It is assigned to a private field of the port if it is tunneled and also it is the buffer supplier for the tunnel.
+                              */
+  PROPRIETARY_COMMUNICATION_ESTABLISHED = 0x0004 /** The tunnel established is created between two components of the same
+                                                  * vendor. These components can take advantage from a vendor specific
+                                                  * communication
+                                                  */
+} TUNNEL_STATUS_FLAG;
+
+
+/**
+ * @brief the base structure that describes each port.
+ *
+ * The data structure that describes a port contains the basic elements used in the
+ * base component. Other elements can be added in the derived components structures.
+ */
+CLASS(omx_base_PortType)
+#define omx_base_PortType_FIELDS \
+  HW_OMX_HANDLETYPE hTunneledComponent; /**< @param hTunneledComponent Handle to the tunnelled component */\
+  HW_OMX_U32 nTunnelFlags; /**< This field contains one or more tags that describe the tunnel status of the port */\
+  HW_OMX_U32 nTunneledPort; /**< @param nTunneledPort Tunneled port number */ \
+  HW_OMX_BUFFERSUPPLIERTYPE eBufferSupplier; /**< @param eBufferSupplier the type of supplier in case of tunneling */\
+  HW_OMX_U32 nNumTunnelBuffer; /**< @param nNumTunnelBuffer Number of buffer to be tunnelled */\
+  tsem_t* pAllocSem; /**< @param pFlushSem Semaphore that locks the execution until the buffers have been flushed, if needed */ \
+  pthread_mutex_t exitMutex; /** This mutex synchronizes the access to the boolean variable bIsDestroying */ \
+  HW_OMX_BOOL bIsDestroying; /** This variable is set to true when the port has been selected for destruction */ \
+  HW_OMX_U32 nNumBufferFlushed; /**< @param nNumBufferFlushed Number of buffer Flushed */\
+  HW_OMX_BOOL bIsPortFlushed;/**< @param bIsPortFlushed Boolean variables indicate port is being flushed at the moment */ \
+  queue_t* pBufferQueue; /**< @param pBufferQueue queue for buffer to be processed by the port */\
+  tsem_t* pBufferSem; /**< @param pBufferSem Semaphore for buffer queue access synchronization */\
+  HW_OMX_U32 nNumAssignedBuffers; /**< @param nNumAssignedBuffers Number of buffer assigned on each port */\
+  HW_OMX_PARAM_PORTDEFINITIONTYPE sPortParam; /**< @param sPortParam General OpenMAX port parameter */\
+  HW_OMX_BUFFERHEADERTYPE **pInternalBufferStorage; /**< This array contains the reference to all the buffers hadled by this port and already registered*/\
+  BUFFER_STATUS_FLAG *bBufferStateAllocated; /**< @param bBufferStateAllocated The State of the Buffer whether assigned or allocated */\
+  HW_OMX_COMPONENTTYPE *standCompContainer;/**< The OpenMAX component reference that contains this port */\
+  HW_OMX_BOOL bIsTransientToEnabled;/**< It indicates that the port is going from disabled to enabled */ \
+  HW_OMX_BOOL bIsTransientToDisabled;/**< It indicates that the port is going from enabled to disabled */ \
+  HW_OMX_BOOL bIsFullOfBuffers; /**< It indicates if the port has all the buffers needed */ \
+  HW_OMX_BOOL bIsEmptyOfBuffers;/**< It indicates if the port has no buffers*/ \
+  HW_OMX_ERRORTYPE (*PortConstructor)(HW_OMX_COMPONENTTYPE *openmaxStandComp,omx_base_PortType **openmaxStandPort,HW_OMX_U32 nPortIndex, HW_OMX_BOOL isInput); /**< The contructor of the port. It fills all the other function pointers */ \
+  HW_OMX_ERRORTYPE (*PortDestructor)(omx_base_PortType *openmaxStandPort); /**< The destructor of the port*/ \
+  HW_OMX_ERRORTYPE (*Port_DisablePort)(omx_base_PortType *openmaxStandPort); /**< Disables the port */ \
+  HW_OMX_ERRORTYPE (*Port_EnablePort)(omx_base_PortType *openmaxStandPort); /**< Enables the port */ \
+  HW_OMX_ERRORTYPE (*Port_SendBufferFunction)(omx_base_PortType *openmaxStandPort, HW_OMX_BUFFERHEADERTYPE* pBuffer);  /**< Holds the EmptyThisBuffer of FillThisBuffer function, if the port is input or output */ \
+  HW_OMX_ERRORTYPE (*Port_AllocateBuffer)(omx_base_PortType *openmaxStandPort, HW_OMX_BUFFERHEADERTYPE** pBuffer, HW_OMX_U32 nPortIndex, HW_OMX_PTR pAppPrivate, HW_OMX_U32 nSizeBytes);/**< Replaces the AllocateBuffer call for the base port. */   \
+  HW_OMX_ERRORTYPE (*Port_UseBuffer)(omx_base_PortType *openmaxStandPort,HW_OMX_BUFFERHEADERTYPE** ppBufferHdr,HW_OMX_U32 nPortIndex,HW_OMX_PTR pAppPrivate,HW_OMX_U32 nSizeBytes,HW_OMX_U8* pBuffer);/**< The standard use buffer function applied to the port class */ \
+  HW_OMX_ERRORTYPE (*Port_FreeBuffer)(omx_base_PortType *openmaxStandPort,HW_OMX_U32 nPortIndex,HW_OMX_BUFFERHEADERTYPE* pBuffer); /**< The standard free buffer function applied to the port class */ \
+  HW_OMX_ERRORTYPE (*Port_AllocateTunnelBuffer)(omx_base_PortType *openmaxStandPort,HW_OMX_U32 nPortIndex);/**< AllocateTunnelBuffer call for the base port. */   \
+  HW_OMX_ERRORTYPE (*Port_FreeTunnelBuffer)(omx_base_PortType *openmaxStandPort,HW_OMX_U32 nPortIndex); /**< The free buffer function used to free tunnelled buffers */ \
+  HW_OMX_ERRORTYPE (*BufferProcessedCallback)(HW_OMX_HANDLETYPE hComponent, HW_OMX_PTR pAppData, HW_OMX_BUFFERHEADERTYPE* pBuffer);/**< Holds the EmptyBufferDone or FillBufferDone callback, if the port is input or output port */ \
+  HW_OMX_ERRORTYPE (*FlushProcessingBuffers)(omx_base_PortType *openmaxStandPort); /**< release all the buffers currently under processing */ \
+  HW_OMX_ERRORTYPE (*ReturnBufferFunction)(omx_base_PortType* openmaxStandPort,HW_OMX_BUFFERHEADERTYPE* pBuffer); /**< Call appropriate function to return buffers to peer or IL Client*/ \
+  HW_OMX_ERRORTYPE (*ComponentTunnelRequest)(omx_base_PortType* openmaxStandPort, HW_OMX_HANDLETYPE hTunneledComp, HW_OMX_U32 nTunneledPort, HW_OMX_TUNNELSETUPTYPE* pTunnelSetup); /**< Setup tunnel with the port */
+ENDCLASS(omx_base_PortType)
+
+/**
+ * @brief The base contructor for the generic OpenMAX ST port
+ *
+ * This function is executed by the component that uses a port.
+ * The parameter contains the info about the component.
+ * It takes care of constructing the instance of the port and
+ * every object needed by the base port.
+ *
+ * @param openmaxStandPort the ST port to be initialized
+ *
+ * @return HW_OMX_ErrorInsufficientResources if a memory allocation fails
+ */
+HW_OMX_ERRORTYPE base_port_Constructor(HW_OMX_COMPONENTTYPE *openmaxStandComp,omx_base_PortType **openmaxStandPort,HW_OMX_U32 nPortIndex, HW_OMX_BOOL isInput);
+
+/** @brief The base destructor for the generic OpenMAX ST port
+ *
+ * This function is executed by the component that uses a port.
+ * The parameter contains the info about the component.
+ * It takes care of destructing the instance of the port and
+ * every object used by the base port.
+ *
+ * @param openmaxStandPort the ST port to be disposed
+  */
+HW_OMX_ERRORTYPE base_port_Destructor(omx_base_PortType *openmaxStandPort);
+
+/** @brief Disables the port.
+ *
+ * This function is called due to a request by the IL client
+ *
+ * @param openmaxStandPort the reference to the port
+ *
+ */
+HW_OMX_ERRORTYPE base_port_DisablePort(omx_base_PortType *openmaxStandPort);
+
+/** @brief Enables the port.
+ *
+ * This function is called due to a request by the IL client
+ *
+ * @param openmaxStandPort the reference to the port
+ *
+ */
+HW_OMX_ERRORTYPE base_port_EnablePort(omx_base_PortType *openmaxStandPort);
+
+/** @brief The entry point for sending buffers to the port
+ *
+ * This function can be called by the EmptyThisBuffer or FillThisBuffer. It depends on
+ * the nature of the port, that can be an input or output port.
+ */
+HW_OMX_ERRORTYPE base_port_SendBufferFunction(
+  omx_base_PortType *openmaxStandPort,
+  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+/** @brief Called by the standard allocate buffer, it implements a base functionality.
+ *
+ * This function can be overriden if the allocation of the buffer is not a simply malloc call.
+ * The parameters are the same as the standard function, except for the handle of the port
+ * instead of the handler of the component
+ * When the buffers needed by this port are all assigned or allocated, the variable
+ * bIsFullOfBuffers becomes equal to HW_OMX_TRUE
+ */
+HW_OMX_ERRORTYPE base_port_AllocateBuffer(
+  omx_base_PortType *openmaxStandPort,
+  HW_OMX_BUFFERHEADERTYPE** pBuffer,
+  HW_OMX_U32 nPortIndex,
+  HW_OMX_PTR pAppPrivate,
+  HW_OMX_U32 nSizeBytes);
+
+/** @brief Called by the standard use buffer, it implements a base functionality.
+ *
+ * This function can be overriden if the use buffer implicate more complicated operations.
+ * The parameters are the same as the standard function, except for the handle of the port
+ * instead of the handler of the component
+ * When the buffers needed by this port are all assigned or allocated, the variable
+ * bIsFullOfBuffers becomes equal to HW_OMX_TRUE
+ */
+HW_OMX_ERRORTYPE base_port_UseBuffer(
+  omx_base_PortType *openmaxStandPort,
+  HW_OMX_BUFFERHEADERTYPE** ppBufferHdr,
+  HW_OMX_U32 nPortIndex,
+  HW_OMX_PTR pAppPrivate,
+  HW_OMX_U32 nSizeBytes,
+  HW_OMX_U8* pBuffer);
+
+/** @brief Called by the standard function.
+ *
+ * It frees the buffer header and in case also the buffer itself, if needed.
+ * When all the bufers are done, the variable bIsEmptyOfBuffers is set to HW_OMX_TRUE
+ */
+HW_OMX_ERRORTYPE base_port_FreeBuffer(
+  omx_base_PortType *openmaxStandPort,
+  HW_OMX_U32 nPortIndex,
+  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+/** @brief Releases buffers under processing.
+ *
+ * This function must be implemented in the derived classes, for the
+ * specific processing
+ */
+HW_OMX_ERRORTYPE base_port_FlushProcessingBuffers(omx_base_PortType *openmaxStandPort);
+
+/** @brief Returns buffers when processed.
+ *
+ * Call appropriate function to return buffers to peer or IL Client
+ */
+
+HW_OMX_ERRORTYPE base_port_ReturnBufferFunction(
+  omx_base_PortType* openmaxStandPort,
+  HW_OMX_BUFFERHEADERTYPE* pBuffer);
+
+/** @brief Setup Tunnel with the port
+ */
+
+HW_OMX_ERRORTYPE base_port_ComponentTunnelRequest(
+  omx_base_PortType* openmaxStandPort,
+  HW_OMX_HANDLETYPE hTunneledComp,
+  HW_OMX_U32 nTunneledPort,
+  HW_OMX_TUNNELSETUPTYPE* pTunnelSetup);
+
+/** @brief Allocate Buffers for tunneling use
+ */
+HW_OMX_ERRORTYPE base_port_AllocateTunnelBuffer(
+  omx_base_PortType *openmaxStandPort,
+  HW_OMX_U32 nPortIndex);
+
+/** @brief Free buffers used in tunnel
+ */
+HW_OMX_ERRORTYPE base_port_FreeTunnelBuffer(
+  omx_base_PortType *openmaxStandPort,
+  HW_OMX_U32 nPortIndex);
+
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_base_sink.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_sink.h
@@ -0,0 +1,69 @@
+/**
+  src/base/omx_base_sink.h
+
+  OpenMAX base sink component. This component does not perform any multimedia
+  processing. It derives from base component and contains a single port. It can be used
+  as base class for sink components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef _HW_OMX_BASE_SINK_COMPONENT_H_
+#define _HW_OMX_BASE_SINK_COMPONENT_H_
+
+#include "HW_OMX_Types.h"
+#include "HW_OMX_Component.h"
+#include "HW_OMX_Core.h"
+#include "omx_base_component.h"
+
+#define HW_OMX_BASE_SINK_INPUTPORT_INDEX    0     /* The index of the input port for the derived components */
+#define HW_OMX_BASE_SINK_CLOCKPORT_INDEX    1     /* The index of the clock port for the derived components */
+#define HW_OMX_BASE_SINK_INPUTPORT_INDEX_1  1     /* The index of the 2nd input port for the derived components */
+
+/** HW_OMX_BASE_SINK_ALLPORT_INDEX as the standard specifies, the -1 value for port index is used to point to all the ports
+ */
+#define HW_OMX_BASE_SINK_ALLPORT_INDEX -1
+
+/** base sink component private structure.
+ */
+DERIVEDCLASS(omx_base_sink_PrivateType, omx_base_component_PrivateType)
+#define omx_base_sink_PrivateType_FIELDS omx_base_component_PrivateType_FIELDS \
+  /** @param BufferMgmtCallback function pointer for algorithm callback */ \
+  void (*BufferMgmtCallback)(HW_OMX_COMPONENTTYPE* openmaxStandComp, HW_OMX_BUFFERHEADERTYPE* inputbuffer);
+ENDCLASS(omx_base_sink_PrivateType)
+
+/** Base sink contructor
+ */
+HW_OMX_ERRORTYPE omx_base_sink_Constructor(HW_OMX_COMPONENTTYPE *openmaxStandComp,HW_OMX_STRING cComponentName);
+
+/** The base sink destructor. It simply calls the base destructor
+ */
+HW_OMX_ERRORTYPE omx_base_sink_Destructor(HW_OMX_COMPONENTTYPE *openmaxStandComp);
+
+/** This is the central function for component processing. It
+ * is executed in a separate thread, is synchronized with
+ * semaphores at each port, those are released each time a new buffer
+ * is available on the given port.
+ */
+void* omx_base_sink_BufferMgmtFunction(void* param);
+
+void* omx_base_sink_twoport_BufferMgmtFunction (void* param);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_base_source.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_source.h
@@ -0,0 +1,80 @@
+/**
+  src/base/omx_base_source.h
+
+  OpenMAX base source component. This component does not perform any multimedia
+  processing. It derives from base component and contains a single port. It can be used
+  as base class for source components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef _HW_OMX_BASE_SOURCE_COMPONENT_H_
+#define _HW_OMX_BASE_SOURCE_COMPONENT_H_
+
+#include "HW_OMX_Types.h"
+#include "HW_OMX_Component.h"
+#include "HW_OMX_Core.h"
+#include "omx_base_component.h"
+
+/** HW_OMX_BASE_SOURCE_OUTPUTPORT_INDEX is the index of any output port for the derived components
+ */
+#define HW_OMX_BASE_SOURCE_OUTPUTPORT_INDEX 0
+
+/** HW_OMX_BASE_SPLITTER_OUTPUTPORT_INDEX_1 is the index of any output port for the derived components
+ */
+#define HW_OMX_BASE_SOURCE_OUTPUTPORT_INDEX_1 1
+
+/** HW_OMX_BASE_SOURCE_ALLPORT_INDEX as the standard specifies, the -1 value for port index is used to point to all the ports
+ */
+#define HW_OMX_BASE_SOURCE_ALLPORT_INDEX -1
+
+/** base source component private structure.
+ */
+DERIVEDCLASS(omx_base_source_PrivateType, omx_base_component_PrivateType)
+#define omx_base_source_PrivateType_FIELDS omx_base_component_PrivateType_FIELDS \
+  /** @param BufferMgmtCallback function pointer for algorithm callback */ \
+  void (*BufferMgmtCallback)(HW_OMX_COMPONENTTYPE* openmaxStandComp, HW_OMX_BUFFERHEADERTYPE* outputbuffer);
+ENDCLASS(omx_base_source_PrivateType)
+
+/** Base source contructor
+ */
+HW_OMX_ERRORTYPE omx_base_source_Constructor(HW_OMX_COMPONENTTYPE *openmaxStandComp,HW_OMX_STRING cComponentName);
+
+/** The base source destructor. It simply calls the base destructor
+ */
+HW_OMX_ERRORTYPE omx_base_source_Destructor(HW_OMX_COMPONENTTYPE *openmaxStandComp);
+
+/** This is the central function for component processing. It
+ * is executed in a separate thread, is synchronized with
+ * semaphores at each port, those are released each time a new buffer
+ * is available on the given port.
+ */
+void* omx_base_source_BufferMgmtFunction(void* param);
+
+/** This is the central function for buffer processing of a two port source component.
+  * It is executed in a separate thread, is synchronized with
+  * semaphores at each port, those are released each time a new buffer
+  * is available on the given port.
+  */
+
+void* omx_base_source_twoport_BufferMgmtFunction (void* param);
+
+#endif
+
Index: ffmpeg/libavcodec/bellagio/omx_base_video_port.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_base_video_port.h
@@ -0,0 +1,88 @@
+/**
+  src/base/omx_base_video_port.h
+    
+  Base Video Port class for OpenMAX ports to be used in derived components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#include "omx_base_component.h"
+#include "omx_classmagic.h"
+#include "omx_base_port.h"
+
+#ifndef __HW_OMX_BASE_VIDEO_PORT_H__
+#define __HW_OMX_BASE_VIDEO_PORT_H__
+
+/** define the max output buffer size */
+#define MAX_VIDEO_OUTPUT_BUF_SIZE 460800 //640 * 480 * 1.5
+#define MIN_VIDEO_OUTPUT_BUF_SIZE 176*144*3 //176 * 144 * 1.5
+/**
+ * @brief the base video domain structure that describes each port. 
+ * 
+ * The data structure is derived from base port class and contain video 
+ * domain specific parameters.
+ * Other elements can be added in the derived components structures. 
+ */
+
+DERIVEDCLASS(omx_base_video_PortType, omx_base_PortType)
+#define omx_base_video_PortType_FIELDS omx_base_PortType_FIELDS \
+  /** @param sVideoParam Domain specific (video) OpenMAX port parameter */ \
+  HW_OMX_VIDEO_PARAM_PORTFORMATTYPE sVideoParam; 
+ENDCLASS(omx_base_video_PortType)
+
+/** 
+  * @brief The base contructor for the generic OpenMAX ST Video port
+  * 
+  * This function is executed by the component that uses a port.
+  * The parameter contains the info about the component.
+  * It takes care of constructing the instance of the port and 
+  * every object needed by the base port.
+  *
+  * @param openmaxStandComp pointer to the Handle of the component
+  * @param openmaxStandPort the ST port to be initialized
+  * @param nPortIndex Index of the port to be constructed
+  * @param isInput specifices if the port is an input or an output
+  * 
+  * @return HW_OMX_ErrorInsufficientResources if a memory allocation fails
+  */
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE base_video_port_Constructor(
+  HW_OMX_COMPONENTTYPE *openmaxStandComp,
+  omx_base_PortType **openmaxStandPort,
+  HW_OMX_U32 nPortIndex, 
+  HW_OMX_BOOL isInput);
+
+/** 
+  * @brief The base video port destructor for the generic OpenMAX ST Video port
+  * 
+  * This function is executed by the component that uses a port.
+  * The parameter contains the info about the port.
+  * It takes care of destructing the instance of the port
+  * 
+  * @param openmaxStandPort the ST port to be destructed
+  * 
+  * @return HW_OMX_ErrorNone 
+  */
+
+
+OSCL_IMPORT_REF HW_OMX_ERRORTYPE base_video_port_Destructor(
+  omx_base_PortType *openmaxStandPort);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_classmagic.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_classmagic.h
@@ -0,0 +1,96 @@
+/**
+  src/base/omx_classmagic.h
+	  
+  This file contains class handling helper macros
+  It is left as an exercise to the reader how they do the magic (FIXME)
+  
+  Usage Rules:
+  1) include this file
+  2) if your don't inherit, start your class with CLASS(classname)
+  3) if you inherit something, start your class with 
+  	DERIVEDCLASS(classname, inheritedclassname)
+  4) end your class with ENDCLASS(classname)
+  5) define your class variables with a #define classname_FIELDS inheritedclassname_FIELDS
+  	inside your class and always add a backslash at the end of line (except last)
+  6) if you want to use doxygen, use C-style comments inside the #define, and
+  	enable macro expansion in doxyconf and predefine DOXYGEN_PREPROCESSING there, etc.
+  
+  See examples at the end of this file (in #if 0 block)
+  
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+#ifndef HW_OMX_CLASSMAGIC_H_
+#define HW_OMX_CLASSMAGIC_H_
+
+
+#ifdef DOXYGEN_PREPROCESSING
+#define CLASS(a) class a { public:
+#define DERIVEDCLASS(a, b) class a : public b { public:
+#define ENDCLASS(a) a##_FIELDS };
+#else
+#define CLASS(a) typedef struct a a; \
+ struct a { 
+#define DERIVEDCLASS(a, b) typedef struct a a; \
+ struct a {
+#define ENDCLASS(a) a##_FIELDS };
+#endif
+
+#if 0 /*EXAMPLES*/
+/**
+ * Class A is a nice class
+ */
+CLASS(A)
+#define A_FIELDS \
+/** @param a very nice parameter */ \
+ 	int a; \
+/** @param ash another very nice parameter */ \
+ 	int ash;
+ENDCLASS(A)
+ 
+/**
+ * Class B is a nice derived class
+ */
+DERIVEDCLASS(B,A)
+#define B_FIELDS A_FIELDS \
+/** @param b very nice parameter */ \
+	int b;
+ENDCLASS(B)
+
+/**
+ * Class B2 is a nice derived class
+ */
+DERIVEDCLASS(B2,A)
+#define B2_FIELDS A_FIELDS \
+/** @param b2 very nice parameter */ \
+	int b2;
+ENDCLASS(B2)
+
+/**
+ * Class C is an even nicer derived class.
+ */
+DERIVEDCLASS(C,B)
+#define C_FIELDS B_FIELDS \
+/** @param c very nice parameter */ \
+	int c;
+ENDCLASS(C)
+
+#endif /* 0 */
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_comp_debug_levels.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_comp_debug_levels.h
@@ -0,0 +1,82 @@
+/**
+  src/omx_comp_debug_levels.h
+
+  Define the level of debug prints on standard err. The different levels can
+  be composed with binary OR.
+  The debug levels defined here belong to OpenMAX components and IL core
+
+  Copyright (C) 2007-2011 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __HW_OMX_COMP_DEBUG_LEVELS_H__
+#define __HW_OMX_COMP_DEBUG_LEVELS_H__
+
+#include <stdio.h>
+
+/** Remove all debug output lines
+ */
+#define DEB_LEV_NO_OUTPUT  0
+
+/** Messages explaining the reason of critical errors
+ */
+#define DEB_LEV_ERR        1
+
+/** Messages showing values related to the test and the component/s used
+ */
+#define DEB_LEV_PARAMS     2
+
+/** Messages representing steps in the execution. These are the simple messages, because
+ * they avoid iterations
+ */
+#define DEB_LEV_SIMPLE_SEQ 4
+
+/** Messages representing steps in the execution. All the steps are described,
+ * also with iterations. With this level of output the performances are
+ * seriously compromised
+ */
+#define DEB_LEV_FULL_SEQ   8
+
+/** Messages that indicates the beginning and the end of a function.
+ * It can be used to trace the execution
+ */
+#define DEB_LEV_FUNCTION_NAME 16
+
+/** Messages that are the default test application output. These message should be
+ * shown every time
+ */
+#define DEFAULT_MESSAGES 32
+
+/** All the messages - max value
+ */
+#define DEB_ALL_MESS   255
+
+#ifdef CONFIG_DEBUG_LEVEL
+/** \def DEBUG_LEVEL is the current level do debug output on standard err */
+#define DEBUG_LEVEL (DEB_LEV_ERR | CONFIG_DEBUG_LEVEL)
+#else
+#define DEBUG_LEVEL (DEB_LEV_ERR)
+#endif
+#if DEBUG_LEVEL > 0
+#define DEBUG(n, fmt, args...) do { if (DEBUG_LEVEL & (n)){fprintf(stderr, "OMX-" fmt, ##args);} } while (0)
+#else
+#define DEBUG(n, fmt, args...) {}
+#endif
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omx_reference_resource_manager.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omx_reference_resource_manager.h
@@ -0,0 +1,76 @@
+/**
+  src/omx_reference_resource_manager.h
+
+  This simple resource manager emulates the behavior of a real RM.
+	It applies the rules defined in the OpenMAX spec. It can be replaced in
+	the future by a real system.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef _HW_OMX_REFERENCE_RESOURCE_MANAGER_H_
+#define _HW_OMX_REFERENCE_RESOURCE_MANAGER_H_
+
+#define MAX_COMPONENTS_TYPES_HANDLED 500
+
+#include "omxcore.h"
+
+
+typedef struct ComponentListType ComponentListType;
+struct ComponentListType {
+	HW_OMX_COMPONENTTYPE *openmaxStandComp;
+	HW_OMX_U32 nGroupPriority;
+	HW_OMX_U32 timestamp;
+	ComponentListType* next;
+};
+
+typedef struct NameIndexType NameIndexType;
+struct NameIndexType {
+	char* component_name;
+	int index;
+	int max_components;
+};
+
+
+int globalIndex;
+NameIndexType *listOfcomponentRegistered;
+ComponentListType **globalComponentList;
+ComponentListType **globalWaitingComponentList;
+
+HW_OMX_ERRORTYPE RM_RegisterComponent(char *name, int max_components);
+HW_OMX_ERRORTYPE addElemToList(ComponentListType **list, HW_OMX_COMPONENTTYPE *openmaxStandComp, int index, HW_OMX_BOOL bIsWaiting);
+HW_OMX_ERRORTYPE removeElemFromList(ComponentListType **list, HW_OMX_COMPONENTTYPE *openmaxStandComp);
+int numElemInList(ComponentListType *list);
+HW_OMX_ERRORTYPE clearList(ComponentListType **list);
+
+/** Debug flags
+ */
+#define RM_SHOW_NAME 0x01
+#define RM_SHOW_ADDRESS 0x02
+
+HW_OMX_ERRORTYPE RM_Init();
+HW_OMX_ERRORTYPE RM_Deinit();
+HW_OMX_ERRORTYPE RM_getResource(HW_OMX_COMPONENTTYPE *openmaxStandComp);
+HW_OMX_ERRORTYPE RM_releaseResource(HW_OMX_COMPONENTTYPE *openmaxStandComp);
+HW_OMX_ERRORTYPE RM_waitForResource(HW_OMX_COMPONENTTYPE *openmaxStandComp);
+HW_OMX_ERRORTYPE RM_removeFromWaitForResource(HW_OMX_COMPONENTTYPE *openmaxStandComp);
+void RM_printList(ComponentListType *list, int viewFlag);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/omxcore.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/omxcore.h
@@ -0,0 +1,58 @@
+/**
+  src/omxcore.h
+
+  OpenMAX Integration Layer Core. This library implements the OpenMAX core
+  responsible for environment setup, components tunneling and communication.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __ST_OMXCORE_H__
+#define __ST_OMXCORE_H__
+
+#include "HW_OMX_Component.h"
+#include "HW_OMX_Types.h"
+#include <pthread.h>
+
+#include "utils.h"
+#include "component_loader.h"
+#include "omx_comp_debug_levels.h"
+#ifdef ANDROID_COMPILATION
+#include <oscl_base_macros.h>
+#else
+#define OSCL_IMPORT_REF
+#define OSCL_EXPORT_REF
+#endif
+
+//forward decl
+struct BOSA_COMPONENTLOADER;
+
+HW_OMX_ERRORTYPE BOSA_AddComponentLoader(struct BOSA_COMPONENTLOADER *pLoader);
+
+/** Defines the major version of the core */
+#define SPECVERSIONMAJOR  1
+/** Defines the minor version of the core */
+#define SPECVERSIONMINOR  1
+/** Defines the revision of the core */
+#define SPECREVISION      0
+/** Defines the step version of the core */
+#define SPECSTEP          0
+
+#endif
Index: ffmpeg/libavcodec/bellagio/queue.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/queue.h
@@ -0,0 +1,93 @@
+/**
+  src/queue.h
+
+  Implements a simple FIFO structure used for queueing OMX buffers.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __TQUEUE_H__
+#define __TQUEUE_H__
+
+#include <pthread.h>
+/** Maximum number of elements in a queue
+ */
+#define MAX_QUEUE_ELEMENTS 10
+/** Output port queue element. Contains an OMX buffer header type
+ */
+typedef struct qelem_t qelem_t;
+struct qelem_t{
+  qelem_t* q_forw;
+  void* data;
+};
+
+/** This structure contains the queue
+ */
+typedef struct queue_t{
+  qelem_t* first; /**< Output buffer queue head */
+  qelem_t* last; /**< Output buffer queue tail */
+  int nelem; /**< Number of elements in the queue */
+  pthread_mutex_t mutex;
+} queue_t;
+
+/** Initialize a queue descriptor
+ *
+ * @param queue The queue descriptor to initialize.
+ * The user needs to allocate the queue
+ *
+ * @return -1 if the resources are not enough and the allocation cannot be performed
+ */
+int queue_init(queue_t* queue);
+
+/** Deinitialize a queue descriptor
+ * flushing all of its internal data
+ *
+ * @param queue the queue descriptor to dump
+ */
+void queue_deinit(queue_t* queue);
+
+/** Enqueue an element to the given queue descriptor
+ *
+ * @param queue the queue descritpor where to queue data
+ *
+ * @param data the data to be enqueued
+ *
+ * @return -1 if the queue is full
+ */
+int queue(queue_t* queue, void* data);
+
+/** Dequeue an element from the given queue descriptor
+ *
+ * @param queue the queue descriptor from which to dequeue the element
+ *
+ * @return the element that has bee dequeued. If the queue is empty
+ *  a NULL value is returned
+ */
+void* dequeue(queue_t* queue);
+
+/** Returns the number of elements hold in the queue
+ *
+ * @param queue the requested queue
+ *
+ * @return the number of elements in the queue
+ */
+int getquenelem(queue_t* queue);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/st_static_component_loader.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/st_static_component_loader.h
@@ -0,0 +1,126 @@
+/**
+  src/st_static_component_loader.h
+
+  ST specific component loader for local components.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __ST_STATIC_COMPONENT_LOADER_H__
+#define __ST_STATIC_COMPONENT_LOADER_H__
+
+#include "omxcore.h"
+#include "extension_struct.h"
+
+/** @brief the private data structure handled by the ST static loader that described
+ * an OpenMAX component
+ *
+ * This structure contains all the fields that the loader must use to support
+ * the loading  unloading functions of the component, that are not described by the
+ * standard.
+ */
+typedef struct stLoaderComponentType{
+  HW_OMX_VERSIONTYPE componentVersion; /**< the version of the component in the OpenMAX standard format */
+  char* name; /**< String that represents the name of the component, ruled by the standard */
+  unsigned int name_specific_length;/**< this field contains the number of roles of the component */
+  char** name_specific; /**< Strings those represent the names of the specific format components */
+  char** role_specific; /**< Strings those represent the names of the specific format components */
+  char* name_requested; /**< This parameter is used to send to the component the string requested by the IL Client */
+  HW_OMX_ERRORTYPE (*constructor)(HW_OMX_COMPONENTTYPE*,HW_OMX_STRING cComponentName); /**< constructor function pointer for each Linux ST OpenMAX component */
+  HW_OMX_U32 nqualitylevels;/**< number of available quality levels */
+  multiResourceDescriptor** multiResourceLevel;
+} stLoaderComponentType;
+
+/** @brief The initialization of the ST specific component loader.
+ */
+void st_static_setup_component_loader(BOSA_COMPONENTLOADER * st_static_loader);
+
+/** @brief The constructor of the ST specific component loader.
+ *
+ * It is the component loader developed under linux by ST, for local libraries.
+ * It is based on a registry file, like in the case of GStreamer. It reads the
+ * registry file, and allows the components to register themself to the
+ * main list templateList.
+ */
+HW_OMX_ERRORTYPE BOSA_ST_InitComponentLoader(BOSA_COMPONENTLOADER *loader);
+
+/** @brief The destructor of the ST specific component loader.
+ *
+ * This function deallocates the list of available components.
+ */
+HW_OMX_ERRORTYPE BOSA_ST_DeInitComponentLoader(BOSA_COMPONENTLOADER *loader);
+
+/** @brief creator of the requested openmax component
+ *
+ * This function searches for the requested component in the internal list.
+ * If the component is found, its constructor is called,
+ * and the standard callback are assigned.
+ * A pointer to a standard openmax component is returned.
+ */
+HW_OMX_ERRORTYPE BOSA_ST_CreateComponent(
+    BOSA_COMPONENTLOADER *loader,
+    HW_OMX_HANDLETYPE* pHandle,
+    HW_OMX_STRING cComponentName,
+    HW_OMX_PTR pAppData,
+    HW_OMX_CALLBACKTYPE* pCallBacks);
+
+/** @brief destructor of the requested OpenMAX component
+ *
+ */
+HW_OMX_ERRORTYPE BOSA_ST_DestroyComponent(
+    BOSA_COMPONENTLOADER *loader,
+    HW_OMX_HANDLETYPE hComponent);
+
+/** @brief This function search for the index from 0 to end of the list
+ *
+ * This function searches in the list of ST static components and enumerates
+ * both the class names and the role specific components.
+ */
+HW_OMX_ERRORTYPE BOSA_ST_ComponentNameEnum(
+    BOSA_COMPONENTLOADER *loader,
+    HW_OMX_STRING cComponentName,
+    HW_OMX_U32 nNameLength,
+    HW_OMX_U32 nIndex);
+
+/** @brief The specific version of HW_OMX_GetRolesOfComponent
+ *
+ * This function replicates exactly the behavior of the
+ * standard HW_OMX_GetRolesOfComponent function for the ST static
+ * component loader
+ */
+HW_OMX_ERRORTYPE BOSA_ST_GetRolesOfComponent(
+    BOSA_COMPONENTLOADER *loader,
+    HW_OMX_STRING compName,
+    HW_OMX_U32 *pNumRoles,
+    HW_OMX_U8 **roles);
+
+/** @brief The specific version of HW_OMX_GetComponentsOfRole
+ *
+ * This function replicates exactly the behavior of the
+ * standard HW_OMX_GetComponentsOfRole function for the ST static
+ * component loader
+ */
+HW_OMX_ERRORTYPE BOSA_ST_GetComponentsOfRole (
+    BOSA_COMPONENTLOADER *loader,
+    HW_OMX_STRING role,
+    HW_OMX_U32 *pNumComps,
+    HW_OMX_U8  **compNames);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/tsemaphore.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/tsemaphore.h
@@ -0,0 +1,98 @@
+/**
+  src/tsemaphore.h
+
+  Implements a simple inter-thread semaphore so not to have to deal with IPC
+  creation and the like.
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+#ifndef __TSEMAPHORE_H__
+#define __TSEMAPHORE_H__
+#ifdef ANDROID_COMPILATION
+#include <oscl_base_macros.h>
+#else
+#define OSCL_IMPORT_REF
+#define OSCL_EXPORT_REF
+#endif
+
+/** The structure contains the semaphore value, mutex and green light flag
+ */
+typedef struct tsem_t{
+  pthread_cond_t condition;
+  pthread_mutex_t mutex;
+  unsigned int semval;
+}tsem_t;
+
+/** Initializes the semaphore at a given value
+ *
+ * @param tsem the semaphore to initialize
+ *
+ * @param val the initial value of the semaphore
+ */
+OSCL_IMPORT_REF int tsem_init(tsem_t* tsem, unsigned int val);
+
+/** Destroy the semaphore
+ *
+ * @param tsem the semaphore to destroy
+ */
+OSCL_IMPORT_REF void tsem_deinit(tsem_t* tsem);
+
+/** Decreases the value of the semaphore. Blocks if the semaphore
+ * value is zero.
+ *
+ * @param tsem the semaphore to decrease
+ */
+OSCL_IMPORT_REF void tsem_down(tsem_t* tsem);
+
+/** Decreases the value of the semaphore. Blocks if the semaphore
+ * value is zero. If the timeout is reached the function exits with
+ * error ETIMEDOUT
+ *
+ * @param tsem the semaphore to decrease
+ * @param timevalue the value of delay for the timeout
+ */
+OSCL_IMPORT_REF int tsem_timed_down(tsem_t* tsem, unsigned int milliSecondsDelay);
+
+/** Increases the value of the semaphore
+ *
+ * @param tsem the semaphore to increase
+ */
+OSCL_IMPORT_REF void tsem_up(tsem_t* tsem);
+
+/** Reset the value of the semaphore
+ *
+ * @param tsem the semaphore to reset
+ */
+OSCL_IMPORT_REF void tsem_reset(tsem_t* tsem);
+
+/** Wait on the condition.
+ *
+ * @param tsem the semaphore to wait
+ */
+OSCL_IMPORT_REF void tsem_wait(tsem_t* tsem);
+
+/** Signal the condition,if waiting
+ *
+ * @param tsem the semaphore to signal
+ */
+OSCL_IMPORT_REF void tsem_signal(tsem_t* tsem);
+
+#endif
Index: ffmpeg/libavcodec/bellagio/user_debug_levels.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/user_debug_levels.h
@@ -0,0 +1,69 @@
+/**
+	test/components/common/user_debug_levels.h
+
+	Define the level of debug prints on standard err. The different levels can
+	be composed with binary OR.
+	The debug levels defined here belong to the test applications
+
+	Copyright (C) 2007-2009 STMicroelectronics
+	Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+	This library is free software; you can redistribute it and/or modify it under
+	the terms of the GNU Lesser General Public License as published by the Free
+	Software Foundation; either version 2.1 of the License, or (at your option)
+	any later version.
+
+	This library is distributed in the hope that it will be useful, but WITHOUT
+	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+	FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+	details.
+
+	You should have received a copy of the GNU Lesser General Public License
+	along with this library; if not, write to the Free Software Foundation, Inc.,
+	51 Franklin St, Fifth Floor, Boston, MA
+	02110-1301  USA
+
+*/
+
+
+/** Remove all debug output lines
+ */
+#define DEB_LEV_NO_OUTPUT  0
+/** Messages explaing the reason of critical errors
+ */
+#define DEB_LEV_ERR        1
+/** Messages showing values related to the test and the component/s used
+ */
+#define DEB_LEV_PARAMS     2
+/** Messages representing steps in the execution. These are the simple messages, because
+ * they avoid iterations
+ */
+#define DEB_LEV_SIMPLE_SEQ 4
+/** Messages representing steps in the execution. All the steps are described,
+ * also with iterations. With this level of output the performance is
+ * seriously compromised
+ */
+#define DEB_LEV_FULL_SEQ   8
+/** Messages that indicate the beginning and the end of a function.
+ * It can be used to trace the execution
+ */
+#define DEB_LEV_FUNCTION_NAME 16
+
+/** Messages that are the default test application output. These message should be
+	* shown every time
+	*/
+#define DEFAULT_MESSAGES 32
+
+/** All the messages - max value
+ */
+#define DEB_ALL_MESS   255
+
+
+/** \def DEBUG_LEVEL is the current level do debug output on standard err */
+#define DEBUG_LEVEL (DEB_LEV_ERR | DEFAULT_MESSAGES)
+#if DEBUG_LEVEL > 0
+#define DEBUG(n, args...) do { if (DEBUG_LEVEL & (n)){fprintf(stderr, args);} } while (0)
+#else
+#define DEBUG(n, args...)
+#endif
+
Index: ffmpeg/libavcodec/bellagio/utils.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/bellagio/utils.h
@@ -0,0 +1,37 @@
+/**
+  src/utils.h
+
+  Set of utility functions for debugging purposes
+
+  Copyright (C) 2007-2009 STMicroelectronics
+  Copyright (C) 2007-2009 Nokia Corporation and/or its subsidiary(-ies).
+
+  This library is free software; you can redistribute it and/or modify it under
+  the terms of the GNU Lesser General Public License as published by the Free
+  Software Foundation; either version 2.1 of the License, or (at your option)
+  any later version.
+
+  This library is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+  FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
+  details.
+
+  You should have received a copy of the GNU Lesser General Public License
+  along with this library; if not, write to the Free Software Foundation, Inc.,
+  51 Franklin St, Fifth Floor, Boston, MA
+  02110-1301  USA
+
+*/
+
+
+#ifndef __ST_UTILS_H__
+#define __ST_UTILS_H__
+
+#include "HW_OMX_Component.h"
+#include "HW_OMX_Types.h"
+
+char *stateName(HW_OMX_STATETYPE state);
+char *transientStateName(int state);
+char *errorName(HW_OMX_ERRORTYPE error);
+
+#endif
Index: ffmpeg/libavcodec/omx_dec.c
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec.c
@@ -0,0 +1,259 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "omx_dec_common.h"
+#include "omx_dec_wrapper.h"
+
+#include "version.h"
+#include "avcodec.h"
+#include "internal.h"
+#include "libavutil/opt.h"
+
+#define VD (AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM)
+#define VDE (AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM | AV_OPT_FLAG_ENCODING_PARAM)
+#define HW_OMX_DEC_SUPPORTED_AV_VERSION 58
+
+#define HW_OMX_PLUGIN_VERSION_MAJOR 1
+#define HW_OMX_PLUGIN_VERSION_MINOR 1
+#define HW_OMX_PLUGIN_VERSION_MICRO 5
+
+static void omx_decode_flush(AVCodecContext *avctx)
+{
+    int32_t ret;
+
+    if (avctx == NULL) {
+        AV_LOGE("avctx is NULL");
+        return;
+    }
+
+    ret = omx_flush_component(avctx);
+    if (ret != 0) {
+        AV_LOGE("omx_decode_flush failed");
+    }
+}
+static int32_t omx_decode_init(AVCodecContext *avctx)
+{
+    int32_t ret;
+
+    CHECK_PARAM_RET(avctx != NULL, "avctx is NULL");
+
+    AV_LOGD("FFmpeg OMX plugin version %d.%d.%d", HW_OMX_PLUGIN_VERSION_MAJOR,
+                                                  HW_OMX_PLUGIN_VERSION_MINOR,
+                                                  HW_OMX_PLUGIN_VERSION_MICRO);
+
+    if (LIBAVCODEC_VERSION_MAJOR < HW_OMX_DEC_SUPPORTED_AV_VERSION) {
+        AV_LOGE("FFmpeg version is too low");
+        return AVERROR_EXIT;
+    }
+    ret = omx_initialize_decoder(avctx);
+    if (ret != 0) {
+        AV_LOGE("omx_decode_init failed");
+        return ret;
+    }
+
+    return 0;
+}
+
+static int32_t omx_decode_deinit(AVCodecContext *avctx)
+{
+    int32_t ret;
+
+    CHECK_PARAM_RET(avctx != NULL, "avctx is NULL");
+
+    ret = omx_release_decoder(avctx);
+    if (ret != 0) {
+        AV_LOGE("omx_decode_deinit failed");
+        return ret;
+    }
+
+    return 0;
+}
+
+
+static int32_t omx_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    int32_t ret;
+
+    CHECK_PARAM_RET(avctx != NULL && frame != NULL, "avctx or frame is NULL");
+
+    while (frame->buf[0] == NULL) {
+        ret = omx_perform_decoding(avctx, frame);
+        if (ret < 0) {
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
+static const AVOption options[] = {
+    { "omx_libname", "OpenMAX library name", OFFSET(libname), AV_OPT_TYPE_STRING, {0}, 0, 0, VDE },
+    { "omx_libprefix", "OpenMAX library prefix", OFFSET(libprefix), AV_OPT_TYPE_STRING, {0}, 0, 0, VDE },
+    { NULL }
+};
+
+static const enum AVPixelFormat omx_decoder_pix_fmts[] = {
+    AV_PIX_FMT_NV12, AV_PIX_FMT_NONE
+};
+
+static const AVClass omx_h264dec_class = {
+    .class_name = "h264_omx_dec",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_h264_omx_decoder = {
+    .name = "h264_omx_dec",
+    .long_name = NULL_IF_CONFIG_SMALL("OpenMAX IL H.264 video decoder"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_H264,
+    .priv_data_size = sizeof(OMXCodecContext),
+    .init = omx_decode_init,
+    .receive_frame = omx_decode_receive_frame,
+    .flush = omx_decode_flush,
+    .close = omx_decode_deinit,
+    .pix_fmts = omx_decoder_pix_fmts,
+    .capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE,
+    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .priv_class = &omx_h264dec_class,
+    .wrapper_name = "omx",
+};
+
+static const AVClass omx_hevcdec_class = {
+    .class_name = "hevc_omx_dec",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_hevc_omx_decoder = {
+    .name = "hevc_omx_dec",
+    .long_name = NULL_IF_CONFIG_SMALL("OpenMAX IL HEVC video decoder"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_HEVC,
+    .priv_data_size = sizeof(OMXCodecContext),
+    .init = omx_decode_init,
+    .receive_frame = omx_decode_receive_frame,
+    .flush = omx_decode_flush,
+    .close = omx_decode_deinit,
+    .pix_fmts = omx_decoder_pix_fmts,
+    .capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE,
+    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .priv_class = &omx_hevcdec_class,
+    .wrapper_name = "omx",
+};
+
+static const AVClass omx_vp9dec_class = {
+    .class_name = "vp9_omx_dec",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_vp9_omx_decoder = {
+    .name = "vp9_omx_dec",
+    .long_name = NULL_IF_CONFIG_SMALL("OpenMAX IL vp9 video decoder"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_VP9,
+    .priv_data_size = sizeof(OMXCodecContext),
+    .init = omx_decode_init,
+    .receive_frame = omx_decode_receive_frame,
+    .flush = omx_decode_flush,
+    .close = omx_decode_deinit,
+    .pix_fmts = omx_decoder_pix_fmts,
+    .capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE,
+    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .priv_class = &omx_vp9dec_class,
+    .wrapper_name = "omx",
+};
+
+static const AVClass omx_mpeg4dec_class = {
+    .class_name = "mpeg4_omx_dec",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_mpeg4_omx_decoder = {
+    .name = "mpeg4_omx_dec",
+    .long_name = NULL_IF_CONFIG_SMALL("OpenMAX IL MPEG4 video decoder"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_MPEG4,
+    .priv_data_size = sizeof(OMXCodecContext),
+    .init = omx_decode_init,
+    .receive_frame = omx_decode_receive_frame,
+    .flush = omx_decode_flush,
+    .close = omx_decode_deinit,
+    .pix_fmts = omx_decoder_pix_fmts,
+    .capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE,
+    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .priv_class = &omx_mpeg4dec_class,
+    .wrapper_name = "omx",
+};
+
+static const AVClass omx_mpeg2dec_class = {
+    .class_name = "mpeg2_omx_dec",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_mpeg2_omx_decoder = {
+    .name = "mpeg2_omx_dec",
+    .long_name = NULL_IF_CONFIG_SMALL("OpenMAX IL MPEG2 video decoder"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_MPEG2VIDEO,
+    .priv_data_size = sizeof(OMXCodecContext),
+    .init = omx_decode_init,
+    .receive_frame = omx_decode_receive_frame,
+    .flush = omx_decode_flush,
+    .close = omx_decode_deinit,
+    .pix_fmts = omx_decoder_pix_fmts,
+    .capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE,
+    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .priv_class = &omx_mpeg2dec_class,
+    .wrapper_name = "omx",
+};
+
+static const AVClass omx_mpeg1dec_class = {
+    .class_name = "mpeg1_omx_dec",
+    .item_name = av_default_item_name,
+    .option = options,
+    .version = LIBAVUTIL_VERSION_INT,
+};
+
+AVCodec ff_mpeg1_omx_decoder = {
+    .name = "mpeg1_omx_dec",
+    .long_name = NULL_IF_CONFIG_SMALL("OpenMAX IL MPEG1 video decoder"),
+    .type = AVMEDIA_TYPE_VIDEO,
+    .id = AV_CODEC_ID_MPEG1VIDEO,
+    .priv_data_size = sizeof(OMXCodecContext),
+    .init = omx_decode_init,
+    .receive_frame = omx_decode_receive_frame,
+    .flush = omx_decode_flush,
+    .close = omx_decode_deinit,
+    .pix_fmts = omx_decoder_pix_fmts,
+    .capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE,
+    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .priv_class = &omx_mpeg1dec_class,
+    .wrapper_name = "omx",
+};
Index: ffmpeg/libavcodec/omx_dec_common.c
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec_common.c
@@ -0,0 +1,149 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "omx_dec_common.h"
+#include "h264.h"
+#include "hevc.h"
+
+#include "avcodec.h"
+#include "internal.h"
+#include "bytestream.h"
+#include "HW_OMX_Core.h"
+
+#include "omx_dec_wrapper.h"
+
+#define MIN_HEVCC_SIZE 23
+#define NALU_HEADER_SIZE 4
+
+int32_t mutexlock_init(AVCodecContext *avctx, MutexLock *mutex_lock)
+{
+    if (mutex_lock->is_init == TRUE) {
+        return 0;
+    }
+
+    if (pthread_mutex_init(&mutex_lock->lock, NULL) != 0) {
+        AV_LOGE("mutexlock init failed");
+        return -1;
+    }
+
+    mutex_lock->is_init = TRUE;
+
+    return 0;
+}
+
+int32_t mutexlock_destroy(AVCodecContext *avctx, MutexLock *mutex_lock)
+{
+    if (mutex_lock->is_init == FALSE) {
+        return 0;
+    }
+
+    if (pthread_mutex_destroy(&mutex_lock->lock) != 0) {
+        AV_LOGE("mutexlock destroy failed");
+        return -1;
+    }
+
+    mutex_lock->is_init = FALSE;
+
+    return 0;
+}
+
+int32_t mutexcond_init(AVCodecContext *avctx, MutexCond *mutex_cond)
+{
+    if (mutex_cond->is_init == TRUE) {
+        return 0;
+    }
+
+    if (pthread_cond_init(&mutex_cond->cond, NULL) != 0) {
+        AV_LOGE("cond init failed");
+        return -1;
+    }
+
+    mutex_cond->is_init = TRUE;
+
+    return 0;
+}
+
+int32_t mutexcond_destroy(AVCodecContext *avctx, MutexCond *mutex_cond)
+{
+    if (mutex_cond->is_init == FALSE) {
+        return 0;
+    }
+
+    if (pthread_cond_destroy(&mutex_cond->cond) != 0) {
+        AV_LOGE("cond destroy failed");
+        return -1;
+    }
+
+    mutex_cond->is_init = FALSE;
+
+    return 0;
+}
+
+void initialize_message_queue(OmxMessageQueue *queue)
+{
+    queue->read = 0;
+    queue->write = 0;
+    queue->size = 0;
+    memset(queue->omx_message_queue, 0, sizeof(OMXMessage) * HW_OMX_MESSAGE_LIST_LEN);
+}
+
+void push_message(AVCodecContext *avctx, OmxMessageQueue *queue, const OMXMessage *msg)
+{
+    if (queue->size >= HW_OMX_MESSAGE_LIST_LEN) {
+        AV_LOGE("message queue is full");
+        return;
+    }
+
+    queue->omx_message_queue[queue->write] = *msg;
+    queue->size++;
+    queue->write++;
+
+    if (queue->write >= HW_OMX_MESSAGE_LIST_LEN) {
+        queue->write = 0;
+    }
+}
+
+int32_t pop_message(AVCodecContext *avctx, OmxMessageQueue *queue, OMXMessage *msg)
+{
+    if (queue->size == 0) {
+        return -1;
+    }
+
+    *msg = queue->omx_message_queue[queue->read];
+    ++queue->read;
+    --queue->size;
+
+    if (queue->read >= HW_OMX_MESSAGE_LIST_LEN) {
+        queue->read = 0;
+    }
+
+    return 0;
+}
+
+bool is_message_queue_empty(OmxMessageQueue *queue)
+{
+    return queue->size ? FALSE : TRUE;
+}
+
+bool is_message_queue_full(OmxMessageQueue *queue)
+{
+    return (queue->size == HW_OMX_MESSAGE_LIST_LEN) ? TRUE : FALSE;
+}
Index: ffmpeg/libavcodec/omx_dec_common.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec_common.h
@@ -0,0 +1,160 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef HW_OMX_DEC_COMMON_H
+#define HW_OMX_DEC_COMMON_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <pthread.h>
+#include <stdbool.h>
+
+#include "avcodec.h"
+#include "HW_OMX_Core.h"
+#include "omx_dec_log.h"
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#define HW_OMX_MESSAGE_LIST_LEN 100
+
+#define COUNTOF(x) (sizeof(x) / sizeof((x)[0]))
+#define OFFSET(x) offsetof(OMXCodecContext, x)
+
+#define CHECK_MUTEX_RET(x) do { \
+        if ((x) != 0) { \
+            return AVERROR(EINVAL); \
+        } \
+    } while (0)
+
+#define CHECK_HW_OMX_RET(err, arg) do { \
+        if ((err) != HW_OMX_ErrorNone) { \
+            AV_LOGE("%s: %s (0x%08x)", (arg), omx_error_to_string(err), (err)); \
+            return err; \
+        } \
+    } while (0)
+
+#define CHECK_PARAM_RET(cond, arg) do { \
+        if (!(cond)) { \
+            AV_LOGE("%s", (arg)); \
+            return AVERROR(EINVAL); \
+        } \
+    } while (0)
+
+#define CHECK_FREE_BUFFER(p) do { \
+        if (*(p)) { \
+            av_freep(p); \
+        } \
+    } while (0)
+
+#define GET_WAIT_TIME(tv, timeus) do { \
+        (tv).tv_sec = (av_gettime() + (timeus)) / 1000000; \
+        (tv).tv_nsec = ((av_gettime() + (timeus)) % 1000000) * 1000; \
+    } while (0)
+
+typedef enum OMXEventType {
+    HW_OMX_STATE_SET_EVENT,
+    HW_OMX_FLUSH_EVENT,
+    HW_OMX_ERROR_EVENT,
+    HW_OMX_PORT_ENABLE_EVENT,
+    HW_OMX_PORT_SETTINGS_CHANGED_EVENT,
+    HW_OMX_BUFFER_FLAG_EVENT,
+    HW_OMX_BUFFER_DONE_EVENT,
+} OMXEventType;
+
+typedef struct OMXEventMessage {
+    OMXEventType type;
+    union {
+        struct {
+            HW_OMX_STATETYPE state;
+        } StateSet;
+
+        struct {
+            HW_OMX_U32 port;
+        } Flush;
+
+        struct {
+            HW_OMX_ERRORTYPE error;
+        } Error;
+
+        struct {
+            HW_OMX_U32 port;
+            HW_OMX_BOOL enable;
+        } PortEnable;
+
+        struct {
+            HW_OMX_U32 port;
+            HW_OMX_U32 type;
+        } PortSettingsChanged;
+
+        struct {
+            HW_OMX_U32 port;
+            HW_OMX_U32 flags;
+        } BufferFlag;
+    } Content;
+} OMXEventMessage;
+
+typedef struct OMXFrameMessage {
+    AVFrame data;
+    int32_t got_frame;
+    int32_t ret;
+} OMXFrameMessage;
+
+typedef union OMXMessage {
+    OMXFrameMessage frame;
+    OMXEventMessage event;
+} OMXMessage;
+
+typedef struct OmxMessageQueue {
+    OMXMessage omx_message_queue[HW_OMX_MESSAGE_LIST_LEN];
+    uint32_t read;
+    uint32_t write;
+    uint32_t size;
+} OmxMessageQueue;
+
+typedef struct MutexLock {
+    pthread_mutex_t lock;
+    bool is_init;
+} MutexLock;
+
+typedef struct MutexCond {
+    pthread_cond_t cond;
+    bool is_init;
+} MutexCond;
+
+int32_t mutexlock_init(AVCodecContext *avctx, MutexLock *mutex_lock);
+int32_t mutexlock_destroy(AVCodecContext *avctx, MutexLock *mutex_lock);
+int32_t mutexcond_init(AVCodecContext *avctx, MutexCond *mutex_cond);
+int32_t mutexcond_destroy(AVCodecContext *avctx, MutexCond *mutex_cond);
+void initialize_message_queue(OmxMessageQueue *queue);
+void push_message(AVCodecContext *avctx, OmxMessageQueue *queue, const OMXMessage *msg);
+int32_t pop_message(AVCodecContext *avctx, OmxMessageQueue *queue, OMXMessage *msg);
+bool is_message_queue_empty(OmxMessageQueue *queue);
+bool is_message_queue_full(OmxMessageQueue *queue);
+void free_buffer(void **p);
+
+#endif
Index: ffmpeg/libavcodec/omx_dec_log.c
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec_log.c
@@ -0,0 +1,103 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include "omx_dec_log.h"
+#include "avcodec.h"
+
+#include "omx_dec_common.h"
+
+const char *omx_error_to_string(HW_OMX_ERRORTYPE err)
+{
+    const char *string = "Unknown error";
+    static const Enum2String error_string[] = {
+        { HW_OMX_ErrorNone,                        "None" },
+        { HW_OMX_ErrorInsufficientResources,       "Insufficient resources" },
+        { HW_OMX_ErrorUndefined,                   "Undefined" },
+        { HW_OMX_ErrorInvalidComponentName,        "Invalid component name" },
+        { HW_OMX_ErrorComponentNotFound,           "Component not found" },
+        { HW_OMX_ErrorBadParameter,                "Bad parameter" },
+        { HW_OMX_ErrorNotImplemented,              "Not implemented" },
+        { HW_OMX_ErrorUnderflow,                   "Underflow" },
+        { HW_OMX_ErrorOverflow,                    "Overflow" },
+        { HW_OMX_ErrorHardware,                    "Hardware" },
+        { HW_OMX_ErrorStreamCorrupt,               "Stream corrupt" },
+        { HW_OMX_ErrorPortsNotCompatible,          "Ports not compatible" },
+        { HW_OMX_ErrorResourcesLost,               "Resources lost" },
+        { HW_OMX_ErrorNoMore,                      "No more" },
+        { HW_OMX_ErrorVersionMismatch,             "Version mismatch" },
+        { HW_OMX_ErrorNotReady,                    "Not ready" },
+        { HW_OMX_ErrorTimeout,                     "Timeout" },
+        { HW_OMX_ErrorSameState,                   "Same state" },
+        { HW_OMX_ErrorResourcesPreempted,          "Resources preempted" },
+        { HW_OMX_ErrorIncorrectStateTransition,    "Incorrect state transition" },
+        { HW_OMX_ErrorIncorrectStateOperation,     "Incorrect state operation" },
+        { HW_OMX_ErrorUnsupportedSetting,          "Unsupported setting" },
+        { HW_OMX_ErrorUnsupportedIndex,            "Unsupported index" },
+        { HW_OMX_ErrorBadPortIndex,                "Bad port index" },
+        { HW_OMX_ErrorPortUnpopulated,             "Port unpopulated" },
+        { HW_OMX_ErrorComponentSuspended,          "Component suspended" },
+        { HW_OMX_ErrorDynamicResourcesUnavailable, "Dynamic resources unavailable" },
+        { HW_OMX_ErrorMbErrorsInFrame,             "Macroblock errors in frame" },
+        { HW_OMX_ErrorFormatNotDetected,           "Format not detected" },
+        { HW_OMX_ErrorSeperateTablesUsed,          "Separate tables used" },
+        { HW_OMX_ErrorTunnelingUnsupported,        "Tunneling unsupported" },
+    };
+
+    if (err >= (uint32_t)HW_OMX_ErrorKhronosExtensions && err < (uint32_t)HW_OMX_ErrorVendorStartUnused) {
+        return "Khronos extension error";
+    } else if (err >= (uint32_t)HW_OMX_ErrorVendorStartUnused && err < (uint32_t)HW_OMX_ErrorMax) {
+        return "Vendor specific error";
+    }
+
+    for (int32_t i = 0; i < COUNTOF(error_string); i++) {
+        if (err == error_string[i].type) {
+            string = error_string[i].string;
+        }
+    }
+
+    return string;
+}
+
+const char *omx_state_to_string(HW_OMX_STATETYPE state)
+{
+    const char *string = "Unknown state";
+    static const Enum2String state_string[] = {
+        { HW_OMX_StateInvalid,          "Invalid" },
+        { HW_OMX_StateLoaded,           "Loaded" },
+        { HW_OMX_StateIdle,             "Idle" },
+        { HW_OMX_StateExecuting,        "Executing" },
+        { HW_OMX_StatePause,            "Pause" },
+        { HW_OMX_StateWaitForResources, "WaitForResources" },
+    };
+
+    if (state >= HW_OMX_StateKhronosExtensions && state < HW_OMX_StateVendorStartUnused) {
+        return "KhronosExtensionState";
+    } else if (state >= HW_OMX_StateVendorStartUnused && state < HW_OMX_StateMax) {
+        return "CustomVendorState";
+    }
+
+    for (int32_t i = 0; i < COUNTOF(state_string); i++) {
+        if (state == state_string[i].type) {
+            string = state_string[i].string;
+        }
+    }
+
+    return string;
+}
Index: ffmpeg/libavcodec/omx_dec_log.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec_log.h
@@ -0,0 +1,41 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef HW_OMX_DEC_LOG_H
+#define HW_OMX_DEC_LOG_H
+#include <stdlib.h>
+#include "HW_OMX_Core.h"
+
+#define AV_LOGD(fmt, arg...) av_log(avctx, AV_LOG_DEBUG, "D [%s] : [%d] " fmt "\n", __func__, __LINE__, ##arg)
+#define AV_LOGE(fmt, arg...) av_log(avctx, AV_LOG_ERROR, "E [%s] : [%d] " fmt "\n", __func__, __LINE__, ##arg)
+#define AV_LOGW(fmt, arg...) av_log(avctx, AV_LOG_WARNING, "W [%s] : [%d] " fmt "\n", __func__, __LINE__, ##arg)
+#define AV_LOGI(fmt, arg...) av_log(avctx, AV_LOG_INFO, "I [%s] : [%d] " fmt "\n", __func__, __LINE__, ##arg)
+#define AV_LOGT(fmt, arg...) av_log(avctx, AV_LOG_TRACE, "T [%s] : [%d] " fmt "\n", __func__, __LINE__, ##arg)
+
+typedef struct Enum2String {
+    int32_t type;
+    const char *string;
+} Enum2String;
+
+const char *omx_error_to_string(HW_OMX_ERRORTYPE err);
+const char *omx_state_to_string(HW_OMX_STATETYPE state);
+
+#endif
Index: ffmpeg/libavcodec/omx_dec_to_annexb.c
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec_to_annexb.c
@@ -0,0 +1,647 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "omx_dec_to_annexb.h"
+#include "h264.h"
+#include "hevc.h"
+
+#include "avcodec.h"
+#include "internal.h"
+#include "bytestream.h"
+#include "HW_OMX_Core.h"
+
+#include "omx_dec_wrapper.h"
+#include "omx_dec_common.h"
+
+#define MIN_HEVCC_SIZE 23
+#define NALU_HEADER_SIZE 4
+
+static void h264_annexb_get(AVCodecContext *avctx,const AVBSFContext *ctx)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+    int32_t err;
+    uint8_t *out = NULL;
+
+    err = av_reallocp(&out,ctx->par_in->extradata_size);
+    if(err < 0){
+        AV_LOGE("av_reallocp,ret=%d",err);
+        return;
+    }
+    memcpy(out,ctx->par_in->extradata,ctx->par_in->extradata_size);
+    s->annexb_buffer = out;
+    s->annexb_buffer_size = ctx->par_in->extradata_size;
+    AV_LOGD("s->annexb_buffer_size:%d",s->annexb_buffer_size);
+}
+
+static uint8_t h264_annexb_type(AVCodecContext *avctx,const uint8_t *buf)
+{
+    uint8_t unit_type;
+    uint8_t idx;
+    for(idx = 0; idx < 4; ++idx){
+        if((idx == 2 || idx == 3) && buf[idx] != 0x00){
+            break;
+        }
+    }
+
+    unit_type = buf[idx +1] & 0x1f;
+    AV_LOGD("val=0x%x,idx=%u,unit_type=0x%x",buf[idx +1],idx +1,unit_type);
+
+    return unit_type;
+}
+
+static void h264_annexb_AUD(AVCodecContext *avctx,const AVPacket *avpkt,HW_OMX_BUFFERHEADERTYPE *out)
+{
+    uint8_t idx;
+    int len;
+
+    for (idx = 0; idx < avpkt->size; ++idx){
+        if((idx ==2 || idx == 3) && (avpkt->data[idx] == 0x01)){
+            break;
+        }
+    }
+
+    len = idx + 3;
+    memcpy(out->pBuffer, avpkt->data +len, avpkt->size -len);
+    out->nFilledLen = avpkt->size -len;
+    AV_LOGD("idx=%u, data len before=%d, after=%d", idx + 1, avpkt->size,out->nFilledLen);
+
+    return;
+}
+
+static void h264_annexb_copy(AVCodecContext *avctx, const AVPacket *avpkt, HW_OMX_BUFFERHEADERTYPE *out)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+    memcpy(out->pBuffer, s->annexb_buffer, s->annexb_buffer_size);
+    memcpy(out->pBuffer + s->annexb_buffer_size, avpkt->data, avpkt->size);
+    out->nFilledLen = avpkt->size + s->annexb_buffer_size;
+}
+
+static int32_t hevc_extradata_to_annexb(AVCodecContext *avctx)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    HevcExtradataContext *s = &s1->extradata_context.hevc;
+    DecodeFilterContext *s2 = &avctx->internal->filter;
+    AVBSFContext *ctx = s2->bsfs[s2->nb_bsfs - 1];
+    GetByteContext gb = { 0 };
+    int32_t length_size, num_arrays, i, j;
+    int32_t ret;
+    uint8_t *new_extradata = NULL;
+    size_t new_extradata_size = 0;
+
+    bytestream2_init(&gb, ctx->par_in->extradata, ctx->par_in->extradata_size);
+    bytestream2_skip(&gb, 21); // 21: protocol threshold
+    length_size = (bytestream2_get_byte(&gb) & 3) + 1;
+    num_arrays = bytestream2_get_byte(&gb);
+
+    for (i = 0; i < num_arrays; i++) {
+        int32_t type = bytestream2_get_byte(&gb) & 0x3f;
+        int32_t cnt = bytestream2_get_be16(&gb);
+
+        if (!(type == HEVC_NAL_VPS || type == HEVC_NAL_SPS || type == HEVC_NAL_PPS || type == HEVC_NAL_SEI_PREFIX ||
+            type == HEVC_NAL_SEI_SUFFIX)) {
+            AV_LOGE("Invalid NAL unit type in extradata: %d", type);
+            ret = AVERROR_INVALIDDATA;
+            goto fail;
+        }
+
+        for (j = 0; j < cnt; j++) {
+            int32_t nalu_len = bytestream2_get_be16(&gb);
+            if (4 + AV_INPUT_BUFFER_PADDING_SIZE + nalu_len > SIZE_MAX - new_extradata_size) { // 4: frame header size
+                ret = AVERROR_INVALIDDATA;
+                goto fail;
+            }
+            // 4: frame header size
+            ret = av_reallocp(&new_extradata, new_extradata_size + nalu_len + 4 + AV_INPUT_BUFFER_PADDING_SIZE);
+            if (ret < 0) {
+                goto fail;
+            }
+
+            AV_WB32(new_extradata + new_extradata_size, 1);                                // add the startcode
+            bytestream2_get_buffer(&gb, new_extradata + new_extradata_size + 4, nalu_len); // 4: frame header size
+            new_extradata_size += 4 + nalu_len;                                            // 4: frame header size
+            memset(new_extradata + new_extradata_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+        }
+    }
+
+    av_freep(&ctx->par_in->extradata);
+    s->annexb_buffer = new_extradata;
+    s->annexb_buffer_size = new_extradata_size;
+
+    if (!new_extradata_size) {
+        AV_LOGW("No parameter sets in the extradata");
+    }
+    return length_size;
+fail:
+    av_freep(&new_extradata);
+
+    return ret;
+}
+
+int32_t hevc_annexb_init(AVCodecContext *avctx)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    HevcExtradataContext *s = &s1->extradata_context.hevc;
+    DecodeFilterContext *s2 = &avctx->internal->filter;
+    AVBSFContext *ctx;
+    int32_t ret;
+    AV_LOGD("hevc_annexb_init");
+
+    if (s2->nb_bsfs < 1) {
+        return AVERROR(EINVAL);
+    }
+    ctx = s2->bsfs[s2->nb_bsfs - 1];
+
+    if (ctx->par_in->extradata_size < MIN_HEVCC_SIZE || AV_RB24(ctx->par_in->extradata) == 1 ||
+        AV_RB32(ctx->par_in->extradata) == 1) {
+        AV_LOGD("The input looks like it is Annex B already");
+    } else {
+        ret = hevc_extradata_to_annexb(avctx);
+        if (ret < 0) {
+            return ret;
+        }
+        s->length_size = ret;
+        s->extradata_parsed = 1;
+        s->duplicate_params = 0;
+    }
+
+    return 0;
+}
+
+int32_t hevc_annexb_filter(AVCodecContext *avctx, const AVPacket *avpkt, HW_OMX_BUFFERHEADERTYPE *out)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    HevcExtradataContext *s = &s1->extradata_context.hevc;
+    const AVPacket *in = avpkt;
+    GetByteContext gb = { 0 };
+    int32_t got_irap = 0;
+    int32_t i;
+
+    if (!s->extradata_parsed) {
+        memcpy(out->pBuffer, in->data, in->size);
+        out->nFilledLen = in->size;
+        return 0;
+    }
+    bytestream2_init(&gb, in->data, in->size);
+
+    while (bytestream2_get_bytes_left(&gb)) {
+        uint32_t nalu_size = 0;
+        int32_t nalu_type;
+        int32_t is_irap, add_extradata, extra_size, prev_size;
+
+        for (i = 0; i < s->length_size; i++) {
+            nalu_size = (nalu_size << 8) | bytestream2_get_byte(&gb);
+        }
+
+        nalu_type = (bytestream2_peek_byte(&gb) >> 1) & 0x3f;
+
+        /* prepend extradata to IRAP frames */
+        is_irap = nalu_type >= 16 && nalu_type <= 23; // 16,23: nalu_type range
+        add_extradata = is_irap && !got_irap;
+        extra_size = add_extradata * s->annexb_buffer_size;
+        got_irap |= is_irap;
+
+        if ((SIZE_MAX - nalu_size < 4) || (extra_size > SIZE_MAX - nalu_size - 4)) { // 4: frame header size
+            return AVERROR_INVALIDDATA;
+        }
+
+        prev_size = out->nFilledLen;
+        out->nFilledLen += 4 + nalu_size + extra_size; // 4: frame header size
+        memset(out->pBuffer + out->nFilledLen, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+
+        if (s->duplicate_params == 0) {
+            s->duplicate_params = (nalu_type == HEVC_NAL_VPS) || (nalu_type == HEVC_NAL_SPS) || (nalu_type == HEVC_NAL_PPS);
+        }
+        if (add_extradata && (s->duplicate_params == 0)) {
+            memcpy(out->pBuffer + prev_size, s->annexb_buffer, extra_size);
+        }
+        if (add_extradata) {
+            s->duplicate_params = 0;
+        }
+
+        AV_WB32(out->pBuffer + prev_size + extra_size, 1);
+        bytestream2_get_buffer(&gb, out->pBuffer + prev_size + 4 + extra_size, nalu_size); // 4: frame header size
+    }
+
+    return 0;
+}
+
+static int32_t h264_alloc_and_copy(HW_OMX_BUFFERHEADERTYPE *out, const uint8_t *sps_pps, uint32_t sps_pps_size,
+    const uint8_t *in, uint32_t in_size, int32_t ps)
+{
+    uint32_t offset = out->nFilledLen;
+    uint8_t start_code_size = offset == 0 || ps ? 4 : 3; // 4,3: start code size
+
+    out->nFilledLen += sps_pps_size + in_size + start_code_size;
+    memset(out->pBuffer + out->nFilledLen, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+    if (sps_pps != NULL) {
+        memcpy(out->pBuffer + offset, sps_pps, sps_pps_size);
+    }
+    memcpy(out->pBuffer + sps_pps_size + start_code_size + offset, in, in_size);
+    if (start_code_size == 4) { // 4: start code size
+        AV_WB32(out->pBuffer + offset + sps_pps_size, 1);
+    } else {
+        (out->pBuffer + offset + sps_pps_size)[0] = (out->pBuffer + offset + sps_pps_size)[1] = 0;
+        (out->pBuffer + offset + sps_pps_size)[2] = 1; // 2: index
+    }
+
+    return 0;
+}
+
+void h264_annexb_flush(AVCodecContext *avctx)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+
+    AV_LOGD("h264_annexb_flush");
+    s->idr_sps_seen = 0;
+    s->idr_pps_seen = 0;
+    s->new_idr = s->extradata_parsed;
+}
+
+static int32_t h264_check_extradata_parameters(AVCodecContext *avctx, AVBSFContext *ctx, const uint8_t *extradata,
+    uint64_t total_size, uint8_t *out)
+{
+    uint16_t unit_size = AV_RB16(extradata);
+
+    if (total_size > INT_MAX) {
+        AV_LOGE("Too big extradata size, corrupted stream or invalid MP4/AVCC bitstream");
+        if (out != NULL) {
+            av_free(out);
+        }
+        return AVERROR(EINVAL);
+    }
+    if (extradata + 2 + unit_size > ctx->par_in->extradata + ctx->par_in->extradata_size) { // 2: offset
+        AV_LOGE("Packet header is not contained in global extradata, corrupted stream or invalid MP4/AVCC bitstream");
+        if (out != NULL) {
+            av_free(out);
+        }
+        return AVERROR(EINVAL);
+    }
+
+    return 0;
+}
+
+static uint16_t h264_get_number_of_sps_unit(H264ExtradataContext *s, const uint8_t *extradata, uint8_t *sps_seen)
+{
+    uint16_t unit_nb = *extradata & 0x1f; /* number of sps unit(s) */
+
+    if (unit_nb) {
+        s->sps_offset = 0;
+        *sps_seen = 1;
+    }
+
+    return unit_nb;
+}
+
+static uint16_t h264_get_number_of_pps_unit(H264ExtradataContext *s, const uint8_t *extradata, uint8_t *pps_seen,
+    uint64_t total_size)
+{
+    uint16_t unit_nb = *extradata; /* number of pps unit(s) */
+
+    if (unit_nb) {
+        s->pps_offset = total_size;
+        *pps_seen = 1;
+    }
+
+    return unit_nb;
+}
+
+static int32_t h264_retrieve_sps_and_pps(AVCodecContext *avctx, AVBSFContext *ctx, uint8_t *sps_seen, uint8_t *pps_seen,
+    int32_t *length_size)
+{
+    uint16_t unit_size, unit_nb;
+    uint64_t total_size = 0;
+    uint8_t *out = NULL;
+    uint8_t sps_done = 0;
+    const uint8_t *extradata = ctx->par_in->extradata + 4; // 4: offset
+    static const uint8_t nalu_header[NALU_HEADER_SIZE] = { 0, 0, 0, 1 };
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+    uint8_t temp = *extradata++;
+
+    *length_size = (temp & 0x3) + 1; // retrieve length coded size
+
+    /* retrieve sps and pps unit(s) */
+    unit_nb = h264_get_number_of_sps_unit(s, extradata++, sps_seen);
+    if (!unit_nb && !sps_done++) {
+        unit_nb = h264_get_number_of_pps_unit(s, extradata++, pps_seen, total_size);
+    }
+
+    while (unit_nb--) {
+        int32_t err;
+        unit_size = AV_RB16(extradata);
+        total_size += unit_size + NALU_HEADER_SIZE;
+        err = h264_check_extradata_parameters(avctx, ctx, extradata, total_size + s->padding, out);
+        if (err < 0) {
+            return err;
+        }
+        err = av_reallocp(&out, total_size + s->padding);
+        if (err < 0) {
+            return err;
+        }
+        memcpy(out + total_size - unit_size - NALU_HEADER_SIZE, nalu_header, NALU_HEADER_SIZE);
+        memcpy(out + total_size - unit_size, extradata + 2, unit_size); // 2: 2 offset
+        extradata += 2 + unit_size;
+
+        if (!unit_nb && !sps_done++) {
+            unit_nb = h264_get_number_of_pps_unit(s, extradata++, pps_seen, total_size);
+        }
+    }
+
+    if (out != NULL) {
+        memset(out + total_size, 0, s->padding);
+    }
+
+    s->annexb_buffer = out;
+    s->annexb_buffer_size = total_size;
+
+    return 0;
+}
+
+static int32_t h264_extradata_to_annexb(AVCodecContext *avctx, const int32_t padding)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+    DecodeFilterContext *s2 = &avctx->internal->filter;
+    AVBSFContext *ctx = NULL;
+    int32_t err;
+    int32_t length_size;
+    uint8_t sps_seen = 0;
+    uint8_t pps_seen = 0;
+
+    if (s2->nb_bsfs < 1) {
+        return AVERROR(EINVAL);
+    }
+
+    ctx = s2->bsfs[s2->nb_bsfs - 1];
+    s->sps_offset = -1;
+    s->pps_offset = -1;
+    s->padding = padding;
+
+    err = h264_retrieve_sps_and_pps(avctx, ctx, &sps_seen, &pps_seen, &length_size);
+    if (err < 0) {
+        return err;
+    }
+
+    if (sps_seen == 0) {
+        AV_LOGW("SPS NALU missing or invalid. The resulting stream may not play.");
+    }
+
+    if (pps_seen == 0) {
+        AV_LOGW("PPS NALU missing or invalid. The resulting stream may not play.");
+    }
+
+    return length_size;
+}
+
+int32_t h264_annexb_init(AVCodecContext *avctx)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+    DecodeFilterContext *s2 = &avctx->internal->filter;
+    AVBSFContext *ctx;
+    int32_t extra_size;
+    int32_t ret;
+
+    AV_LOGD("h264_annexb_init");
+
+    if (s2->nb_bsfs < 1) {
+        return AVERROR(EINVAL);
+    }
+    ctx = s2->bsfs[s2->nb_bsfs - 1];
+    extra_size = ctx->par_in->extradata_size;
+
+    /* retrieve sps and pps NAL units from extradata */
+    if (!extra_size || (extra_size >= 3 && AV_RB24(ctx->par_in->extradata) == 1) || // 3: Start stream length
+        (extra_size >= 4 && AV_RB32(ctx->par_in->extradata) == 1)) {                // 4: Start stream length
+        AV_LOGD("The input looks like it is Annex B already");
+        if(extra_size == 0){
+            AV_LOGD("no extradata");
+            return 0;
+        }
+        h264_annexb_get(avctx,ctx);
+    } else if (extra_size >= 6) { // 6: no Start stream length
+        ret = h264_extradata_to_annexb(avctx, AV_INPUT_BUFFER_PADDING_SIZE);
+        if (ret < 0) {
+            return ret;
+        }
+
+        s->length_size = ret;
+        s->new_idr = 1;
+        s->idr_sps_seen = 0;
+        s->idr_pps_seen = 0;
+        s->extradata_parsed = 1;
+    } else {
+        AV_LOGE("Invalid extradata size: %d", extra_size);
+        return AVERROR_INVALIDDATA;
+    }
+
+    return 0;
+}
+
+static int32_t h264_extract_nal_sps_pps(AVCodecContext *avctx, HW_OMX_BUFFERHEADERTYPE *out, uint8_t unit_type,
+    int32_t nal_size, const uint8_t *buf)
+{
+    int32_t ret;
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+
+    if (unit_type == H264_NAL_SPS) {
+        s->idr_sps_seen = s->new_idr = 1;
+    } else if (unit_type == H264_NAL_PPS) {
+        s->idr_pps_seen = s->new_idr = 1;
+        /* if SPS has not been seen yet, prepend the AVCC one to PPS */
+        if (s->idr_sps_seen) {
+            return 0;
+        }
+        if (s->sps_offset == -1) {
+            AV_LOGW("SPS not present in the stream, nor in AVCC, stream may be unreadable");
+        } else {
+            ret = h264_alloc_and_copy(out, s->annexb_buffer + s->sps_offset,
+                s->pps_offset != -1 ? s->pps_offset : s->annexb_buffer_size - s->sps_offset, buf, nal_size, 1);
+            if (ret < 0) {
+                return ret;
+            }
+            s->idr_sps_seen = 1;
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+static int32_t h264_sps_pps_have_been_not_present(H264ExtradataContext *s, HW_OMX_BUFFERHEADERTYPE *out, int32_t nal_size,
+    const uint8_t *buf)
+{
+    int32_t ret;
+
+    ret = h264_alloc_and_copy(out, s->annexb_buffer, s->annexb_buffer_size, buf, nal_size, 1);
+    if (ret < 0) {
+        return ret;
+    }
+    s->new_idr = 0;
+
+    return ret;
+}
+
+static int32_t h264_only_sps_is_seen(AVCodecContext *avctx, H264ExtradataContext *s, HW_OMX_BUFFERHEADERTYPE *out,
+    int32_t nal_size, const uint8_t *buf)
+{
+    int32_t ret;
+
+    if (s->pps_offset == -1) {
+        AV_LOGW("PPS not present in the stream, nor in AVCC, stream may be unreadable");
+        ret = h264_alloc_and_copy(out, NULL, 0, buf, nal_size, 0);
+    } else {
+        ret = h264_alloc_and_copy(out, s->annexb_buffer + s->pps_offset, s->annexb_buffer_size - s->pps_offset, buf,
+            nal_size, 1);
+    }
+
+    return ret;
+}
+
+static int32_t h264_sps_pps_have_been_seen(H264ExtradataContext *s, HW_OMX_BUFFERHEADERTYPE *out, uint8_t unit_type,
+    int32_t nal_size, const uint8_t *buf)
+{
+    int32_t ret;
+
+    ret = h264_alloc_and_copy(out, NULL, 0, buf, nal_size, unit_type == H264_NAL_SPS || unit_type == H264_NAL_PPS);
+    if (ret < 0) {
+        return ret;
+    }
+    if (!s->new_idr && unit_type == H264_NAL_SLICE) {
+        s->new_idr = 1;
+        s->idr_sps_seen = 0;
+        s->idr_pps_seen = 0;
+    }
+
+    return ret;
+}
+
+
+static int32_t h264_extract_nal_idr_slice(AVCodecContext *avctx, HW_OMX_BUFFERHEADERTYPE *out, uint8_t unit_type,
+    int32_t nal_size, const uint8_t *buf)
+{
+    int32_t ret;
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+
+    /* if this is a new IDR picture following an IDR picture, reset the idr flag.
+     * Just check first_mb_in_slice to be 0 as this is the simplest solution.
+     * This could be checking idr_pic_id instead, but would complexify the parsing. */
+    if (!s->new_idr && unit_type == H264_NAL_IDR_SLICE && (buf[1] & 0x80)) {
+        s->new_idr = 1;
+    }
+    /* prepend only to the first type 5 NAL unit of an IDR picture, if no sps/pps are already present */
+    if (s->new_idr && unit_type == H264_NAL_IDR_SLICE && !s->idr_sps_seen && !s->idr_pps_seen) {
+        ret = h264_sps_pps_have_been_not_present(s, out, nal_size, buf);
+        /* if only SPS has been seen, also insert PPS */
+    } else if (s->new_idr && unit_type == H264_NAL_IDR_SLICE && s->idr_sps_seen && !s->idr_pps_seen) {
+        ret = h264_only_sps_is_seen(avctx, s, out, nal_size, buf);
+    } else {
+        ret = h264_sps_pps_have_been_seen(s, out, unit_type, nal_size, buf);
+    }
+
+    return ret;
+}
+
+static int32_t h264_extract_nal_information(AVCodecContext *avctx, HW_OMX_BUFFERHEADERTYPE *out, uint8_t unit_type,
+    int32_t nal_size, const uint8_t *buf)
+{
+    int32_t ret;
+
+    ret = h264_extract_nal_sps_pps(avctx, out, unit_type, nal_size, buf);
+    if (ret == 0) {
+        ret = h264_extract_nal_idr_slice(avctx, out, unit_type, nal_size, buf);
+        if (ret < 0) {
+            return AVERROR(EINVAL);
+        }
+    } else if (ret < 0) {
+        return AVERROR(EINVAL);
+    }
+
+    return ret;
+}
+
+int32_t h264_annexb_filter(AVCodecContext *avctx, const AVPacket *avpkt, HW_OMX_BUFFERHEADERTYPE *out)
+{
+    OMXCodecContext *s1 = avctx->priv_data;
+    H264ExtradataContext *s = &s1->extradata_context.h264;
+
+    const AVPacket *in = avpkt;
+    uint8_t unit_type;
+    int32_t nal_size;
+    uint32_t cumul_size = 0;
+    const uint8_t *buf = NULL;
+    const uint8_t *buf_end = NULL;
+    int32_t buf_size;
+    int32_t ret;
+    int32_t i;
+
+    out->nFilledLen = 0;
+    /* nothing to filter */
+    if (!s->extradata_parsed) {
+        unit_type = h264_annexb_type(avctx, in->data);
+        if(unit_type == H264_NAL_IDR_SLICE){
+            AV_LOGD("unit_type H264_NAL_IDR_SLICE");
+            h264_annexb_copy(avctx,avpkt,out);
+        } else if(unit_type == H264_NAL_AUD){
+            AV_LOGD("unit_type H264_NAL_AUD");
+            h264_annexb_AUD(avctx,avpkt,out);
+        }else{
+            memcpy(out->pBuffer, in->data, in->size);
+            out->nFilledLen = in->size;
+            AV_LOGD("extradata_parased false");
+        }
+        return 0;
+    }
+    buf = in->data;
+    buf_size = in->size;
+    buf_end = in->data + in->size;
+
+    do {
+        if (buf + s->length_size > buf_end) {
+            goto fail;
+        }
+        for (nal_size = 0, i = 0; i < s->length_size; i++) {
+            nal_size = (nal_size << 8) | buf[i];
+        }
+
+        buf += s->length_size;
+        unit_type = *buf & 0x1f;
+
+        if (nal_size > buf_end - buf || nal_size < 0) {
+            goto fail;
+        }
+        ret = h264_extract_nal_information(avctx, out, unit_type, nal_size, buf);
+        if (ret < 0) {
+            goto fail;
+        }
+
+        buf += nal_size;
+        cumul_size += nal_size + s->length_size;
+    } while (cumul_size < buf_size);
+
+fail:
+    return ret >= 0 ? 0 : ret;
+}
Index: ffmpeg/libavcodec/omx_dec_to_annexb.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec_to_annexb.h
@@ -0,0 +1,70 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef HW_OMX_DEC_TO_ANNEXB_H
+#define HW_OMX_DEC_TO_ANNEXB_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+#include <pthread.h>
+#include <stdbool.h>
+
+#include "avcodec.h"
+#include "HW_OMX_Core.h"
+#include "omx_dec_common.h"
+
+typedef struct H264ExtradataContext {
+    int32_t sps_offset;
+    int32_t pps_offset;
+    uint8_t length_size;
+    uint8_t new_idr;
+    uint8_t idr_sps_seen;
+    uint8_t idr_pps_seen;
+    uint8_t *annexb_buffer;
+    int32_t annexb_buffer_size;
+    uint8_t flag;
+    bool extradata_parsed;
+    int32_t padding;
+} H264ExtradataContext;
+
+typedef struct HevcExtradataContext {
+    uint8_t length_size;
+    uint8_t *annexb_buffer;
+    int32_t annexb_buffer_size;
+    uint8_t flag;
+    bool extradata_parsed;
+    bool duplicate_params;
+} HevcExtradataContext;
+
+typedef union ExtradataContext {
+    H264ExtradataContext h264;
+    HevcExtradataContext hevc;
+} ExtradataContext;
+
+int32_t hevc_annexb_init(AVCodecContext *avctx);
+int32_t hevc_annexb_filter(AVCodecContext *avctx, const AVPacket *avpkt, HW_OMX_BUFFERHEADERTYPE *out);
+void h264_annexb_flush(AVCodecContext *avctx);
+int32_t h264_annexb_init(AVCodecContext *avctx);
+int32_t h264_annexb_filter(AVCodecContext *avctx, const AVPacket *avpkt, HW_OMX_BUFFERHEADERTYPE *out);
+
+
+#endif
Index: ffmpeg/libavcodec/omx_dec_wrapper.c
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec_wrapper.c
@@ -0,0 +1,2668 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "omx_dec_wrapper.h"
+#include "avcodec.h"
+#include "decode.h"
+#include "internal.h"
+#include "HW_OMX_Video.h"
+#include "HW_OMX_VideoExt.h"
+#include "HW_OMX_Core.h"
+#include "HW_OMX_Component.h"
+#include "HW_OMX_IndexExt.h"
+
+#include "libavutil/avassert.h"
+#include "libavutil/time.h"
+#include "libavutil/avstring.h"
+#include "libavutil/common.h"
+
+#include "omx_dec_common.h"
+#include "omx_dec_to_annexb.h"
+#include "omx_profile_level.h"
+
+#define DLSYM_BUFFER_LEN 50
+#define DEFAULT_WIDTH 3840
+#define DEFAULT_HEIGHT 2160
+#define RESERVED_SIZE 100
+#define ONE_SECOND_INTERVAL 1000000
+#define MAX_INDICES_TO_CHECK 48
+
+static void *omx_dlsym_prefixed(void *handle, const char *symbol, const char *prefix)
+{
+    char buf[DLSYM_BUFFER_LEN] = {0};
+
+    snprintf(buf, sizeof(buf), "%s%s", prefix ? prefix : "", symbol);
+    return dlsym(handle, buf);
+}
+
+static int32_t omx_try_load(OMXContext *s, AVCodecContext *avctx, const char *libname, const char *prefix)
+{
+    s->lib = dlopen(libname, RTLD_NOW | RTLD_GLOBAL);
+    if (s->lib == NULL) {
+        AV_LOGE("%s not found", libname);
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+
+    s->Init_Func = omx_dlsym_prefixed(s->lib, "OMX_Init", prefix);
+    s->Deinit_Func = omx_dlsym_prefixed(s->lib, "OMX_Deinit", prefix);
+    s->ComponentNameEnum_Func = omx_dlsym_prefixed(s->lib, "OMX_ComponentNameEnum", prefix);
+    s->GetHandle_Func = omx_dlsym_prefixed(s->lib, "OMX_GetHandle", prefix);
+    s->FreeHandle_Func = omx_dlsym_prefixed(s->lib, "OMX_FreeHandle", prefix);
+    s->GetComponentsOfRole_Func = omx_dlsym_prefixed(s->lib, "OMX_GetComponentsOfRole", prefix);
+    s->GetRolesOfComponent_Func = omx_dlsym_prefixed(s->lib, "OMX_GetRolesOfComponent", prefix);
+
+    if (s->Init_Func == NULL || s->Deinit_Func == NULL || s->ComponentNameEnum_Func == NULL ||
+        s->GetHandle_Func == NULL || s->FreeHandle_Func == NULL || s->GetComponentsOfRole_Func == NULL ||
+        s->GetRolesOfComponent_Func == NULL) {
+        AV_LOGE("not all functions found in %s", libname);
+        dlclose(s->lib);
+        s->lib = NULL;
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+
+    return 0;
+}
+
+static int32_t omx_get_context_instance(AVCodecContext *avctx, const char *libname, const char *prefix,
+    OMXContext **omx_context)
+{
+    int32_t ret = -1;
+    const char * const * nameptr = NULL;
+    static const char * const libnames[] = {
+        "libOMX_Core.so",
+        NULL
+    };
+
+    if (libname != NULL) {
+        ret = omx_try_load(*omx_context, avctx, libname, prefix);
+        if (ret < 0) {
+            av_free(*omx_context);
+            AV_LOGE("%s load failed", libname);
+            return ret;
+        }
+    } else {
+        for (nameptr = libnames; *nameptr; nameptr += 1) {
+            if (!omx_try_load(*omx_context, avctx, nameptr[0], prefix)) {
+                break;
+            }
+        }
+        if (*nameptr == NULL) {
+            av_free(*omx_context);
+            AV_LOGE("%s load failed", *nameptr);
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
+static OMXContext *omx_init(AVCodecContext *avctx, const char *libname, const char *prefix)
+{
+    OMXContext *omx_context = NULL;
+    int32_t ret;
+
+    omx_context = av_mallocz(sizeof(*omx_context));
+    if (omx_context == NULL) {
+        AV_LOGE("omx_context is NULL");
+        return NULL;
+    }
+
+    ret = omx_get_context_instance(avctx, libname, prefix, &omx_context);
+    if (ret < 0) {
+        return NULL;
+    }
+
+    if (omx_context->host_init != NULL) {
+        omx_context->host_init();
+    }
+    if (omx_context->Init_Func != NULL) {
+        omx_context->Init_Func();
+    }
+
+    return omx_context;
+}
+
+static void omx_deinit(OMXContext *omx_context)
+{
+    if (omx_context->Deinit_Func != NULL) {
+        omx_context->Deinit_Func();
+    }
+    dlclose(omx_context->lib);
+    av_free(omx_context);
+}
+
+static void omx_append_buffer(OMXPort *port, HW_OMX_BUFFERHEADERTYPE *buffer)
+{
+    pthread_mutex_lock(&port->buffer_lock.lock);
+    port->pending_buffers[port->num_pending_buffers++] = buffer;
+    pthread_cond_broadcast(&port->buffer_cond.cond);
+    pthread_mutex_unlock(&port->buffer_lock.lock);
+}
+
+static HW_OMX_BUFFERHEADERTYPE *omx_get_buffer(AVCodecContext *avctx, OMXPort *port, int32_t wait)
+{
+    struct timespec tv;
+    HW_OMX_BUFFERHEADERTYPE *buffer = NULL;
+    HW_OMX_BUFFERHEADERTYPE **array = port->pending_buffers;
+    OMXCodecContext *s = avctx->priv_data;
+    int32_t *array_size = &port->num_pending_buffers;
+    HW_OMX_ERRORTYPE error = s->error;
+
+    pthread_mutex_lock(&port->buffer_lock.lock);
+    if (wait) {
+        while (!*array_size && error == HW_OMX_ErrorNone) {
+            GET_WAIT_TIME(tv, ONE_SECOND_INTERVAL);
+            pthread_cond_timedwait(&port->buffer_cond.cond, &port->buffer_lock.lock, &tv);
+
+            pthread_mutex_lock(&s->decoder_status_lock.lock);
+            error = s->error;
+            pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        }
+    }
+
+    if (*array_size > 0) {
+        buffer = array[0];
+        (*array_size)--;
+        memmove(&array[0], &array[1], (*array_size) * sizeof(HW_OMX_BUFFERHEADERTYPE *));
+    } else {
+        buffer = NULL;
+    }
+    pthread_mutex_unlock(&port->buffer_lock.lock);
+
+    return buffer;
+}
+
+static void omx_push_event(OMXCodecContext *s, const OMXMessage *msg)
+{
+    pthread_mutex_lock(&s->event_message_lock.lock);
+    push_message(s->avctx, s->event_message_queue, msg);
+    pthread_cond_broadcast(&s->event_message_cond.cond);
+    pthread_mutex_unlock(&s->event_message_lock.lock);
+}
+
+static HW_OMX_ERRORTYPE omx_update_port_definition(AVCodecContext *avctx, OMXPort *port,
+    HW_OMX_PARAM_PORTDEFINITIONTYPE *port_def)
+{
+    HW_OMX_ERRORTYPE err_get;
+    HW_OMX_ERRORTYPE err_set = HW_OMX_ErrorNone;
+    OMXCodecContext *s = avctx->priv_data;
+
+    if (port_def != NULL) {
+        err_set = HW_OMX_SetParameter(s->handle, HW_OMX_IndexParamPortDefinition, port_def);
+        if (err_set != HW_OMX_ErrorNone) {
+            AV_LOGE("updated port %d definition: %s (0x%08x)", port->index, omx_error_to_string(err_set), err_set);
+        }
+    }
+
+    err_get = HW_OMX_GetParameter(s->handle, HW_OMX_IndexParamPortDefinition, &port->port_def);
+    if (err_get != HW_OMX_ErrorNone) {
+        AV_LOGE("updated port %d definition: %s (0x%08x)", port->index, omx_error_to_string(err_get), err_get);
+    }
+
+    if (err_set != HW_OMX_ErrorNone) {
+        return err_set;
+    } else {
+        return err_get;
+    }
+}
+
+static void omx_handle_state_set_event(AVCodecContext *avctx, const OMXEventMessage *msg)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    s->state = msg->Content.StateSet.state;
+
+    AV_LOGD("state change to %s finished", omx_state_to_string(s->state));
+}
+
+static void omx_handle_flush_event(AVCodecContext *avctx, const OMXEventMessage *msg)
+{
+    OMXPort *port = NULL;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_U32 index = msg->Content.Flush.port;
+
+    if (index == HW_OMX_DirInput) {
+        port = &s->input_port;
+    } else {
+        port = &s->output_port;
+    }
+
+    if (port->flushing) {
+        port->flushed = TRUE;
+        AV_LOGD("port %u flush finished", index);
+    } else {
+        AV_LOGD("port %u was not flushing", index);
+    }
+}
+
+static void omx_handle_port_enable_event(AVCodecContext *avctx, const OMXEventMessage *msg)
+{
+    OMXPort *port = NULL;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_U32 index = msg->Content.PortEnable.port;
+    HW_OMX_BOOL enable = msg->Content.PortEnable.enable;
+
+    if (index == HW_OMX_DirInput) {
+        port = &s->input_port;
+    } else {
+        port = &s->output_port;
+    }
+
+    if (enable) {
+        port->enabled_pending = FALSE;
+    } else {
+        port->disabled_pending = FALSE;
+    }
+
+    AV_LOGD("port %u %s", index, (enable ? "enabled" : "disabled"));
+}
+
+static void init_omx_params(HW_OMX_CONFIG_RECTTYPE *params) {
+    memset(params, 0, sizeof(HW_OMX_CONFIG_RECTTYPE));
+    params->nSize = sizeof(HW_OMX_CONFIG_RECTTYPE);
+    params->nVersion.s.nVersionMajor = 1;
+    params->nVersion.s.nVersionMinor = 0;
+    params->nVersion.s.nRevision = 0;
+    params->nVersion.s.nStep = 0;
+}
+
+static void omx_handle_port_settings_changed_event(AVCodecContext *avctx, const OMXEventMessage *msg)
+{
+    OMXPort *port = NULL;
+    OMXCodecContext *s = avctx->priv_data;
+    uint32_t index = msg->Content.PortSettingsChanged.port;
+    uint32_t type = msg->Content.PortSettingsChanged.type;
+
+    if (index == HW_OMX_DirInput) {
+        port = &s->input_port;
+    } else {
+        port = &s->output_port;
+    }
+
+    omx_update_port_definition(avctx, port, NULL);
+
+    if (port->port_def.eDir == HW_OMX_DirOutput && type == HW_OMX_IndexConfigCommonOutputCrop) {
+        HW_OMX_CONFIG_RECTTYPE rect;
+        init_omx_params(&rect);
+        rect.nPortIndex = HW_OMX_DirOutput;
+        HW_OMX_ERRORTYPE err_get = HW_OMX_GetConfig(s->handle, HW_OMX_IndexConfigCommonOutputCrop, &rect);
+        if (err_get != HW_OMX_ErrorNone) {
+            AV_LOGE("updated OutputCropinfo error : %s (0x%08x)", omx_error_to_string(err_get), err_get);
+            if (s->error == HW_OMX_ErrorNone) {
+                s->error = err_get;
+                s->error_status = TRUE;
+            }
+        } else {
+            s->width = rect.nWidth;
+            s->height = rect.nHeight;
+        }
+    }
+
+    if (port->port_def.eDir == HW_OMX_DirOutput && type == HW_OMX_IndexParamPortDefinition) {
+        port->pending_reconfigure_port = TRUE;
+    }
+
+    AV_LOGD("event port %u settings changed", index);
+}
+
+static void omx_handle_buffer_flag_event(AVCodecContext *avctx, const OMXEventMessage *msg)
+{
+    OMXPort *port = NULL;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_U32 index = msg->Content.BufferFlag.port;
+    HW_OMX_U32 flags = msg->Content.BufferFlag.flags;
+
+    if (index == HW_OMX_DirInput) {
+        port = &s->input_port;
+    } else {
+        port = &s->output_port;
+    }
+
+    if ((flags & HW_OMX_BUFFERFLAG_EOS) && port->port_def.eDir == HW_OMX_DirOutput) {
+        port->eos = TRUE;
+    }
+
+    AV_LOGD("handle message buffer flag");
+}
+
+static void omx_handle_error_event(AVCodecContext *avctx, const OMXEventMessage *msg)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_ERRORTYPE error = msg->Content.Error.error;
+
+    if (error == HW_OMX_ErrorNone) {
+        return;
+    }
+
+    if (s->error == HW_OMX_ErrorNone) {
+        s->error = error;
+        s->error_status = TRUE;
+    }
+
+    AV_LOGD("get error: %s (0x%08x)", omx_error_to_string(s->error), s->error);
+}
+
+static void omx_handle_event_message(AVCodecContext *avctx, const OMXMessage *msg)
+{
+    switch (msg->event.type) {
+        case HW_OMX_STATE_SET_EVENT:
+            omx_handle_state_set_event(avctx, &msg->event);
+            break;
+
+        case HW_OMX_FLUSH_EVENT:
+            omx_handle_flush_event(avctx, &msg->event);
+            break;
+
+        case HW_OMX_PORT_ENABLE_EVENT:
+            omx_handle_port_enable_event(avctx, &msg->event);
+            break;
+
+        case HW_OMX_PORT_SETTINGS_CHANGED_EVENT:
+            omx_handle_port_settings_changed_event(avctx, &msg->event);
+            break;
+
+        case HW_OMX_BUFFER_FLAG_EVENT:
+            omx_handle_buffer_flag_event(avctx, &msg->event);
+            break;
+
+        case HW_OMX_ERROR_EVENT:
+            omx_handle_error_event(avctx, &msg->event);
+            break;
+
+        case HW_OMX_BUFFER_DONE_EVENT:
+        default:
+            AV_LOGD("invalid message type");
+            break;
+    }
+}
+
+static void *omx_handle_event_message_thread(void *avctx)
+{
+    struct timespec tv;
+    OMXMessage msg;
+    OMXCodecContext *s = ((AVCodecContext *)avctx)->priv_data;
+    AV_LOGD("omx_handle_event_message_thread start");
+    while (1) {
+        pthread_mutex_lock(&s->event_message_lock.lock);
+        while (is_message_queue_empty(s->event_message_queue) && !s->event_handle_thread_end) {
+            GET_WAIT_TIME(tv, ONE_SECOND_INTERVAL);
+            pthread_cond_timedwait(&s->event_message_cond.cond, &s->event_message_lock.lock, &tv);
+        }
+        pop_message(avctx, s->event_message_queue, &msg);
+        pthread_mutex_unlock(&s->event_message_lock.lock);
+
+        if (s->event_handle_thread_end) {
+            break;
+        }
+
+        pthread_mutex_lock(&s->decoder_status_lock.lock);
+        omx_handle_event_message(avctx, &msg);
+        pthread_cond_broadcast(&s->decoder_status_cond.cond);
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+    }
+
+    AV_LOGD("omx_handle_event_message_thread end");
+    return NULL;
+}
+
+static HW_OMX_ERRORTYPE omx_wait_component_state_finished(AVCodecContext *avctx, HW_OMX_STATETYPE state)
+{
+    struct timespec tv;
+    HW_OMX_ERRORTYPE last_error;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+
+    AV_LOGD("waitting for state: %s", omx_state_to_string(state));
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->state == state && s->error == HW_OMX_ErrorNone) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        err = HW_OMX_ErrorNone;
+        goto done;
+    }
+
+    if (s->error != HW_OMX_ErrorNone) {
+        err = s->error;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("component in error state: %s (0x%08x)", omx_error_to_string(err), err);
+        goto done;
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    last_error = HW_OMX_ErrorNone;
+    AV_LOGD("waiting for state %s", omx_state_to_string(state));
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    while (last_error == HW_OMX_ErrorNone && s->state != state) {
+        GET_WAIT_TIME(tv, ONE_SECOND_INTERVAL);
+        pthread_cond_timedwait(&s->decoder_status_cond.cond, &s->decoder_status_lock.lock, &tv);
+        last_error = s->error;
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    AV_LOGD("waiting for state %s finished", omx_state_to_string(state));
+
+    if (last_error != HW_OMX_ErrorNone) {
+        AV_LOGD("get error while waiting for state %s: %s (0x%08x)", omx_state_to_string(state),
+            omx_error_to_string(err), err);
+        err = last_error;
+    } else {
+        AV_LOGD("state change to %s finished", omx_state_to_string(state));
+    }
+
+done:
+    AV_LOGD("waitting for state %s finshed: %s (0x%08x)", omx_state_to_string(state), omx_error_to_string(err), err);
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_wait_port_flushed(AVCodecContext *avctx, OMXPort *port)
+{
+    struct timespec tv;
+    HW_OMX_ERRORTYPE last_error;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+
+    AV_LOGD("waitting for flushed");
+    omx_update_port_definition(avctx, port, NULL);
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (port->flushed == TRUE && s->error == HW_OMX_ErrorNone) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        err = HW_OMX_ErrorNone;
+        goto done;
+    }
+
+    if (s->error != HW_OMX_ErrorNone) {
+        err = s->error;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("component in error state: %s (0x%08x)", omx_error_to_string(err), err);
+        goto done;
+    }
+
+    last_error = HW_OMX_ErrorNone;
+    while (last_error == HW_OMX_ErrorNone && port->flushed != TRUE) {
+        GET_WAIT_TIME(tv, ONE_SECOND_INTERVAL);
+        pthread_cond_timedwait(&s->decoder_status_cond.cond, &s->decoder_status_lock.lock, &tv);
+        last_error = s->error;
+        omx_update_port_definition(avctx, port, NULL);
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    if (last_error != HW_OMX_ErrorNone) {
+        AV_LOGD("get error while port %d waiting for flushed: %s (0x%08x)", port->index, omx_error_to_string(err), err);
+        err = last_error;
+    } else {
+        AV_LOGD("port %d waiting for flushed finished", port->index);
+    }
+
+    omx_update_port_definition(avctx, port, NULL);
+
+done:
+    AV_LOGD("port %d waiting for flushed: %s (0x%08x)", port->index, omx_error_to_string(err), err);
+
+    return err;
+}
+
+static OMXAcquireBufferState omx_get_buffer_in_reconfiguration_status(AVCodecContext *avctx, OMXPort *port,
+    HW_OMX_BUFFERHEADERTYPE **buffer)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    pthread_mutex_lock(&s->output_port.buffer_lock.lock);
+    if (port->num_pending_buffers != 0) {
+        pthread_mutex_unlock(&s->output_port.buffer_lock.lock);
+        AV_LOGD("output port %d needs reconfiguration but has buffers pending", port->index);
+        *buffer = omx_get_buffer(avctx, port, 0);
+        return HW_OMX_ACQUIRE_BUFFER_OK;
+    }
+    pthread_mutex_unlock(&s->output_port.buffer_lock.lock);
+    AV_LOGD("component port %d needs reconfiguring", port->index);
+    return HW_OMX_ACQUIRE_BUFFER_RECONFIGURE;
+}
+
+static OMXAcquireBufferState omx_get_buffer_in_eos_status(AVCodecContext *avctx, OMXPort *port,
+    HW_OMX_BUFFERHEADERTYPE **buffer)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    pthread_mutex_lock(&s->output_port.buffer_lock.lock);
+    if (port->num_pending_buffers != 0) {
+        pthread_mutex_unlock(&s->output_port.buffer_lock.lock);
+        AV_LOGD("output port %d is EOS but has buffers pending", port->index);
+        *buffer = omx_get_buffer(avctx, port, 0);
+        return HW_OMX_ACQUIRE_BUFFER_OK;
+    }
+    pthread_mutex_unlock(&s->output_port.buffer_lock.lock);
+    AV_LOGD("component port %d signalled EOS", port->index);
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    port->eos = FALSE;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    return HW_OMX_ACQUIRE_BUFFER_EOS;
+}
+
+static OMXAcquireBufferState omx_acquire_port_buffer(AVCodecContext *avctx, OMXPort *port, HW_OMX_BUFFERHEADERTYPE **buf)
+{
+    OMXAcquireBufferState buffer_state = HW_OMX_ACQUIRE_BUFFER_OK;
+    OMXCodecContext *s = avctx->priv_data;
+    bool pending_reconfigure_port = FALSE;
+    bool eos = FALSE;
+    HW_OMX_BUFFERHEADERTYPE *buffer = NULL;
+
+    if (port == NULL || buf == NULL) {
+        AV_LOGE("port acquire buffer error");
+        buffer_state = HW_OMX_ACQUIRE_BUFFER_ERROR;
+        goto done;
+    }
+
+    *buf = NULL;
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->error != HW_OMX_ErrorNone) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("Component is in error state: %s", omx_error_to_string(s->error));
+        buffer_state = HW_OMX_ACQUIRE_BUFFER_ERROR;
+        goto done;
+    }
+
+    if (port->flushing) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGD("Component port %d is flushing", port->index);
+        buffer_state = HW_OMX_ACQUIRE_BUFFER_FLUSHING;
+        goto done;
+    }
+    pending_reconfigure_port = port->pending_reconfigure_port;
+    eos = port->eos;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    if (port->port_def.eDir == HW_OMX_DirOutput && pending_reconfigure_port == TRUE) {
+        buffer_state = omx_get_buffer_in_reconfiguration_status(avctx, port, &buffer);
+        goto done;
+    }
+
+    if (port->port_def.eDir == HW_OMX_DirOutput && eos == TRUE) {
+        buffer_state = omx_get_buffer_in_eos_status(avctx, port, &buffer);
+        goto done;
+    }
+
+    AV_LOGT("port %d has pending buffers: %d", port->index, port->num_pending_buffers);
+
+    if (port->port_def.eDir == HW_OMX_DirInput) {
+        buffer = omx_get_buffer(avctx, port, 1);
+    } else {
+        buffer = omx_get_buffer(avctx, port, 0);
+    }
+
+done:
+    *buf = buffer;
+
+    return buffer_state;
+}
+
+static bool omx_is_port_enabled(AVCodecContext *avctx, OMXPort *port)
+{
+    bool enabled = FALSE;
+
+    omx_update_port_definition(avctx, port, NULL);
+    enabled = port->port_def.bEnabled;
+
+    AV_LOGD("port %d is enabled: %d", port->index, enabled);
+
+    return enabled;
+}
+
+static HW_OMX_ERRORTYPE omx_set_port_enable(AVCodecContext *avctx, OMXPort *port, bool enabled)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_ERRORTYPE err;
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->error != HW_OMX_ErrorNone) {
+        err = s->error;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("component in error state: %s (0x%08x)", omx_error_to_string(err), err);
+        goto done;
+    }
+
+    if (port->enabled_pending || port->disabled_pending) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGD("port %d enabled/disabled pending already", port->index);
+        err = HW_OMX_ErrorInvalidState;
+        goto done;
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+    AV_LOGD("setting port %d to %s", port->index, enabled ? "enabled" : "disabled");
+
+    err = omx_update_port_definition(avctx, port, NULL);
+    if (err != HW_OMX_ErrorNone) {
+        AV_LOGE("omx update port definition error: %s (0x%08x)", omx_error_to_string(err), err);
+        goto done;
+    }
+
+    if (port->port_def.bEnabled == enabled) {
+        goto done;
+    }
+
+    if (enabled) {
+        pthread_mutex_lock(&s->decoder_status_lock.lock);
+        port->enabled_pending = TRUE;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        err = HW_OMX_SendCommand(s->handle, HW_OMX_CommandPortEnable, port->index, NULL);
+    } else {
+        pthread_mutex_lock(&s->decoder_status_lock.lock);
+        port->disabled_pending = TRUE;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        err = HW_OMX_SendCommand(s->handle, HW_OMX_CommandPortDisable, port->index, NULL);
+    }
+
+    if (err != HW_OMX_ErrorNone) {
+        AV_LOGE("failed to send enable/disable command to port %d: %s (0x%08x)", port->index, omx_error_to_string(err),
+            err);
+        goto done;
+    }
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->error != HW_OMX_ErrorNone) {
+        err = s->error;
+        AV_LOGE("component in error state: %s (0x%08x)", omx_error_to_string(err), err);
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+done:
+    omx_update_port_definition(avctx, port, NULL);
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_deallocate_port_buffers(AVCodecContext *avctx, OMXPort *port)
+{
+    int32_t i;
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+    HW_OMX_BUFFERHEADERTYPE *buffer = NULL;
+    OMXCodecContext *s = avctx->priv_data;
+
+    AV_LOGD("deallocating buffers of port %d", port->index);
+
+    if (port->buffer_numbers == 0 || port->buffer_headers == 0) {
+        err = HW_OMX_ErrorUndefined;
+        AV_LOGD("no buffers allocated for port %d", port->index);
+        goto done;
+    }
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->error != HW_OMX_ErrorNone) {
+        err = s->error;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("component in error state: %s (0x%08x)", omx_error_to_string(err), err);
+        goto done;
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    for (i = 0; i < port->buffer_numbers; i++) {
+        buffer = omx_get_buffer(avctx, port, 1);
+        HW_OMX_FreeBuffer(s->handle, port->index, buffer);
+    }
+    port->buffer_numbers = 0;
+done:
+    omx_update_port_definition(avctx, port, NULL);
+    AV_LOGD("deallocate buffers of port %d finished", port->index);
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_wait_port_enable_done(AVCodecContext *avctx, OMXPort *port, bool enabled)
+{
+    struct timespec tv;
+    HW_OMX_ERRORTYPE last_error = HW_OMX_ErrorNone;
+    OMXCodecContext *s = avctx->priv_data;
+
+    omx_update_port_definition(avctx, port, NULL);
+    AV_LOGD("port %d waiting for enabled/disabled", port->index);
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    while (last_error == HW_OMX_ErrorNone &&
+        (port->port_def.bEnabled != enabled || port->enabled_pending || port->disabled_pending)) {
+        GET_WAIT_TIME(tv, ONE_SECOND_INTERVAL);
+        pthread_cond_timedwait(&s->decoder_status_cond.cond, &s->decoder_status_lock.lock, &tv);
+        last_error = s->error;
+        omx_update_port_definition(avctx, port, NULL);
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    AV_LOGD("port %d waiting for enabled/disabled finished", port->index);
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    port->enabled_pending = FALSE;
+    port->disabled_pending = FALSE;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    return last_error;
+}
+
+static bool omx_get_pending_status(OMXPort *port)
+{
+    if (port->enabled_pending) {
+        return TRUE;
+    } else if (port->disabled_pending) {
+        return FALSE;
+    } else {
+        return port->port_def.bEnabled;
+    }
+}
+
+static HW_OMX_ERRORTYPE omx_wait_port_enabled(AVCodecContext *avctx, OMXPort *port)
+{
+    bool enabled = FALSE;
+    HW_OMX_ERRORTYPE last_error;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+
+    AV_LOGD("port %d wait enabled", port->index);
+
+    omx_update_port_definition(avctx, port, NULL);
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    enabled = omx_get_pending_status(port);
+
+    if (s->error != HW_OMX_ErrorNone) {
+        err = s->error;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("component in error state: %s (0x%08x)", omx_error_to_string(err), err);
+        goto done;
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+    AV_LOGD("waiting for port %d to be %s", port->index, enabled ? "enabled" : "disabled");
+
+    last_error = omx_wait_port_enable_done(avctx, port, enabled);
+    if (last_error != HW_OMX_ErrorNone) {
+        err = last_error;
+        AV_LOGD("get error while waiting for port %d to be %s: %s (0x%08x)", port->index,
+            (enabled ? "enabled" : "disabled"), omx_error_to_string(err), err);
+    } else {
+        if (enabled) {
+            pthread_mutex_lock(&s->decoder_status_lock.lock);
+            port->eos = FALSE;
+            pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        }
+    }
+
+done:
+    omx_update_port_definition(avctx, port, NULL);
+    AV_LOGD("port %d is %s%s: %s (0x%08x)", port->index, (err == HW_OMX_ErrorNone ? "" : "not"),
+        (enabled ? "enabled" : "disabled"), omx_error_to_string(err), err);
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_port_enable(AVCodecContext *avctx, OMXPort *port)
+{
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+
+    if (!omx_is_port_enabled(avctx, port)) {
+        err = omx_set_port_enable(avctx, port, TRUE);
+        CHECK_HW_OMX_RET(err, "omx set enable error");
+
+        err = omx_wait_port_enabled(avctx, port);
+        CHECK_HW_OMX_RET(err, "omx wait enable error");
+    }
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_reallocate_port_buffers(AVCodecContext *avctx, OMXPort *port)
+{
+    int32_t i;
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+    pthread_mutex_t *mutex = &port->buffer_lock.lock;
+
+    port->buffer_numbers = port->port_def.nBufferCountActual;
+
+    if (port->buffer_headers != NULL) {
+        av_freep(&port->buffer_headers);
+    }
+    port->buffer_headers = av_mallocz(sizeof(HW_OMX_BUFFERHEADERTYPE *) * port->buffer_numbers);
+
+    if (port->pending_buffers != NULL) {
+        av_freep(&port->pending_buffers);
+    }
+    port->pending_buffers = av_mallocz(sizeof(HW_OMX_BUFFERHEADERTYPE *) * port->buffer_numbers);
+
+    if (port->buffer_headers == NULL || port->pending_buffers == NULL) {
+        return HW_OMX_ErrorUndefined;
+    }
+
+    for (i = 0; i < port->buffer_numbers && err == HW_OMX_ErrorNone; i++) {
+        err = HW_OMX_AllocateBuffer(s->handle, &port->buffer_headers[i], port->index, s, port->port_def.nBufferSize);
+    }
+    port->buffer_numbers = i;
+    CHECK_HW_OMX_RET(err, "omx allocate buffer error");
+
+    err = omx_port_enable(avctx, port);
+    CHECK_HW_OMX_RET(err, "port enable failed");
+
+    if (port->index == s->output_port.index) {
+        for (i = 0; i < port->buffer_numbers && err == HW_OMX_ErrorNone; i++) {
+            err = HW_OMX_FillThisBuffer(s->handle, port->buffer_headers[i]);
+        }
+    }
+    CHECK_HW_OMX_RET(err, "omx fill this buffer error");
+
+    pthread_mutex_lock(mutex);
+    for (; i < port->buffer_numbers; i++) {
+        port->pending_buffers[port->num_pending_buffers++] = port->buffer_headers[i];
+    }
+
+    pthread_mutex_unlock(mutex);
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_update_port_and_reallocate_buffers(AVCodecContext *avctx, OMXPort *port)
+{
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+
+    AV_LOGD("port %d reconfigure", port->index);
+    err = omx_update_port_definition(avctx, port, NULL);
+    CHECK_HW_OMX_RET(err, "update port error");
+
+    AV_LOGD("setting port %d state: format %d, width %u, height %u, nStride %u, nSliceHeight %u, nBufferSize %d",
+        port->index, port->port_def.format.video.eColorFormat, (uint32_t)port->port_def.format.video.nFrameWidth,
+        (uint32_t)port->port_def.format.video.nFrameHeight, (uint32_t)port->port_def.format.video.nStride,
+        (uint32_t)port->port_def.format.video.nSliceHeight, port->port_def.nBufferSize);
+
+    err = omx_reallocate_port_buffers(avctx, port);
+    CHECK_HW_OMX_RET(err, "omx_reallocate_port_buffers error");
+
+    err = omx_update_port_definition(avctx, port, NULL);
+    CHECK_HW_OMX_RET(err, "update port error");
+
+    if (port->index == s->output_port.index) {
+        s->decode_width = port->port_def.format.video.nStride;
+        s->decode_height = port->port_def.format.video.nSliceHeight;
+    }
+    if (s->width != port->port_def.format.video.nFrameWidth || s->height != port->port_def.format.video.nFrameHeight) {
+        s->width = port->port_def.format.video.nFrameWidth;
+        s->height = port->port_def.format.video.nFrameHeight;
+    }
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_reconfigure_port(AVCodecContext *avctx, OMXPort *port)
+{
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+    OMXCodecContext *s = avctx->priv_data;
+
+    AV_LOGD("Port settings have changed");
+    if (omx_is_port_enabled(avctx, port)) {
+        err = omx_set_port_enable(avctx, port, FALSE);
+        if (err != HW_OMX_ErrorNone) {
+            AV_LOGE("omx set enables error: %s (0x%08x)", omx_error_to_string(err), err);
+            goto done;
+        }
+
+        err = omx_deallocate_port_buffers(avctx, port);
+        if (err != HW_OMX_ErrorNone) {
+            AV_LOGE("omx deallocate buffers error: %s (0x%08x)", omx_error_to_string(err), err);
+            goto done;
+        }
+
+        err = omx_wait_port_enabled(avctx, port);
+        if (err != HW_OMX_ErrorNone) {
+            AV_LOGE("omx wait enabled error: %s (0x%08x)", omx_error_to_string(err), err);
+            goto done;
+        }
+    }
+
+    err = omx_update_port_and_reallocate_buffers(avctx, port);
+    if (err != HW_OMX_ErrorNone) {
+        AV_LOGE("omx reconfigure port %d error: %s (0x%08x)", port->index, omx_error_to_string(err), err);
+    }
+
+done:
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    port->pending_reconfigure_port = FALSE;
+    s->reconfiguring = FALSE;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    return err;
+}
+
+static void omx_push_cmd_complete_event(HW_OMX_PTR pAppData, HW_OMX_U32 nData1, HW_OMX_U32 nData2)
+{
+    OMXCodecContext *s = (OMXCodecContext *)pAppData;
+    HW_OMX_COMMANDTYPE cmd = (HW_OMX_COMMANDTYPE)nData1;
+    OMXMessage msg;
+
+    switch (cmd) {
+        case HW_OMX_CommandStateSet: {
+            msg.event.type = HW_OMX_STATE_SET_EVENT;
+            msg.event.Content.StateSet.state = nData2;
+            omx_push_event(s, &msg);
+            break;
+        }
+        case HW_OMX_CommandFlush: {
+            msg.event.type = HW_OMX_FLUSH_EVENT;
+            msg.event.Content.Flush.port = nData2;
+            omx_push_event(s, &msg);
+            break;
+        }
+        case HW_OMX_CommandPortEnable:
+        case HW_OMX_CommandPortDisable: {
+            msg.event.type = HW_OMX_PORT_ENABLE_EVENT;
+            msg.event.Content.PortEnable.port = nData2;
+            msg.event.Content.PortEnable.enable = (cmd == HW_OMX_CommandPortEnable);
+            omx_push_event(s, &msg);
+            break;
+        }
+        default:
+            break;
+    }
+}
+
+static void omx_push_error_event(HW_OMX_PTR pAppData, HW_OMX_U32 nData1)
+{
+    OMXCodecContext *s = (OMXCodecContext *)pAppData;
+    OMXMessage msg;
+
+    msg.event.type = HW_OMX_ERROR_EVENT;
+    msg.event.Content.Error.error = nData1;
+
+    omx_push_event(s, &msg);
+}
+
+static void omx_push_port_settings_changed_event(HW_OMX_PTR pAppData, HW_OMX_U32 nData1, HW_OMX_U32 nData2)
+{
+    OMXCodecContext *s = (OMXCodecContext *)pAppData;
+    OMXMessage msg;
+
+    msg.event.type = HW_OMX_PORT_SETTINGS_CHANGED_EVENT;
+    msg.event.Content.PortSettingsChanged.port = nData1;
+    msg.event.Content.PortSettingsChanged.type = nData2;
+
+    omx_push_event(s, &msg);
+}
+
+static void omx_push_buffer_flag_event(HW_OMX_PTR pAppData, HW_OMX_U32 nData1, HW_OMX_U32 nData2)
+{
+    OMXCodecContext *s = (OMXCodecContext *)pAppData;
+    OMXMessage msg;
+
+    msg.event.type = HW_OMX_BUFFER_FLAG_EVENT;
+    msg.event.Content.BufferFlag.port = nData1;
+    msg.event.Content.BufferFlag.flags = nData2;
+
+    omx_push_event(s, &msg);
+}
+
+static HW_OMX_ERRORTYPE event_handler(HW_OMX_HANDLETYPE hComponent, HW_OMX_PTR pAppData, HW_OMX_EVENTTYPE eEvent, HW_OMX_U32 nData1,
+    HW_OMX_U32 nData2, HW_OMX_PTR pEventData)
+{
+    switch (eEvent) {
+        case HW_OMX_EventCmdComplete: {
+            omx_push_cmd_complete_event(pAppData, nData1, nData2);
+            break;
+        }
+        case HW_OMX_EventError: {
+            omx_push_error_event(pAppData, nData1);
+            break;
+        }
+        case HW_OMX_EventPortSettingsChanged: {
+            omx_push_port_settings_changed_event(pAppData, nData1, nData2);
+            break;
+        }
+        case HW_OMX_EventBufferFlag: {
+            omx_push_buffer_flag_event(pAppData, nData1, nData2);
+            break;
+        }
+        case HW_OMX_EventPortFormatDetected:
+
+        default:
+            break;
+    }
+
+    return HW_OMX_ErrorNone;
+}
+
+static HW_OMX_ERRORTYPE empty_buffer_done(HW_OMX_HANDLETYPE component, HW_OMX_PTR app_data, HW_OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = app_data;
+
+    if (buffer == NULL) {
+        return HW_OMX_ErrorBadParameter;
+    }
+
+    omx_append_buffer(&s->input_port, buffer);
+
+    return HW_OMX_ErrorNone;
+}
+
+static HW_OMX_ERRORTYPE fill_buffer_done(HW_OMX_HANDLETYPE component, HW_OMX_PTR app_data, HW_OMX_BUFFERHEADERTYPE *buffer)
+{
+    OMXCodecContext *s = app_data;
+
+    if (buffer == NULL) {
+        return HW_OMX_ErrorBadParameter;
+    }
+
+    omx_append_buffer(&s->output_port, buffer);
+
+    return HW_OMX_ErrorNone;
+}
+
+static const HW_OMX_CALLBACKTYPE g_callbacks = { event_handler, empty_buffer_done, fill_buffer_done };
+
+static int32_t omx_find_component(OMXContext *omx_context, AVCodecContext *avctx, const char **role, char *str,
+    int32_t str_size)
+{
+    uint32_t num = 0;
+    int32_t ret = 0;
+    OMXCodecContext *s = avctx->priv_data;
+    char **components = NULL;
+
+    str[0] = '\0';
+
+    switch (avctx->codec->id) {
+        case AV_CODEC_ID_MPEG4:
+            *role = "video_decoder.mpeg4";
+            break;
+        case AV_CODEC_ID_H264:
+            *role = "video_decoder.avc";
+            break;
+        case AV_CODEC_ID_HEVC:
+            *role = "video_decoder.hevc";
+            break;
+        case AV_CODEC_ID_MPEG1VIDEO:
+        case AV_CODEC_ID_MPEG2VIDEO:
+            *role = "video_decoder.mpeg2";
+            break;
+        case AV_CODEC_ID_VP9:
+            *role = "video_decoder.vp9";
+            break;
+        default:
+            return AVERROR(ENOSYS);
+    }
+
+    if (omx_context->GetComponentsOfRole_Func == NULL) {
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+    omx_context->GetComponentsOfRole_Func((HW_OMX_STRING)*role, &num, NULL);
+    if (!num) {
+        AV_LOGE("no component for role %s found", *role);
+        return AVERROR_DECODER_NOT_FOUND;
+    }
+
+    components = av_mallocz_array(num, sizeof(*components));
+    CHECK_PARAM_RET(components != NULL, "components is NULL.");
+
+    for (uint32_t i = 0; i < num; i++) {
+        components[i] = av_mallocz(HW_OMX_MAX_STRINGNAME_SIZE);
+        if (components[i] == NULL) {
+            AV_LOGE("components[%u] pointer is NULL", i);
+            ret = AVERROR(ENOMEM);
+            goto end;
+        }
+    }
+
+    omx_context->GetComponentsOfRole_Func((HW_OMX_STRING)*role, &num, (HW_OMX_U8 **)components);
+    av_strlcpy(str, components[0], str_size);
+
+end:
+    for (uint32_t i = 0; i < num; i++) {
+        av_free(components[i]);
+    }
+    av_free(components);
+
+    AV_LOGI("Using %s", s->component_name);
+
+    return ret;
+}
+
+static void omx_port_status_parameters_init(OMXPort *port)
+{
+    port->flushing = FALSE;
+    port->flushed = FALSE;
+    port->enabled_pending = FALSE;
+    port->disabled_pending = FALSE;
+    port->eos = FALSE;
+    port->pending_reconfigure_port = FALSE;
+}
+
+static uint32_t omx_calculate_framerate(AVCodecContext *avctx)
+{
+    uint32_t framerate = 0;
+
+    if (avctx->framerate.den > 0 && avctx->framerate.num > 0) {
+        framerate = (float)avctx->framerate.num / avctx->framerate.den + 0.5;
+    } else {
+        if (avctx->time_base.num != 0) {
+            framerate = (float)avctx->time_base.den / avctx->time_base.num + 0.5;
+        }
+    }
+
+    return framerate * (1UL << 16);
+}
+
+static HW_OMX_ERRORTYPE omx_set_port_record(AVCodecContext *avctx, HW_OMX_PARAM_PORTDEFINITIONTYPE port_params,
+    int32_t port_number)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    if (port_params.eDir == HW_OMX_DirInput && s->input_port.index < 0) {
+        s->input_port.port_def = port_params;
+        s->input_port.index = port_number;
+    } else if (port_params.eDir == HW_OMX_DirOutput && s->output_port.index < 0) {
+        s->output_port.port_def = port_params;
+        s->output_port.index = port_number;
+    } else {
+        AV_LOGE("port undefined");
+        return HW_OMX_ErrorUndefined;
+    }
+
+    return HW_OMX_ErrorNone;
+}
+
+static HW_OMX_ERRORTYPE omx_get_port_definition(AVCodecContext *avctx, HW_OMX_PORT_PARAM_TYPE video_port_params)
+{
+    HW_OMX_ERRORTYPE err;
+    HW_OMX_PARAM_PORTDEFINITIONTYPE port_params = { 0 };
+    OMXCodecContext *s = avctx->priv_data;
+
+    for (int32_t i = 0; i < video_port_params.nPorts; i++) {
+        int32_t port_number = video_port_params.nStartPortNumber + i;
+        port_params.nSize = sizeof(HW_OMX_PARAM_PORTDEFINITIONTYPE);
+        port_params.nVersion = s->version;
+        port_params.nPortIndex = port_number;
+
+        err = HW_OMX_GetParameter(s->handle, HW_OMX_IndexParamPortDefinition, &port_params);
+        CHECK_HW_OMX_RET(err, "HW_OMX_GetParameter faild");
+
+        err = omx_set_port_record(avctx, port_params, port_number);
+        if (err != HW_OMX_ErrorNone) {
+            return err;
+        }
+    }
+
+    return HW_OMX_ErrorNone;
+}
+
+static HW_OMX_ERRORTYPE omx_get_component_default_parameters(AVCodecContext *avctx, const char *role)
+{
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_PORT_PARAM_TYPE video_port_params = { sizeof(HW_OMX_PORT_PARAM_TYPE), s->version, 0, 0 };
+    HW_OMX_PARAM_COMPONENTROLETYPE role_params = { sizeof(HW_OMX_PARAM_COMPONENTROLETYPE), s->version, { 0 } };
+
+    if (s->omx_context->GetHandle_Func == NULL) {
+        return HW_OMX_ErrorBadParameter;
+    }
+    err = s->omx_context->GetHandle_Func(&s->handle, s->component_name, s, (HW_OMX_CALLBACKTYPE *)&g_callbacks);
+    if (err != HW_OMX_ErrorNone) {
+        AV_LOGE("HW_OMX_GetHandle(%s) failed: %x", s->component_name, err);
+        return err;
+    }
+
+    av_strlcpy(role_params.cRole, role, sizeof(role_params.cRole));
+    err = HW_OMX_SetParameter(s->handle, HW_OMX_IndexParamStandardComponentRole, &role_params);
+    CHECK_HW_OMX_RET(err, "HW_OMX_SetParameter faild");
+
+    err = HW_OMX_GetParameter(s->handle, HW_OMX_IndexParamVideoInit, &video_port_params);
+    if (err != HW_OMX_ErrorNone) {
+        AV_LOGW("omx get parameter error: %s (0x%08x)", omx_error_to_string(err), err);
+    }
+
+    s->input_port.index = -1;
+    s->output_port.index = -1;
+
+    err = omx_get_port_definition(avctx, video_port_params);
+    if (err != HW_OMX_ErrorNone) {
+        AV_LOGE("omx_get_port_definition failed");
+        return err;
+    }
+
+    if (s->input_port.index < 0 || s->output_port.index < 0) {
+        AV_LOGE("No in or out port found (in %d out %d)", s->input_port.index, s->output_port.index);
+        return HW_OMX_ErrorUndefined;
+    }
+
+    return HW_OMX_ErrorNone;
+}
+
+static HW_OMX_ERRORTYPE omx_set_input_port_format(AVCodecContext *avctx)
+{
+    HW_OMX_ERRORTYPE err;
+    HW_OMX_VIDEO_PARAM_PORTFORMATTYPE video_port_format = { 0 };
+    OMXCodecContext *s = avctx->priv_data;
+
+    video_port_format.nSize = sizeof(HW_OMX_VIDEO_PARAM_PORTFORMATTYPE);
+    video_port_format.nVersion = s->version;
+    video_port_format.nIndex = 0;
+    video_port_format.nPortIndex = s->input_port.index;
+
+    err = HW_OMX_GetParameter(s->handle, HW_OMX_IndexParamVideoPortFormat, &video_port_format);
+    CHECK_HW_OMX_RET(err, "HW_OMX_GetParameter failed");
+
+    switch (avctx->codec->id) {
+        case AV_CODEC_ID_H264:
+            s->input_port.compression_format = HW_OMX_VIDEO_CodingAVC;
+            break;
+        case AV_CODEC_ID_MPEG4:
+            s->input_port.compression_format = HW_OMX_VIDEO_CodingMPEG4;
+            break;
+        case AV_CODEC_ID_HEVC:
+            s->input_port.compression_format = HW_OMX_VIDEO_CodingHEVC;
+            break;
+        case AV_CODEC_ID_VP9:
+            s->input_port.compression_format = HW_OMX_VIDEO_CodingVP9;
+            break;
+        case AV_CODEC_ID_MPEG1VIDEO:
+        case AV_CODEC_ID_MPEG2VIDEO:
+            s->input_port.compression_format = HW_OMX_VIDEO_CodingMPEG2;
+            break;
+        default:
+            s->input_port.compression_format = HW_OMX_VIDEO_CodingUnused;
+            AV_LOGE("encoding format is not supported");
+            break;
+    }
+
+    s->input_port.color_format = HW_OMX_COLOR_FormatUnused;
+    video_port_format.eCompressionFormat = s->input_port.compression_format;
+    video_port_format.eColorFormat = s->input_port.color_format;
+    err = HW_OMX_SetParameter(s->handle, HW_OMX_IndexParamVideoPortFormat, &video_port_format);
+    CHECK_HW_OMX_RET(err, "HW_OMX_SetParameter failed");
+
+    return HW_OMX_ErrorNone;
+}
+
+static HW_OMX_ERRORTYPE omx_set_output_port_format(AVCodecContext *avctx)
+{
+    HW_OMX_ERRORTYPE err;
+    HW_OMX_VIDEO_PARAM_PORTFORMATTYPE video_port_format = { 0 };
+    OMXCodecContext *s = avctx->priv_data;
+
+    video_port_format.nSize = sizeof(HW_OMX_VIDEO_PARAM_PORTFORMATTYPE);
+    video_port_format.nVersion = s->version;
+    video_port_format.nIndex = 0;
+    video_port_format.nPortIndex = s->output_port.index;
+
+    err = HW_OMX_GetParameter(s->handle, HW_OMX_IndexParamVideoPortFormat, &video_port_format);
+    CHECK_HW_OMX_RET(err, "HW_OMX_GetParameter failed");
+
+    s->output_port.color_format = HW_OMX_COLOR_FormatYUV420SemiPlanar;
+    s->output_port.compression_format = HW_OMX_VIDEO_CodingUnused;
+    video_port_format.eColorFormat = s->output_port.color_format;
+    video_port_format.eCompressionFormat = s->output_port.compression_format;
+    err = HW_OMX_SetParameter(s->handle, HW_OMX_IndexParamVideoPortFormat, &video_port_format);
+    CHECK_HW_OMX_RET(err, "HW_OMX_SetParameter failed");
+
+    return HW_OMX_ErrorNone;
+}
+
+static HW_OMX_ERRORTYPE omx_set_port_definition(AVCodecContext *avctx, OMXPort *port)
+{
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+
+    omx_update_port_definition(avctx, port, NULL);
+
+    port->port_def.format.video.nFrameWidth = s->width;
+    port->port_def.format.video.nFrameHeight = s->height;
+    port->port_def.format.video.eCompressionFormat = port->compression_format;
+    port->port_def.format.video.eColorFormat = port->color_format;
+
+    if (port->port_def.eDir == HW_OMX_DirInput) {
+        port->port_def.format.video.xFramerate = omx_calculate_framerate(avctx);
+        if (port->port_def.format.video.xFramerate == 0) {
+            AV_LOGW("framerate is unknow");
+        }
+    }
+
+    err = omx_update_port_definition(avctx, port, &port->port_def);
+    CHECK_HW_OMX_RET(err, "omx_update_port_definition failed");
+
+    omx_update_port_definition(avctx, port, NULL);
+
+    s->stride = port->port_def.format.video.nStride;
+    s->plane_size = port->port_def.format.video.nSliceHeight;
+    s->framerate = port->port_def.format.video.xFramerate;
+    port->buffer_numbers = port->port_def.nBufferCountActual;
+
+    omx_port_status_parameters_init(port);
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_set_component_framerate(AVCodecContext *avctx, OMXPort *port)
+{
+    uint32_t framerate;
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+    HW_OMX_PARAM_U32TYPE config_data = { 0 };
+    OMXCodecContext *s = avctx->priv_data;
+
+    framerate = omx_calculate_framerate(avctx);
+    if (framerate == s->framerate) {
+        return err;
+    }
+
+    if (framerate == 0) {
+        AV_LOGW("framerate is unknow");
+        return err;
+    } else {
+        AV_LOGD("framerate is %u", framerate);
+    }
+
+    config_data.nPortIndex = port->index;
+    config_data.nU32 = framerate;
+    config_data.nSize = sizeof(config_data);
+
+    err = HW_OMX_SetConfig(s->handle, HW_OMX_IndexConfigOperatingRate, &config_data);
+    CHECK_HW_OMX_RET(err, "HW_OMX_SetConfig failed");
+
+    s->framerate = framerate;
+
+    return err;
+}
+
+static void omx_check_decoder_support_for_10bit(AVCodecContext *avctx, HW_OMX_VIDEO_PARAM_PROFILELEVELTYPE* video_params)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    if ((avctx->codec->id == AV_CODEC_ID_H264 && video_params->eProfile == HW_OMX_VIDEO_AVCProfileHigh10) ||
+        (avctx->codec->id == AV_CODEC_ID_HEVC && video_params->eProfile == HW_OMX_VIDEO_HEVCProfileMain10) ||
+        (avctx->codec->id == AV_CODEC_ID_VP9 && (video_params->eProfile == HW_OMX_VIDEO_VP9Profile2 ||
+        video_params->eProfile == HW_OMX_VIDEO_VP9Profile3))) {
+        s->dec_10bit_supported = TRUE;
+    }
+}
+
+static bool omx_is_10bit_video(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    if ((avctx->codec->id == AV_CODEC_ID_H264 && avctx->profile == HW_OMX_VIDEO_AVCProfileHigh10) ||
+        (avctx->codec->id == AV_CODEC_ID_HEVC && avctx->profile == HW_OMX_VIDEO_HEVCProfileMain10) ||
+        (avctx->codec->id == AV_CODEC_ID_VP9 && avctx->profile == FF_PROFILE_VP9_2) ||
+        (avctx->codec->id == AV_CODEC_ID_VP9 && avctx->profile == FF_PROFILE_VP9_3)) {
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static HW_OMX_ERRORTYPE omx_verify_support_for_profile_and_level(AVCodecContext *avctx)
+{
+    HW_OMX_ERRORTYPE err;
+    HW_OMX_VIDEO_PARAM_PROFILELEVELTYPE video_params = { 0 };
+    OMXCodecContext *s = avctx->priv_data;
+
+    omx_get_profile_and_level(avctx);
+
+    video_params.nSize = sizeof(HW_OMX_VIDEO_PARAM_PROFILELEVELTYPE);
+    video_params.nVersion = s->version;
+    video_params.nPortIndex = s->input_port.index;
+
+    for (int32_t index = 0; index <= MAX_INDICES_TO_CHECK; ++index) {
+        video_params.nProfileIndex = index;
+        err = HW_OMX_GetParameter(s->handle, HW_OMX_IndexParamVideoProfileLevelQuerySupported, &video_params);
+        if (err == HW_OMX_ErrorNoMore) {
+            break;
+        } else if (err != HW_OMX_ErrorNone) {
+            AV_LOGE("HW_OMX_GetParameter failed: %s (0x%08x)", omx_error_to_string(err), err);
+            return err;
+        }
+        omx_check_decoder_support_for_10bit(avctx, &video_params);
+        if (s->omx_profile == (int32_t)video_params.eProfile && s->omx_level <= (int32_t)video_params.eLevel) {
+            AV_LOGI("video profile is %u, level is %u", video_params.eProfile, video_params.eLevel);
+            break;
+        }
+    }
+
+    if (err == HW_OMX_ErrorNoMore) {
+        if (s->dec_10bit_supported == FALSE && omx_is_10bit_video(avctx)) {
+            AV_LOGE("10 bit not supported by component");
+            return HW_OMX_ErrorUndefined;
+        } else {
+            AV_LOGW("setting profile(%d) and level(%d) not supported by component", s->omx_profile, s->omx_level);
+        }
+    }
+
+    return HW_OMX_ErrorNone;
+}
+
+static HW_OMX_ERRORTYPE omx_allocate_port_buffers(AVCodecContext *avctx, OMXPort *port)
+{
+    int32_t i;
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+    OMXCodecContext *s = avctx->priv_data;
+
+    port->buffer_headers = av_mallocz(sizeof(HW_OMX_BUFFERHEADERTYPE *) * port->buffer_numbers);
+    port->pending_buffers = av_mallocz(sizeof(HW_OMX_BUFFERHEADERTYPE *) * port->buffer_numbers);
+    if (port->buffer_headers == NULL || port->pending_buffers == NULL) {
+        return HW_OMX_ErrorUndefined;
+    }
+
+    for (i = 0; i < port->buffer_numbers && err == HW_OMX_ErrorNone; i++) {
+        err = HW_OMX_AllocateBuffer(s->handle, &port->buffer_headers[i], port->index, s, port->port_def.nBufferSize);
+        if (port->port_def.eDir == HW_OMX_DirInput && err == HW_OMX_ErrorNone) {
+            port->buffer_headers[i]->pAppPrivate = NULL;
+            port->buffer_headers[i]->pOutputPortPrivate = NULL;
+        }
+    }
+
+    port->buffer_numbers = i;
+    CHECK_HW_OMX_RET(err, "HW_OMX_AllocateBuffer failed");
+
+    return err;
+}
+
+static void omx_port_pending_buffers_init(AVCodecContext *avctx, OMXPort *port)
+{
+    int32_t i = 0;
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+    OMXCodecContext *s = avctx->priv_data;
+
+    port->num_pending_buffers = 0;
+    if (port->port_def.eDir == HW_OMX_DirOutput) {
+        for (i = 0; i < port->buffer_numbers && err == HW_OMX_ErrorNone; i++) {
+            err = HW_OMX_FillThisBuffer(s->handle, port->buffer_headers[i]);
+            if (err != HW_OMX_ErrorNone) {
+                AV_LOGE("HW_OMX_FillThisBuffer is in error state: %s (0x%08x)", omx_error_to_string(err), err);
+            }
+        }
+    }
+
+    for (; i < port->buffer_numbers; i++) {
+        port->pending_buffers[port->num_pending_buffers++] = port->buffer_headers[i];
+    }
+}
+
+static int32_t omx_component_init(AVCodecContext *avctx, const char *role)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_ERRORTYPE err;
+
+    err = omx_get_component_default_parameters(avctx, role);
+    CHECK_HW_OMX_RET(err, "get port default parameters error");
+
+    err = omx_set_input_port_format(avctx);
+    CHECK_HW_OMX_RET(err, "set input port format error");
+
+    err = omx_set_output_port_format(avctx);
+    CHECK_HW_OMX_RET(err, "set output port format error");
+
+    err = omx_set_port_definition(avctx, &s->input_port);
+    CHECK_HW_OMX_RET(err, "input port definition error");
+
+    err = omx_set_port_definition(avctx, &s->output_port);
+    CHECK_HW_OMX_RET(err, "output port definition error");
+
+    err = omx_set_component_framerate(avctx, &s->input_port);
+    CHECK_HW_OMX_RET(err, "set component framerate error");
+
+    err = omx_verify_support_for_profile_and_level(avctx);
+    CHECK_HW_OMX_RET(err, "verify support for profile and level error");
+
+    err = HW_OMX_SendCommand(s->handle, HW_OMX_CommandStateSet, HW_OMX_StateIdle, NULL);
+    CHECK_HW_OMX_RET(err, "omx send command error");
+
+    err = omx_allocate_port_buffers(avctx, &s->input_port);
+    CHECK_HW_OMX_RET(err, "input port allocate buffer error");
+
+    err = omx_allocate_port_buffers(avctx, &s->output_port);
+    CHECK_HW_OMX_RET(err, "output port allocate buffer error");
+
+    err = omx_wait_component_state_finished(avctx, HW_OMX_StateIdle);
+    CHECK_HW_OMX_RET(err, "component wait state Idle error");
+
+    err = HW_OMX_SendCommand(s->handle, HW_OMX_CommandStateSet, HW_OMX_StateExecuting, NULL);
+    CHECK_HW_OMX_RET(err, "omx send command error");
+
+    err = omx_wait_component_state_finished(avctx, HW_OMX_StateExecuting);
+    CHECK_HW_OMX_RET(err, "component wait state Executing error");
+
+    omx_port_pending_buffers_init(avctx, &s->input_port);
+    omx_port_pending_buffers_init(avctx, &s->output_port);
+
+    AV_LOGD("component init successfully");
+
+    return HW_OMX_ErrorNone;
+}
+
+static int32_t omx_message_queue_init(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    s->event_message_queue = av_malloc(sizeof(OmxMessageQueue));
+    s->frame_message_queue = av_malloc(sizeof(OmxMessageQueue));
+    if (s->event_message_queue == NULL || s->frame_message_queue == NULL) {
+        return AVERROR(ENOMEM);
+    }
+
+    initialize_message_queue(s->event_message_queue);
+    initialize_message_queue(s->frame_message_queue);
+
+    s->event_message_lock.is_init = FALSE;
+    s->decoder_status_lock.is_init = FALSE;
+    s->frame_message_lock.is_init = FALSE;
+
+    CHECK_MUTEX_RET(mutexlock_init(avctx, &s->event_message_lock));
+    CHECK_MUTEX_RET(mutexlock_init(avctx, &s->decoder_status_lock));
+    CHECK_MUTEX_RET(mutexlock_init(avctx, &s->frame_message_lock));
+
+    s->event_message_cond.is_init = FALSE;
+    s->decoder_status_cond.is_init = FALSE;
+
+    CHECK_MUTEX_RET(mutexcond_init(avctx, &s->event_message_cond));
+    CHECK_MUTEX_RET(mutexcond_init(avctx, &s->decoder_status_cond));
+
+    return 0;
+}
+
+static int32_t omx_input_port_init(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    s->packet_sended = 0;
+    s->input_port.buffer_headers = NULL;
+    s->input_port.pending_buffers = NULL;
+    s->input_port.buffer_lock.is_init = FALSE;
+    s->input_port.buffer_cond.is_init = FALSE;
+
+    CHECK_MUTEX_RET(mutexlock_init(avctx, &s->input_port.buffer_lock));
+    CHECK_MUTEX_RET(mutexcond_init(avctx, &s->input_port.buffer_cond));
+
+    return 0;
+}
+
+static int32_t omx_output_port_init(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    s->frame_received = 0;
+    s->output_port.buffer_headers = NULL;
+    s->output_port.pending_buffers = NULL;
+    s->output_port.buffer_lock.is_init = FALSE;
+    s->output_port.buffer_cond.is_init = FALSE;
+
+    CHECK_MUTEX_RET(mutexlock_init(avctx, &s->output_port.buffer_lock));
+    CHECK_MUTEX_RET(mutexcond_init(avctx, &s->output_port.buffer_cond));
+
+    return 0;
+}
+
+static int32_t omx_context_init(AVCodecContext *avctx)
+{
+    int32_t ret;
+    OMXCodecContext *s = avctx->priv_data;
+    s->avctx = avctx;
+    s->need_release = TRUE;
+    s->state = HW_OMX_StateLoaded;
+    s->error = HW_OMX_ErrorNone;
+    s->eos_sent = 0;
+    s->eos_flag = 0;
+    s->reconfiguring = FALSE;
+    s->flushing = FALSE;
+    s->error_status = FALSE;
+    s->abnormal_status = FALSE;
+    s->abnormal_time = 0;
+    s->last_packet_time = 0;
+
+    s->width = avctx->width ? avctx->width : DEFAULT_WIDTH;
+    s->height = avctx->height ? avctx->height : DEFAULT_HEIGHT;
+    s->decode_width = s->width;
+    s->decode_height = s->height;
+    s->framerate = 0;
+    s->dec_10bit_supported = FALSE;
+    s->packet_num = 0;
+    s->thread_end = FALSE;
+    s->event_handle_thread_end = FALSE;
+    s->packet_received = FALSE;
+    memset(&s->extradata_context, 0, sizeof(ExtradataContext));
+    memset(&s->packet_sended_queue, 0, MAX_PACKET_LIST_LEN * sizeof(OMXPacketParam));
+
+    s->flushing_lock.is_init = FALSE;
+    CHECK_MUTEX_RET(mutexlock_init(avctx, &s->flushing_lock));
+
+    ret = omx_message_queue_init(avctx);
+    if (ret < 0) {
+        AV_LOGE("omx_message_queue_init failed");
+        return ret;
+    }
+
+    ret = omx_input_port_init(avctx);
+    if (ret < 0) {
+        AV_LOGE("omx_input_port_init failed");
+        return ret;
+    }
+
+    ret = omx_output_port_init(avctx);
+    if (ret < 0) {
+        AV_LOGE("omx_output_port_init failed");
+        return ret;
+    }
+
+    if (avctx->sw_pix_fmt == -1) {
+        avctx->sw_pix_fmt = AV_PIX_FMT_NV12;
+    }
+
+    return 0;
+}
+
+static void omx_release_buffer(void *opaque, uint8_t *data)
+{
+    av_buffer_default_free(opaque, data);
+}
+
+static HW_OMX_ERRORTYPE omx_pause_component(AVCodecContext *avctx)
+{
+    HW_OMX_ERRORTYPE err = HW_OMX_ErrorNone;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_STATETYPE state;
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->error != HW_OMX_ErrorNone) {
+        err = s->error;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("Component in error state: %s (0x%08x)", omx_error_to_string(err), err);
+        return err;
+    }
+    state = s->state;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    if (state == HW_OMX_StateExecuting) {
+        err = HW_OMX_SendCommand(s->handle, HW_OMX_CommandStateSet, HW_OMX_StatePause, NULL);
+        CHECK_HW_OMX_RET(err, "send command error");
+
+        err = omx_wait_component_state_finished(avctx, HW_OMX_StatePause);
+        if (err != HW_OMX_ErrorNone) {
+            AV_LOGE("wait state %s error: %s (0x%08x)", omx_state_to_string(HW_OMX_StatePause), omx_error_to_string(err),
+                err);
+            return err;
+        }
+    }
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_flush_port(AVCodecContext *avctx, OMXPort *port)
+{
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->error != HW_OMX_ErrorNone) {
+        err = s->error;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("Component in error state: %s (0x%08x)", omx_error_to_string(err), err);
+        return err;
+    }
+    port->flushing = TRUE;
+    port->flushed = FALSE;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    err = HW_OMX_SendCommand(s->handle, HW_OMX_CommandFlush, port->index, NULL);
+    CHECK_HW_OMX_RET(err, "omx send command error");
+
+    err = omx_wait_port_flushed(avctx, port);
+    CHECK_HW_OMX_RET(err, "wait flush error");
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    port->flushing = FALSE;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    return err;
+}
+
+static HW_OMX_ERRORTYPE omx_resume_component(AVCodecContext *avctx)
+{
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    err = s->error;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    CHECK_HW_OMX_RET(err, "component in error state");
+
+
+    err = HW_OMX_SendCommand(s->handle, HW_OMX_CommandStateSet, HW_OMX_StateExecuting, NULL);
+    CHECK_HW_OMX_RET(err, "HW_OMX_SendCommand failed");
+
+    err = omx_wait_component_state_finished(avctx, HW_OMX_StateExecuting);
+    if (err != HW_OMX_ErrorNone) {
+        AV_LOGE("wait state %s error: %s (0x%08x)", omx_state_to_string(HW_OMX_StateExecuting), omx_error_to_string(err),
+            err);
+        return err;
+    }
+
+    return err;
+}
+static void omx_free_frame_message_queue(AVCodecContext *avctx, OmxMessageQueue *queue)
+{
+    OMXMessage msg;
+    OMXCodecContext *s = avctx->priv_data;
+
+    if (s->frame_message_lock.is_init == FALSE) {
+        return;
+    }
+
+    pthread_mutex_lock(&s->frame_message_lock.lock);
+    while (!is_message_queue_empty(queue)) {
+        pop_message(avctx, queue, &msg);
+        av_buffer_unref(&msg.frame.data.buf[0]);
+        av_buffer_unref(&msg.frame.data.buf[1]);
+    }
+    pthread_mutex_unlock(&s->frame_message_lock.lock);
+}
+
+static HW_OMX_ERRORTYPE omx_clean_pending_buffers(AVCodecContext *avctx)
+{
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_BUFFERHEADERTYPE *buffer = NULL;
+
+    pthread_mutex_lock(&s->flushing_lock.lock);
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    err = s->error;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    CHECK_HW_OMX_RET(err, "component in error state");
+
+    while (1) {
+        buffer = omx_get_buffer(avctx, &s->output_port, 0);
+        if (buffer == NULL) {
+            break;
+        }
+
+        buffer->nFlags = 0;
+        err = HW_OMX_FillThisBuffer(s->handle, buffer);
+        if (err != HW_OMX_ErrorNone) {
+            pthread_mutex_unlock(&s->flushing_lock.lock);
+            omx_append_buffer(&s->output_port, buffer);
+            AV_LOGE("fill this buffer failed: %s (0x%08x)", omx_error_to_string(err), err);
+            return err;
+        }
+    }
+
+    omx_free_frame_message_queue(avctx, s->frame_message_queue);
+    memset(&s->packet_sended_queue, 0, MAX_PACKET_LIST_LEN * sizeof(OMXPacketParam));
+    pthread_mutex_unlock(&s->flushing_lock.lock);
+    return err;
+}
+
+static void omx_stream_conversion(AVCodecContext *avctx, const AVPacket *avpkt, HW_OMX_BUFFERHEADERTYPE *buffer,
+    OMXCodecContext *s)
+{
+    if (avctx->codec->id == AV_CODEC_ID_H264) {
+        if (s->extradata_context.h264.flag == 0) {
+            s->extradata_context.h264.flag = 1;
+            h264_annexb_init(avctx);
+        }
+        h264_annexb_filter(avctx, avpkt, buffer);
+    } else if (avctx->codec->id == AV_CODEC_ID_HEVC) {
+        if (s->extradata_context.hevc.flag == 0) {
+            s->extradata_context.hevc.flag = 1;
+            hevc_annexb_init(avctx);
+        }
+        hevc_annexb_filter(avctx, avpkt, buffer);
+    } else if (avctx->codec->id == AV_CODEC_ID_MPEG4 ||
+               avctx->codec->id == AV_CODEC_ID_MPEG1VIDEO ||
+               avctx->codec->id == AV_CODEC_ID_MPEG2VIDEO) {
+        if (s->packet_num == 1) {
+            memcpy(buffer->pBuffer, avctx->extradata, avctx->extradata_size);
+            memcpy(buffer->pBuffer + avctx->extradata_size, avpkt->data, avpkt->size);
+            buffer->nFilledLen = avpkt->size + avctx->extradata_size;
+        } else {
+            memcpy(buffer->pBuffer, avpkt->data, avpkt->size);
+            buffer->nFilledLen = avpkt->size;
+        }
+    } else if (avctx->codec->id == AV_CODEC_ID_VP9) {
+        memcpy(buffer->pBuffer, avctx->extradata, avctx->extradata_size);
+        memcpy(buffer->pBuffer + avctx->extradata_size, avpkt->data, avpkt->size);
+        buffer->nFilledLen = avpkt->size + avctx->extradata_size;
+    } else {
+        AV_LOGE("encoding format is not supported");
+    }
+}
+
+static int32_t omx_get_packet_and_fill_buffer(AVCodecContext *avctx, const AVPacket *avpkt)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_ERRORTYPE err;
+
+    HW_OMX_BUFFERHEADERTYPE *buffer = omx_get_buffer(avctx, &s->input_port, 1);
+
+    if (avpkt->size + avctx->extradata_size > buffer->nAllocLen - RESERVED_SIZE) {
+        omx_append_buffer(&s->input_port, buffer);
+        AV_LOGD("avpkt size beyond input port buffer size: %d", avpkt->size);
+        return 0;
+    }
+
+    omx_stream_conversion(avctx, avpkt, buffer, s);
+    buffer->nTimeStamp = avpkt->pts;
+    err = HW_OMX_EmptyThisBuffer(s->handle, buffer);
+    if (err != HW_OMX_ErrorNone) {
+        omx_append_buffer(&s->input_port, buffer);
+        AV_LOGE("HW_OMX_EmptyThisBuffer failed: %s (0x%08x)", omx_error_to_string(err), err);
+        return AVERROR_UNKNOWN;
+    }
+
+    if (!s->packet_sended) {
+        s->packet_sended = 1;
+    }
+
+    return 0;
+}
+
+static int32_t omx_send_eos_flag(AVCodecContext *avctx)
+{
+    HW_OMX_BUFFERHEADERTYPE *buffer;
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+
+    buffer = omx_get_buffer(avctx, &s->input_port, 1);
+
+    buffer->nFilledLen = 0;
+    buffer->nFlags = HW_OMX_BUFFERFLAG_EOS;
+    buffer->pAppPrivate = buffer->pOutputPortPrivate = NULL;
+
+    err = HW_OMX_EmptyThisBuffer(s->handle, buffer);
+    if (err != HW_OMX_ErrorNone) {
+        omx_append_buffer(&s->input_port, buffer);
+        AV_LOGE("HW_OMX_EmptyThisBuffer failed: %s (0x%08x)", omx_error_to_string(err), err);
+        return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+static void omx_push_packet_parameters(AVCodecContext *avctx, const AVPacket *pkt)
+{
+    int i;
+    OMXCodecContext *s = avctx->priv_data;
+
+    if (pkt->pts == AV_NOPTS_VALUE) {
+        return;
+    }
+    for (i = 0; i < MAX_PACKET_LIST_LEN; i++) {
+        if (s->packet_sended_queue[i].flag == 0) {
+            s->packet_sended_queue[i].dts = pkt->dts;
+            s->packet_sended_queue[i].pts = pkt->pts;
+            s->packet_sended_queue[i].pos = pkt->pos;
+            s->packet_sended_queue[i].duration = pkt->duration;
+            s->packet_sended_queue[i].size = pkt->size;
+            s->packet_sended_queue[i].flag = TRUE;
+            break;
+        }
+    }
+
+    if (i == MAX_PACKET_LIST_LEN) {
+        AV_LOGW("packet_sended_queue is full");
+    }
+}
+
+static OMXPacketParam omx_pop_packet_parameters(AVCodecContext *avctx, int64_t pts)
+{
+    int i;
+    OMXCodecContext *s = avctx->priv_data;
+    OMXPacketParam param = { 0 };
+
+    if (pts == AV_NOPTS_VALUE) {
+        return param;
+    }
+
+    for (i = 0; i < MAX_PACKET_LIST_LEN; i++) {
+        if (s->packet_sended_queue[i].flag == TRUE && s->packet_sended_queue[i].pts == pts) {
+            param = s->packet_sended_queue[i];
+            s->packet_sended_queue[i].flag = FALSE;
+        } else if (s->packet_sended_queue[i].flag == TRUE && s->packet_sended_queue[i].pts < pts) {
+            s->packet_sended_queue[i].flag = FALSE;
+        }
+    }
+
+    if (i == MAX_PACKET_LIST_LEN && param.flag == 0) {
+        AV_LOGW("pts %ld packet not found", pts);
+    }
+
+    return param;
+}
+
+static int32_t omx_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
+{
+    int32_t ret;
+    OMXCodecContext *s = avctx->priv_data;
+
+    AV_LOGT("port 0 has pending buffers: %d", s->input_port.num_pending_buffers);
+
+    if (s->packet_received == FALSE) {
+        return 0;
+    }
+
+    if (s->flushing == TRUE) {
+        s->flushing = FALSE;
+    }
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (!s->input_port.num_pending_buffers || s->error_status == TRUE) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        return 0;
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    omx_push_packet_parameters(avctx, avpkt);
+
+    s->eos_flag = (avpkt->size == 0 && s->packet_sended == 1) ? 1 : 0;
+    if (avpkt->size) {
+        ret = omx_get_packet_and_fill_buffer(avctx, avpkt);
+        if (ret != 0) {
+            AV_LOGE("omx_get_packet_and_fill_buffer failed");
+            return ret;
+        }
+    } else if (s->eos_sent) {
+        ret = omx_send_eos_flag(avctx);
+        if (ret != 0) {
+            AV_LOGE("sent eos flag error");
+            return ret;
+        }
+    } else {
+        AV_LOGD("receive data is NULL");
+    }
+
+    return 0;
+}
+
+static void copy_yuv_by_line(uint8_t *plane, uint8_t *source, int32_t decorder_width, int32_t width, int32_t height, int32_t bit_depth)
+{
+    int32_t i;
+    for (i = 0; i< height ; i++) {
+        memcpy(plane, source, width * bit_depth);
+        plane += width * bit_depth;
+        source += decorder_width * bit_depth;
+    }
+}
+
+static int32_t omx_fill_frame(AVCodecContext *avctx, AVFrame *pict, const HW_OMX_BUFFERHEADERTYPE *buffer)
+{
+    uint8_t *yplane = NULL;
+    uint8_t *uvplane = NULL;
+    OMXCodecContext *s = avctx->priv_data;
+    int32_t bit_depth = omx_is_10bit_video(avctx) ? 2 : 1;
+
+    pict->width = s->width;
+    pict->height = s->height;
+
+    if (omx_is_10bit_video(avctx)) {
+        pict->format = AV_PIX_FMT_P010LE;
+    } else {
+        pict->format = AV_PIX_FMT_NV12;
+    }
+
+    pict->sample_aspect_ratio = avctx->sample_aspect_ratio;
+    pict->pkt_dts = AV_NOPTS_VALUE;
+    pict->linesize[0] = s->width * bit_depth;
+    pict->pts = buffer->nTimeStamp < 0 ? AV_NOPTS_VALUE : buffer->nTimeStamp;
+    
+    if (s->width * s->height == 0) {
+        return AVERROR(EINVAL);
+    }
+    yplane = av_malloc(s->width * s->height * bit_depth);
+    if (yplane == NULL) {
+        return AVERROR(ENOMEM);
+    }
+
+    copy_yuv_by_line(yplane, buffer->pBuffer + buffer->nOffset, s->decode_width, s->width, s->height, bit_depth);
+    pict->buf[0] = av_buffer_create(yplane, s->width * s->height * bit_depth, omx_release_buffer, avctx,
+        AV_BUFFER_FLAG_READONLY);
+    if (pict->buf[0] == NULL) {
+        av_freep(&yplane);
+        return AVERROR(ENOMEM);
+    }
+    pict->data[0] = pict->buf[0]->data;
+
+    uvplane = av_malloc(s->width * s->height  * bit_depth/ 2); // 2: yv domain space size calculation
+    if (uvplane == NULL) {
+        av_buffer_unref(&pict->buf[0]);
+        return AVERROR(ENOMEM);
+    }
+
+    copy_yuv_by_line(uvplane ,buffer->pBuffer + buffer->nOffset + s->decode_width * s->decode_height * bit_depth,
+        s->decode_width, s->width, s->height / 2, bit_depth);
+
+    pict->linesize[1] = s->width* bit_depth;
+    // 2: yv domain space size calculation
+    pict->buf[1] = av_buffer_create(uvplane, s->width * s->height * bit_depth/ 2, omx_release_buffer, avctx,
+        AV_BUFFER_FLAG_READONLY);
+    if (pict->buf[1] == NULL) {
+        av_buffer_unref(&pict->buf[0]);
+        av_freep(&uvplane);
+        return AVERROR(ENOMEM);
+    }
+    pict->data[1] = pict->buf[1]->data;
+    pict->nb_extended_buf = 0;
+    pict->extended_data = pict->data;
+
+    return 0;
+}
+
+static int32_t omx_get_buffer_and_fill_frame(AVCodecContext *avctx, AVFrame *data, int32_t *got_frame)
+{
+    int32_t ret;
+    HW_OMX_ERRORTYPE err;
+    HW_OMX_BUFFERHEADERTYPE *buffer = NULL;
+    OMXAcquireBufferState acq_return;
+    OMXCodecContext *s = avctx->priv_data;
+    int32_t eos_flag = s->eos_flag;
+    int32_t packet_sended = s->packet_sended;
+
+    if (eos_flag == 1 && packet_sended == 1 && s->frame_received == 0) {
+        av_usleep(200000); // 200000: wait 200ms
+    }
+
+    acq_return = omx_acquire_port_buffer(avctx, &s->output_port, &buffer);
+    if (acq_return == HW_OMX_ACQUIRE_BUFFER_EOS) {
+        AV_LOGD("Decoder have received eos");
+    }
+
+    if (buffer == NULL) {
+        return 0;
+    }
+
+    if (buffer->nFilledLen > 0) {
+        *got_frame = 1;
+        ret = omx_fill_frame(avctx, data, buffer);
+        if (ret != 0) {
+            *got_frame = 0;
+        } else {
+            if (!s->frame_received) {
+                s->frame_received = 1;
+            }
+        }
+    }
+    err = HW_OMX_FillThisBuffer(s->handle, buffer);
+    if (err != HW_OMX_ErrorNone) {
+        omx_append_buffer(&s->output_port, buffer);
+        AV_LOGE("HW_OMX_FillThisBuffer failed: %x", err);
+        return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+static void omx_get_cond_status(OMXCodecContext *s, bool *reconfiguring, bool *flushing, bool *is_full)
+{
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    *reconfiguring = s->reconfiguring;
+    *flushing = s->flushing;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    pthread_mutex_lock(&s->frame_message_lock.lock);
+    *is_full = is_message_queue_full(s->frame_message_queue);
+    pthread_mutex_unlock(&s->frame_message_lock.lock);
+}
+
+
+static void omx_receive_frame_thread_init(AVCodecContext *avctx, AVFrame **frame, OMXMessage *msg)
+{
+    OMXCodecContext *s = ((AVCodecContext *)avctx)->priv_data;
+
+    *frame = av_frame_alloc();
+
+    if (*frame == NULL) {
+        msg->frame.ret = AVERROR(ENOMEM);
+        msg->frame.got_frame = 0;
+
+        pthread_mutex_lock(&s->frame_message_lock.lock);
+        push_message(s->avctx, s->frame_message_queue, msg);
+        pthread_mutex_unlock(&s->frame_message_lock.lock);
+        AV_LOGE("create frame faild");
+    }
+}
+
+static void omx_receive_frame_thread_deinit(AVFrame *frame)
+{
+    memset(frame, 0, sizeof(*frame));
+    av_frame_free(&frame);
+}
+
+static void *omx_receive_frame_thread(void *avctx)
+{
+    AVFrame *frame = NULL;
+    OMXMessage msg;
+    int32_t got_frame;
+    int32_t ret;
+    bool reconfiguring = FALSE;
+    bool flushing = FALSE;
+    bool is_full = FALSE;
+    struct timespec tv;
+    OMXCodecContext *s = ((AVCodecContext *)avctx)->priv_data;
+    AV_LOGD("omx_receive_frame_thread start");
+
+    omx_receive_frame_thread_init((AVCodecContext *)avctx, &frame, &msg);
+
+    while (1) {
+        omx_get_cond_status(s, &reconfiguring, &flushing, &is_full);
+
+        pthread_mutex_lock(&s->output_port.buffer_lock.lock);
+        while ((!s->output_port.num_pending_buffers || reconfiguring || flushing || is_full) && !s->thread_end) {
+            GET_WAIT_TIME(tv, ONE_SECOND_INTERVAL);
+            pthread_cond_timedwait(&s->output_port.buffer_cond.cond, &s->output_port.buffer_lock.lock, &tv);
+            omx_get_cond_status(s, &reconfiguring, &flushing, &is_full);
+        }
+        pthread_mutex_unlock(&s->output_port.buffer_lock.lock);
+
+        pthread_mutex_lock(&s->flushing_lock.lock);
+        if (s->thread_end) {
+            pthread_mutex_unlock(&s->flushing_lock.lock);
+            omx_receive_frame_thread_deinit(frame);
+            AV_LOGD("omx_receive_frame_thread end");
+            break;
+        }
+
+        if (s->flushing == TRUE) {
+            pthread_mutex_unlock(&s->flushing_lock.lock);
+            continue;
+        }
+
+        got_frame = 0;
+        ret = omx_get_buffer_and_fill_frame(avctx, frame, &got_frame);
+        memset(&msg, 0, sizeof(msg));
+        if (ret != 0) {
+            msg.frame.ret = ret;
+            msg.frame.got_frame = 0;
+        } else if (got_frame == 0) {
+            pthread_mutex_unlock(&s->flushing_lock.lock);
+            continue;
+        } else {
+            av_frame_unref(&msg.frame.data);
+            av_frame_move_ref(&msg.frame.data, frame);
+            msg.frame.ret = ret;
+            msg.frame.got_frame = got_frame;
+        }
+
+        pthread_mutex_lock(&s->frame_message_lock.lock);
+        push_message(s->avctx, s->frame_message_queue, &msg);
+        pthread_mutex_unlock(&s->frame_message_lock.lock);
+        pthread_mutex_unlock(&s->flushing_lock.lock);
+    }
+
+    AV_LOGD("omx_receive_frame_thread end");
+    return NULL;
+}
+
+static void omx_release_hardware_resources(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    HW_OMX_STATETYPE state = s->state;
+
+    if (state > HW_OMX_StateLoaded || state == HW_OMX_StateInvalid) {
+        if (state > HW_OMX_StateIdle) {
+            HW_OMX_SendCommand(s->handle, HW_OMX_CommandStateSet, HW_OMX_StateIdle, NULL);
+            omx_wait_component_state_finished(avctx, HW_OMX_StateIdle);
+        }
+        HW_OMX_SendCommand(s->handle, HW_OMX_CommandStateSet, HW_OMX_StateLoaded, NULL);
+        omx_deallocate_port_buffers(avctx, &s->input_port);
+        omx_deallocate_port_buffers(avctx, &s->output_port);
+        omx_wait_component_state_finished(avctx, HW_OMX_StateLoaded);
+    }
+
+    if (s->omx_context->FreeHandle_Func != NULL && s->handle != NULL) {
+        s->omx_context->FreeHandle_Func(s->handle);
+        s->handle = NULL;
+    } else {
+        AV_LOGE("FreeHandle_Func is %p , handle is %p.", s->omx_context->FreeHandle_Func, s->handle);
+        return;
+    }
+
+    omx_deinit(s->omx_context);
+}
+
+static void omx_release_context_resources(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    s->omx_context = NULL;
+
+    mutexlock_destroy(avctx, &s->input_port.buffer_lock);
+    mutexlock_destroy(avctx, &s->output_port.buffer_lock);
+    mutexlock_destroy(avctx, &s->event_message_lock);
+    mutexlock_destroy(avctx, &s->decoder_status_lock);
+    mutexlock_destroy(avctx, &s->frame_message_lock);
+    mutexlock_destroy(avctx, &s->flushing_lock);
+
+    mutexcond_destroy(avctx, &s->input_port.buffer_cond);
+    mutexcond_destroy(avctx, &s->output_port.buffer_cond);
+    mutexcond_destroy(avctx, &s->event_message_cond);
+    mutexcond_destroy(avctx, &s->decoder_status_cond);
+
+    CHECK_FREE_BUFFER((void **)&s->input_port.buffer_headers);
+    CHECK_FREE_BUFFER((void **)&s->output_port.buffer_headers);
+    CHECK_FREE_BUFFER((void **)&s->input_port.pending_buffers);
+    CHECK_FREE_BUFFER((void **)&s->output_port.pending_buffers);
+    CHECK_FREE_BUFFER((void **)&s->event_message_queue);
+    CHECK_FREE_BUFFER((void **)&s->frame_message_queue);
+
+    if (avctx->codec->id == AV_CODEC_ID_H264) {
+        CHECK_FREE_BUFFER((void **)&s->extradata_context.h264.annexb_buffer);
+    }
+
+    if (avctx->codec->id == AV_CODEC_ID_HEVC) {
+        CHECK_FREE_BUFFER((void **)&s->extradata_context.hevc.annexb_buffer);
+    }
+}
+
+static int64_t omx_guess_correct_pts(AVCodecContext *ctx, int64_t reordered_pts, int64_t dts)
+{
+    int64_t pts;
+
+    if (dts != AV_NOPTS_VALUE) {
+        ctx->pts_correction_num_faulty_dts += dts <= ctx->pts_correction_last_dts;
+        ctx->pts_correction_last_dts = dts;
+    } else if (reordered_pts != AV_NOPTS_VALUE) {
+        ctx->pts_correction_last_dts = reordered_pts;
+    }
+
+    if (reordered_pts != AV_NOPTS_VALUE) {
+        ctx->pts_correction_num_faulty_pts += reordered_pts <= ctx->pts_correction_last_pts;
+        ctx->pts_correction_last_pts = reordered_pts;
+    } else if (dts != AV_NOPTS_VALUE) {
+        ctx->pts_correction_last_pts = dts;
+    }
+
+    if ((ctx->pts_correction_num_faulty_pts <= ctx->pts_correction_num_faulty_dts || dts == AV_NOPTS_VALUE) &&
+        reordered_pts != AV_NOPTS_VALUE) {
+        pts = reordered_pts;
+    } else {
+        pts = dts;
+    }
+
+    return pts;
+}
+
+static void omx_set_frame_parameters(AVCodecContext *avctx, AVFrame *frame, int32_t *got_frame)
+{
+    OMXPacketParam param;
+
+    param = omx_pop_packet_parameters(avctx, frame->pts);
+    if (param.flag == 0) {
+        param.dts = AV_NOPTS_VALUE;
+        param.pos = -1;
+        param.duration = 0;
+        param.size = 0;
+    }
+
+    frame->pkt_duration = param.duration;
+    frame->pkt_size = param.size;
+    if (!(avctx->codec->caps_internal & FF_CODEC_CAP_SETS_PKT_DTS)) {
+        frame->pkt_dts = param.dts;
+    }
+
+    if (!avctx->has_b_frames) {
+        frame->pkt_pos = param.pos;
+    }
+
+    if (*got_frame) {
+        frame->best_effort_timestamp = omx_guess_correct_pts(avctx, frame->pts, frame->pkt_dts);
+    }
+
+    if (!*got_frame) {
+        av_frame_unref(frame);
+    }
+}
+
+static void omx_perform_reconfigure(AVCodecContext *avctx)
+{
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = avctx->priv_data;
+    int32_t num_pending_buffers = s->output_port.num_pending_buffers;
+    bool pending_reconfigure_port = s->output_port.pending_reconfigure_port;
+
+    if (pending_reconfigure_port == TRUE && num_pending_buffers == 0) {
+        pthread_mutex_lock(&s->decoder_status_lock.lock);
+        s->reconfiguring = TRUE;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+        err = omx_reconfigure_port(avctx, &s->output_port);
+        if (err != HW_OMX_ErrorNone) {
+            AV_LOGE("port reconfigure error: %s (0x%08x)", omx_error_to_string(err), err);
+        }
+    }
+}
+
+static int32_t omx_receive_packet(AVCodecContext *avctx, const AVCodecInternal *avci, AVPacket *pkt)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    s->packet_received = FALSE;
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (!s->input_port.num_pending_buffers && s->error_status != TRUE && s->abnormal_status != TRUE) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        s->abnormal_time = av_gettime();
+        if (s->abnormal_time - s->last_packet_time > ONE_SECOND_INTERVAL) {
+            omx_flush_component(avctx); // the input buffer number is 0 for 1 second, and do the flush operation
+            s->abnormal_status = TRUE;
+            AV_LOGW("the input buffer number is 0 for 1 second");
+        }
+        return 0;
+    }
+
+    if (s->input_port.num_pending_buffers && s->abnormal_status == TRUE) {
+        s->abnormal_status = FALSE; // state restoration
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    s->last_packet_time = av_gettime();
+
+    if (!pkt->data && !avci->draining) {
+        int32_t ret;
+        s->packet_received = TRUE;
+        av_packet_unref(pkt);
+        ret = ff_decode_get_packet(avctx, pkt);
+        if (ret < 0 && ret != AVERROR_EOF) {
+            return ret;
+        } else if (ret == AVERROR_EOF) {
+            AV_LOGD("reach end of file(EOF)");
+        }
+    }
+    s->packet_num++;
+    // Some codecs (at least wma lossless) will crash when feeding drain packets
+    // after EOF was signaled.
+    if (avci->draining_done) {
+        AV_LOGD("end of decoding");
+        return AVERROR_EOF;
+    }
+
+    return 0;
+}
+
+static int32_t omx_send_frame(AVCodecContext *avctx, AVFrame *frame, int32_t *got_frame)
+{
+    int32_t ret;
+    int32_t message_ret;
+    OMXMessage msg;
+    OMXCodecContext *s = avctx->priv_data;
+
+    pthread_mutex_lock(&s->frame_message_lock.lock);
+    message_ret = pop_message(avctx, s->frame_message_queue, &msg);
+    pthread_mutex_unlock(&s->frame_message_lock.lock);
+
+    if (message_ret != 0) {
+        return 0;
+    }
+
+    ret = msg.frame.ret;
+    if (ret != 0) {
+        pthread_mutex_lock(&s->decoder_status_lock.lock);
+        s->error_status = TRUE;
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+    }
+    *got_frame = msg.frame.got_frame;
+    if (ret == 0 && *got_frame == 1) {
+        msg.frame.data.extended_data = msg.frame.data.data;
+        av_frame_unref(frame);
+        av_frame_move_ref(frame, &msg.frame.data);
+    } else {
+        *got_frame = 0;
+    }
+
+    return ret;
+}
+
+static void omx_set_draining_done(AVCodecContext *avctx, AVCodecInternal *avci, int32_t actual_got_frame, int32_t *ret)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    /* do not stop draining when actual_got_frame != 0 or *ret < 0 */
+    /* got_frame == 0 but actual_got_frame != 0 when frame is discarded */
+    if (avctx->internal->draining && !actual_got_frame && !s->frame_message_queue->size) {
+        if (*ret < 0) {
+            /* prevent infinite loop if a decoder wrongly always return error on draining */
+            /* reasonable nb_errors_max = maximum b frames + thread count */
+            const int32_t nb_errors_max = 20 + // 20: maximum b frames
+                (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_FRAME) ? avctx->thread_count : 1);
+
+            if (avci->nb_draining_errors++ >= nb_errors_max) {
+                AV_LOGE("Too many errors when draining, this is a bug. Stop draining and force EOF.");
+                avci->draining_done = 1;
+                *ret = AVERROR_BUG;
+            }
+        } else {
+            avci->draining_done = 1;
+        }
+    }
+}
+
+static void omx_release_receive_frame_thread(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    if (s->output_port.buffer_lock.is_init == FALSE || s->output_port.buffer_cond.is_init == FALSE) {
+        return;
+    }
+
+    pthread_mutex_lock(&s->output_port.buffer_lock.lock);
+    s->thread_end = TRUE;
+    pthread_cond_broadcast(&s->output_port.buffer_cond.cond);
+    pthread_mutex_unlock(&s->output_port.buffer_lock.lock);
+
+    pthread_join(s->receive_frame_thread_id, NULL);
+
+    omx_free_frame_message_queue(avctx, s->frame_message_queue);
+}
+
+static void omx_release_event_handle_thread(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = avctx->priv_data;
+
+    if (s->event_message_lock.is_init == FALSE || s->event_message_cond.is_init == FALSE) {
+        return;
+    }
+
+    pthread_mutex_lock(&s->event_message_lock.lock);
+    s->event_handle_thread_end = TRUE;
+    pthread_cond_broadcast(&s->event_message_cond.cond);
+    pthread_mutex_unlock(&s->event_message_lock.lock);
+
+    pthread_join(s->event_handle_thread_id, NULL);
+}
+
+
+int32_t omx_flush_component(AVCodecContext *avctx)
+{
+    HW_OMX_ERRORTYPE err;
+    OMXCodecContext *s = NULL;
+
+    s = avctx->priv_data;
+    s->flushing = TRUE;
+
+    AV_LOGD("OMX decode flush start");
+
+    if (s->omx_context == NULL || !strlen(s->component_name)) {
+        return HW_OMX_ErrorUndefined;
+    }
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->error_status == TRUE) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        AV_LOGE("decoder is in an error state");
+        return HW_OMX_ErrorUndefined;
+    }
+
+    if (s->state == HW_OMX_StateLoaded) {
+        pthread_mutex_unlock(&s->decoder_status_lock.lock);
+        return HW_OMX_ErrorNone;
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    err = omx_pause_component(avctx);
+    CHECK_HW_OMX_RET(err, "pause the components error");
+
+    err = omx_flush_port(avctx, &s->input_port);
+    CHECK_HW_OMX_RET(err, "input port flush error");
+
+    err = omx_flush_port(avctx, &s->output_port);
+    CHECK_HW_OMX_RET(err, "output port flush error");
+
+    err = omx_resume_component(avctx);
+    CHECK_HW_OMX_RET(err, "resume_components error");
+
+    err = omx_clean_pending_buffers(avctx);
+    CHECK_HW_OMX_RET(err, "clean pending buffers error");
+
+    if (avctx->codec->id == AV_CODEC_ID_H264) {
+        h264_annexb_flush(avctx);
+    }
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    s->flushing = FALSE;
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    AV_LOGD("OMX decode flush end");
+
+    return HW_OMX_ErrorNone;
+}
+
+int32_t omx_perform_decoding(AVCodecContext *avctx, AVFrame *frame)
+{
+    AVCodecInternal *avci = avctx->internal;
+    DecodeSimpleContext *ds = &avci->ds;
+    AVPacket *pkt = ds->in_pkt;
+    OMXCodecContext *s = avctx->priv_data;
+    int32_t actual_got_frame;
+    int32_t got_frame = 0;
+    int32_t ret;
+
+    omx_perform_reconfigure(avctx);
+
+    ret = omx_receive_packet(avctx, avci, pkt);
+    if (ret != 0) {
+        return ret;
+    }
+
+    ret = omx_send_packet(avctx, pkt);
+    if (ret != 0) {
+        return ret;
+    }
+
+    ret = omx_send_frame(avctx, frame, &got_frame);
+
+    actual_got_frame = got_frame;
+    omx_set_frame_parameters(avctx, frame, &got_frame);
+
+
+#if FF_API_AVCTX_TIMEBASE
+    if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {
+        avctx->time_base = av_inv_q(av_mul_q(avctx->framerate, (AVRational) { avctx->ticks_per_frame, 1 }));
+    }
+#endif
+
+    omx_set_draining_done(avctx, avci, actual_got_frame, &ret);
+    av_packet_unref(pkt);
+
+    pthread_mutex_lock(&s->decoder_status_lock.lock);
+    if (s->error_status == TRUE) {
+        s->error = HW_OMX_ErrorNone;
+    }
+    pthread_mutex_unlock(&s->decoder_status_lock.lock);
+
+    return ret < 0 ? ret : 0;
+}
+
+int32_t omx_initialize_decoder(AVCodecContext *avctx)
+{
+    int32_t ret;
+    OMXCodecContext *s = NULL;
+    const char *role = NULL;
+
+    s = avctx->priv_data;
+    s->omx_context = omx_init(avctx, s->libname, s->libprefix);
+    if (s->omx_context == NULL) {
+        ret = AVERROR_DECODER_NOT_FOUND;
+        AV_LOGE("omx context create failed");
+        goto FAIL;
+    }
+
+    ret = omx_context_init(avctx);
+    if (ret < 0) {
+        AV_LOGE("omx context init failed");
+        goto FAIL;
+    }
+
+    ret = omx_find_component(s->omx_context, avctx, &role, s->component_name, sizeof(s->component_name));
+    if (ret < 0) {
+        AV_LOGE("find component error");
+        goto FAIL;
+    }
+
+    ret = pthread_create(&s->event_handle_thread_id, NULL, omx_handle_event_message_thread, avctx);
+    if (ret != 0) {
+        ret = AVERROR(ENOSYS);
+        AV_LOGE("omx_handle_event_message_thread failed");
+        goto FAIL;
+    }
+
+    ret = omx_component_init(avctx, role);
+    if (ret != HW_OMX_ErrorNone) {
+        ret = AVERROR(ENOSYS);
+        AV_LOGE("component init failed");
+        goto FAIL;
+    }
+
+    ret = pthread_create(&s->receive_frame_thread_id, NULL, omx_receive_frame_thread, avctx);
+    if (ret != 0) {
+        ret = AVERROR(ENOSYS);
+        AV_LOGE("omx_receive_frame_thread failed");
+        goto FAIL;
+    }
+
+    return 0;
+
+FAIL:
+    omx_release_decoder(avctx);
+    s->need_release = FALSE;
+    return ret;
+}
+
+int32_t omx_release_decoder(AVCodecContext *avctx)
+{
+    OMXCodecContext *s = NULL;
+
+    AV_LOGD("omx_release_decoder start");
+
+    s = avctx->priv_data;
+
+    if (s->omx_context == NULL || !strlen(s->component_name)) {
+        AV_LOGW("omx_context or component_name is NULL ");
+        return 0;
+    }
+
+    if (s->need_release == FALSE) {
+        AV_LOGW("decoder has been released");
+        return 0;
+    }
+
+    omx_release_receive_frame_thread(avctx);
+
+    omx_release_hardware_resources(avctx);
+
+    omx_release_event_handle_thread(avctx);
+
+    omx_release_context_resources(avctx);
+
+    AV_LOGD("omx_release_decoder end");
+    return 0;
+}
Index: ffmpeg/libavcodec/omx_dec_wrapper.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_dec_wrapper.h
@@ -0,0 +1,153 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef HW_OMX_DEC_WRAPPER_H
+#define HW_OMX_DEC_WRAPPER_H
+#include "avcodec.h"
+#include "HW_OMX_Core.h"
+#include "HW_OMX_Component.h"
+#include "omx_dec_common.h"
+#include "omx_dec_to_annexb.h"
+
+#define MAX_PACKET_LIST_LEN 50
+
+typedef enum OMXAcquireBufferState {
+    HW_OMX_ACQUIRE_BUFFER_OK = 0,       /* Everything good and the buffer is valid */
+    HW_OMX_ACQUIRE_BUFFER_FLUSHING,     /* The port is flushing, exit ASAP */
+    HW_OMX_ACQUIRE_BUFFER_RECONFIGURE,  /* The port must be reconfigured */
+    HW_OMX_ACQUIRE_BUFFER_EOS,          /* The port is EOS */
+    HW_OMX_ACQUIRE_BUFFER_ERROR,        /* A fatal error happened */
+    HW_OMX_ACQUIRE_BUFFER_NO_AVAILABLE, /* No buffer is currently available */
+} OMXAcquireBufferState;
+
+typedef struct OMXContext {
+    void *lib;
+    HW_OMX_ERRORTYPE (*Init_Func)(void);
+    HW_OMX_ERRORTYPE (*Deinit_Func)(void);
+    HW_OMX_ERRORTYPE (*ComponentNameEnum_Func)(HW_OMX_STRING, HW_OMX_U32, HW_OMX_U32);
+    HW_OMX_ERRORTYPE (*GetHandle_Func)(HW_OMX_HANDLETYPE *, HW_OMX_STRING, HW_OMX_PTR, HW_OMX_CALLBACKTYPE *);
+    HW_OMX_ERRORTYPE (*FreeHandle_Func)(HW_OMX_HANDLETYPE);
+    HW_OMX_ERRORTYPE (*GetComponentsOfRole_Func)(HW_OMX_STRING, HW_OMX_U32 *, HW_OMX_U8 **);
+    HW_OMX_ERRORTYPE (*GetRolesOfComponent_Func)(HW_OMX_STRING, HW_OMX_U32 *, HW_OMX_U8 **);
+    void (*host_init)(void);
+} OMXContext;
+
+typedef struct OMXPort {
+    int32_t index;
+    HW_OMX_PARAM_PORTDEFINITIONTYPE port_def;
+
+    bool flushing;
+    bool flushed;          /* TRUE after HW_OMX_CommandFlush was done */
+    bool enabled_pending;  /* TRUE after HW_OMX_Command{En,Dis}able */
+    bool disabled_pending; /* was done until it took effect */
+    bool eos;              /* TRUE after a buffer with EOS flag was received */
+
+    int32_t buffer_numbers;
+    HW_OMX_COLOR_FORMATTYPE color_format;
+    HW_OMX_VIDEO_CODINGTYPE compression_format;
+    HW_OMX_BUFFERHEADERTYPE **buffer_headers;
+    int32_t num_pending_buffers;
+    HW_OMX_BUFFERHEADERTYPE **pending_buffers;
+
+    bool pending_reconfigure_port;
+    MutexLock buffer_lock;
+    MutexCond buffer_cond;
+} OMXPort;
+
+typedef struct OMXPacketParam {
+    int64_t pts;
+    int64_t dts;
+    int64_t pos;
+    int64_t duration;
+    int size;
+    bool flag;
+} OMXPacketParam;
+
+typedef struct OMXCodecContext {
+    const AVClass *class;
+    char *libname;
+    char *libprefix;
+    OMXContext *omx_context;
+    AVCodecContext *avctx;
+    bool need_release;
+
+    char component_name[HW_OMX_MAX_STRINGNAME_SIZE];
+    HW_OMX_VERSIONTYPE version;
+    HW_OMX_HANDLETYPE handle;
+
+    OMXPort input_port;
+    OMXPort output_port;
+    int32_t packet_sended;
+    int32_t frame_received;
+    int32_t stride;
+    int32_t plane_size;
+    uint32_t packet_num;
+
+    HW_OMX_STATETYPE state;
+    HW_OMX_ERRORTYPE error;
+    int32_t eos_sent;
+    int32_t eos_flag;
+    int32_t omx_profile;
+    int32_t omx_level;
+    int32_t width;
+    int32_t height;
+    int32_t decode_width;
+    int32_t decode_height;
+    bool reconfiguring;
+    bool flushing;
+    bool dec_10bit_supported;
+    MutexLock flushing_lock;
+    bool error_status;
+    bool abnormal_status;
+    uint32_t framerate;
+
+    OmxMessageQueue *event_message_queue;
+    bool thread_end;
+
+    pthread_t event_handle_thread_id;
+    MutexLock event_message_lock;
+    MutexCond event_message_cond;
+    MutexLock decoder_status_lock;
+    MutexCond decoder_status_cond;
+    bool event_handle_thread_end;
+
+    OmxMessageQueue *frame_message_queue;
+    pthread_t receive_frame_thread_id;
+    MutexLock frame_message_lock;
+
+    ExtradataContext extradata_context;
+
+    int64_t abnormal_time;
+    int64_t last_packet_time;
+
+    OMXPacketParam packet_sended_queue[MAX_PACKET_LIST_LEN];
+    bool packet_received;
+} OMXCodecContext;
+
+int32_t omx_perform_decoding(AVCodecContext *avctx, AVFrame *frame);
+
+int32_t omx_flush_component(AVCodecContext *avctx);
+
+int32_t omx_initialize_decoder(AVCodecContext *avctx);
+
+int32_t omx_release_decoder(AVCodecContext *avctx);
+
+#endif
Index: ffmpeg/libavcodec/omx_profile_level.c
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_profile_level.c
@@ -0,0 +1,228 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "omx_profile_level.h"
+
+#include "HW_OMX_Video.h"
+#include "HW_OMX_VideoExt.h"
+#include "avcodec.h"
+#include "omx_dec_common.h"
+#include "omx_dec_wrapper.h"
+
+#define HW_OMX_VIDEO_INVALID_PARAMETER 0x7FFFFFFF
+
+static const ProfileLevelMap h264_profile_adaptation_map[] = {
+    { FF_PROFILE_H264_BASELINE,             HW_OMX_VIDEO_AVCProfileBaseline },
+    { FF_PROFILE_H264_CONSTRAINED_BASELINE, HW_OMX_VIDEO_AVCProfileBaseline },
+    { FF_PROFILE_H264_MAIN,                 HW_OMX_VIDEO_AVCProfileMain },
+    { FF_PROFILE_H264_EXTENDED,             HW_OMX_VIDEO_AVCProfileExtended },
+    { FF_PROFILE_H264_HIGH,                 HW_OMX_VIDEO_AVCProfileHigh },
+    { FF_PROFILE_H264_HIGH_10,              HW_OMX_VIDEO_AVCProfileHigh10 },
+    { FF_PROFILE_H264_HIGH_422,             HW_OMX_VIDEO_AVCProfileHigh422 },
+    { FF_PROFILE_H264_HIGH_444,             HW_OMX_VIDEO_AVCProfileHigh444 },
+};
+
+static const ProfileLevelMap h264_level_adaptation_map[] = {
+    { 10, HW_OMX_VIDEO_AVCLevel1 },
+    { 9,  HW_OMX_VIDEO_AVCLevel1b },
+    { 11, HW_OMX_VIDEO_AVCLevel11 },
+    { 12, HW_OMX_VIDEO_AVCLevel12 },
+    { 13, HW_OMX_VIDEO_AVCLevel13 },
+    { 20, HW_OMX_VIDEO_AVCLevel2 },
+    { 21, HW_OMX_VIDEO_AVCLevel21 },
+    { 22, HW_OMX_VIDEO_AVCLevel22 },
+    { 30, HW_OMX_VIDEO_AVCLevel3 },
+    { 31, HW_OMX_VIDEO_AVCLevel31 },
+    { 32, HW_OMX_VIDEO_AVCLevel32 },
+    { 40, HW_OMX_VIDEO_AVCLevel4 },
+    { 41, HW_OMX_VIDEO_AVCLevel41 },
+    { 42, HW_OMX_VIDEO_AVCLevel42 },
+    { 50, HW_OMX_VIDEO_AVCLevel5 },
+    { 51, HW_OMX_VIDEO_AVCLevel51 },
+    { 52, HW_OMX_VIDEO_AVCLevel52 },
+    { 60, HW_OMX_VIDEO_AVCLevel6 },
+    { 61, HW_OMX_VIDEO_AVCLevel61 },
+    { 62, HW_OMX_VIDEO_AVCLevel62 }
+};
+
+static const ProfileLevelMap hevc_profile_adaptation_map[] = {
+    { FF_PROFILE_HEVC_MAIN,               HW_OMX_VIDEO_HEVCProfileMain },
+    { FF_PROFILE_HEVC_MAIN_10,            HW_OMX_VIDEO_HEVCProfileMain10 },
+    { FF_PROFILE_HEVC_MAIN_STILL_PICTURE, HW_OMX_VIDEO_HEVCProfileMainStill },
+};
+
+static const ProfileLevelMap hevc_main_level_adaptation_map[] = {
+    { 10, HW_OMX_VIDEO_HEVCMainTierLevel1 },
+    { 20, HW_OMX_VIDEO_HEVCMainTierLevel2 },
+    { 21, HW_OMX_VIDEO_HEVCMainTierLevel21 },
+    { 30, HW_OMX_VIDEO_HEVCMainTierLevel3 },
+    { 31, HW_OMX_VIDEO_HEVCMainTierLevel31 },
+    { 40, HW_OMX_VIDEO_HEVCMainTierLevel4 },
+    { 41, HW_OMX_VIDEO_HEVCMainTierLevel41 },
+    { 50, HW_OMX_VIDEO_HEVCMainTierLevel5 },
+    { 51, HW_OMX_VIDEO_HEVCMainTierLevel51 },
+    { 52, HW_OMX_VIDEO_HEVCMainTierLevel52 },
+    { 60, HW_OMX_VIDEO_HEVCMainTierLevel6 },
+    { 61, HW_OMX_VIDEO_HEVCMainTierLevel61 },
+    { 62, HW_OMX_VIDEO_HEVCMainTierLevel62 },
+};
+
+
+static const ProfileLevelMap vp9_profile_adaptation_map[] = {
+    { FF_PROFILE_VP9_0, HW_OMX_VIDEO_VP9Profile0 },
+    { FF_PROFILE_VP9_1, HW_OMX_VIDEO_VP9Profile1 },
+    { FF_PROFILE_VP9_2, HW_OMX_VIDEO_VP9Profile2 },
+    { FF_PROFILE_VP9_3, HW_OMX_VIDEO_VP9Profile3 },
+};
+
+static const ProfileLevelMap vp9_main_level_adaptation_map[] = {
+    { 10, HW_OMX_VIDEO_VP9Level1 },
+    { 20, HW_OMX_VIDEO_VP9Level2 },
+    { 21, HW_OMX_VIDEO_VP9Level21 },
+    { 30, HW_OMX_VIDEO_VP9Level3 },
+    { 31, HW_OMX_VIDEO_VP9Level31 },
+    { 40, HW_OMX_VIDEO_VP9Level4 },
+    { 41, HW_OMX_VIDEO_VP9Level41 },
+    { 50, HW_OMX_VIDEO_VP9Level5 },
+    { 51, HW_OMX_VIDEO_VP9Level51 },
+    { 52, HW_OMX_VIDEO_VP9Level52 },
+    { 60, HW_OMX_VIDEO_VP9Level6 },
+    { 61, HW_OMX_VIDEO_VP9Level61 },
+    { 62, HW_OMX_VIDEO_VP9Level62 },
+};
+
+static const ProfileLevelMap mpeg4_profile_adaptation_map[] = {
+    { FF_PROFILE_MPEG4_SIMPLE,                    HW_OMX_VIDEO_MPEG4ProfileSimple },
+    { FF_PROFILE_MPEG4_SIMPLE_SCALABLE,           HW_OMX_VIDEO_MPEG4ProfileSimpleScalable },
+    { FF_PROFILE_MPEG4_CORE,                      HW_OMX_VIDEO_MPEG4ProfileCore },
+    { FF_PROFILE_MPEG4_MAIN,                      HW_OMX_VIDEO_MPEG4ProfileMain },
+    { FF_PROFILE_MPEG4_N_BIT,                     HW_OMX_VIDEO_MPEG4ProfileNbit },
+    { FF_PROFILE_MPEG4_SCALABLE_TEXTURE,          HW_OMX_VIDEO_MPEG4ProfileScalableTexture },
+    { FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION,     HW_OMX_VIDEO_MPEG4ProfileSimpleFace },
+    { FF_PROFILE_MPEG4_SIMPLE_STUDIO,             HW_OMX_VIDEO_MPEG4ProfileSimpleFBA },
+    { FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE,    HW_OMX_VIDEO_MPEG4ProfileBasicAnimated },
+    { FF_PROFILE_MPEG4_HYBRID,                    HW_OMX_VIDEO_MPEG4ProfileHybrid },
+    { FF_PROFILE_MPEG4_ADVANCED_REAL_TIME,        HW_OMX_VIDEO_MPEG4ProfileAdvancedRealTime },
+    { FF_PROFILE_MPEG4_CORE_SCALABLE,             HW_OMX_VIDEO_MPEG4ProfileCoreScalable },
+    { FF_PROFILE_MPEG4_ADVANCED_CODING,           HW_OMX_VIDEO_MPEG4ProfileAdvancedCoding },
+    { FF_PROFILE_MPEG4_ADVANCED_CORE,             HW_OMX_VIDEO_MPEG4ProfileAdvancedCore },
+    { FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE, HW_OMX_VIDEO_MPEG4ProfileAdvancedScalable },
+    { FF_PROFILE_MPEG4_ADVANCED_SIMPLE,           HW_OMX_VIDEO_MPEG4ProfileAdvancedSimple },
+};
+
+static const ProfileLevelMap mpeg4_level_adaptation_map[] = {
+    { 0, HW_OMX_VIDEO_MPEG4Level0 },
+    { 1, HW_OMX_VIDEO_MPEG4Level1 },
+    { 2, HW_OMX_VIDEO_MPEG4Level2 },
+    { 3, HW_OMX_VIDEO_MPEG4Level3 },
+    { 4, HW_OMX_VIDEO_MPEG4Level4 },
+    { 5, HW_OMX_VIDEO_MPEG4Level5 },
+    { 6, HW_OMX_VIDEO_MPEG4Level6 },
+};
+
+static const ProfileLevelMap mpeg2_profile_adaptation_map[] = {
+    { FF_PROFILE_MPEG2_SIMPLE,       HW_OMX_VIDEO_MPEG2ProfileSimple },
+    { FF_PROFILE_MPEG2_MAIN,         HW_OMX_VIDEO_MPEG2ProfileMain },
+    { FF_PROFILE_MPEG2_422,          HW_OMX_VIDEO_MPEG2Profile422 },
+    { FF_PROFILE_MPEG2_SNR_SCALABLE, HW_OMX_VIDEO_MPEG2ProfileSNR },
+    { FF_PROFILE_MPEG2_SS,           HW_OMX_VIDEO_MPEG2ProfileSpatial },
+    { FF_PROFILE_MPEG2_HIGH,         HW_OMX_VIDEO_MPEG2ProfileHigh },
+};
+
+static const ProfileLevelMap mpeg2_level_adaptation_map[] = {
+    { 10, HW_OMX_VIDEO_MPEG2LevelLL },
+    { 8,  HW_OMX_VIDEO_MPEG2LevelML },
+    { 6,  HW_OMX_VIDEO_MPEG2LevelH14 },
+    { 4,  HW_OMX_VIDEO_MPEG2LevelHL },
+};
+
+static const ProfileLevelMapInfo profile_level_map_info_list[] = {
+    { AV_CODEC_ID_H264,       h264_profile_adaptation_map,    COUNTOF(h264_profile_adaptation_map),
+                              h264_level_adaptation_map,      COUNTOF(h264_level_adaptation_map) },
+    { AV_CODEC_ID_HEVC,       hevc_profile_adaptation_map,    COUNTOF(hevc_profile_adaptation_map),
+                              hevc_main_level_adaptation_map, COUNTOF(hevc_main_level_adaptation_map) },
+    { AV_CODEC_ID_VP9,        vp9_profile_adaptation_map,     COUNTOF(vp9_profile_adaptation_map),
+                              vp9_main_level_adaptation_map,  COUNTOF(vp9_main_level_adaptation_map) },
+    { AV_CODEC_ID_MPEG4,      mpeg4_profile_adaptation_map,   COUNTOF(mpeg4_profile_adaptation_map),
+                              mpeg4_level_adaptation_map,     COUNTOF(mpeg4_level_adaptation_map) },
+    { AV_CODEC_ID_MPEG2VIDEO, mpeg2_profile_adaptation_map,   COUNTOF(mpeg2_profile_adaptation_map),
+                              mpeg2_level_adaptation_map,     COUNTOF(mpeg2_level_adaptation_map) },
+    { AV_CODEC_ID_MPEG1VIDEO, mpeg2_profile_adaptation_map,   COUNTOF(mpeg2_profile_adaptation_map),
+                              mpeg2_level_adaptation_map,     COUNTOF(mpeg2_level_adaptation_map) },
+};
+
+static void omx_get_profile(AVCodecContext *avctx, const ProfileLevelMap *profile_map, uint32_t profile_map_size)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    int32_t i;
+
+    for (i = 0; i < profile_map_size; i++) {
+        if (avctx->profile == profile_map[i].ff_name) {
+            s->omx_profile = profile_map[i].omx_name;
+            return;
+        }
+    }
+
+    if (i == profile_map_size) {
+        s->omx_profile = HW_OMX_VIDEO_INVALID_PARAMETER;
+    }
+}
+
+static void omx_get_level(AVCodecContext *avctx, const ProfileLevelMap *level_map, uint32_t level_map_size)
+{
+    OMXCodecContext *s = avctx->priv_data;
+    int32_t i;
+
+    for (i = 0; i < level_map_size; i++) {
+        if (avctx->level == level_map[i].ff_name) {
+            s->omx_level = level_map[i].omx_name;
+            return;
+        }
+    }
+
+    if (i == level_map_size) {
+        s->omx_level = HW_OMX_VIDEO_INVALID_PARAMETER;
+    }
+}
+
+
+void omx_get_profile_and_level(AVCodecContext *avctx)
+{
+    int32_t index = 0;
+    OMXCodecContext *s = avctx->priv_data;
+
+    for (index = 0; index < COUNTOF(profile_level_map_info_list); index++) {
+        if (avctx->codec->id == profile_level_map_info_list[index].codec_id) {
+            break;
+        }
+    }
+
+    if (index == COUNTOF(profile_level_map_info_list)) {
+        s->omx_profile = HW_OMX_VIDEO_INVALID_PARAMETER;
+        s->omx_level = HW_OMX_VIDEO_INVALID_PARAMETER;
+        return;
+    }
+
+    omx_get_profile(avctx, profile_level_map_info_list[index].profile_map, profile_level_map_info_list[index].profile_map_size);
+
+    omx_get_level(avctx, profile_level_map_info_list[index].level_map, profile_level_map_info_list[index].level_map_size);
+}
+
Index: ffmpeg/libavcodec/omx_profile_level.h
===================================================================
--- /dev/null
+++ ffmpeg/libavcodec/omx_profile_level.h
@@ -0,0 +1,46 @@
+/*
+ * OMX Video decoder
+ * Copyright (c) Huawei Technologies
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef HW_OMX_PROFILE_LEVEL_H
+#define HW_OMX_PROFILE_LEVEL_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "avcodec.h"
+#include "omx_dec_log.h"
+#include "HW_OMX_Types.h"
+
+typedef struct ProfileLevelMap {
+    int32_t ff_name;
+    int32_t omx_name;
+} ProfileLevelMap;
+
+typedef struct ProfileLevelMapInfo {
+    int32_t codec_id;
+    const ProfileLevelMap *profile_map;
+    uint32_t profile_map_size;
+    const ProfileLevelMap *level_map;
+    uint32_t level_map_size;
+} ProfileLevelMapInfo;
+
+void omx_get_profile_and_level(AVCodecContext* avctx);
+
+#endif
