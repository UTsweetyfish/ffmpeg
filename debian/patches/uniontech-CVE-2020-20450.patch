commit: 5400e4a50c61e53e1bc50b3e77201649bbe9c510
Author: Andreas Rheinhardt <andreas.rheinhardt@gmail.com>
Date:   Fri, 28 Feb 2020 04:48:22 +0100

diff --git a/libavformat/mxfenc.c b/libavformat/mxfenc.c
index a94adec..d2b04ec 100644
--- a/libavformat/mxfenc.c
+++ b/libavformat/mxfenc.c
@@ -1982,7 +1982,6 @@ static int mxf_parse_dnxhd_frame(AVFormatContext *s, AVStream *st, AVPacket *pkt
     if (pkt->size < 43)
         return 0;
 
-    sc->codec_ul = NULL;
     cid = AV_RB32(pkt->data + 0x28);
     for (i = 0; i < FF_ARRAY_ELEMS(mxf_dnxhd_codec_uls); i++) {
         if (cid == mxf_dnxhd_codec_uls[i].cid) {
@@ -1990,7 +1989,7 @@ static int mxf_parse_dnxhd_frame(AVFormatContext *s, AVStream *st, AVPacket *pkt
             break;
         }
     }
-    if (!sc->codec_ul)
+    if (i == FF_ARRAY_ELEMS(mxf_dnxhd_codec_uls))
         return 0;
 
     sc->component_depth = 0;
@@ -2127,6 +2126,7 @@ static int mxf_parse_h264_frame(AVFormatContext *s, AVStream *st,
     static const int mxf_h264_num_codec_uls = sizeof(mxf_h264_codec_uls) / sizeof(mxf_h264_codec_uls[0]);
     const uint8_t *buf = pkt->data;
     const uint8_t *buf_end = pkt->data + pkt->size;
+    const UID *codec_ul = NULL;
     uint32_t state = -1;
     int long_gop = 0; // assume intra when there is no SPS header
     int extra_size = 512; // support AVC Intra files without SPS/PPS header
@@ -2169,7 +2169,7 @@ static int mxf_parse_h264_frame(AVFormatContext *s, AVStream *st,
     frame_size = pkt->size + extra_size;
     for (i = 0; i < mxf_h264_num_codec_uls; i++) {
         if (frame_size == mxf_h264_codec_uls[i].frame_size && sc->interlaced == mxf_h264_codec_uls[i].interlaced) {
-            sc->codec_ul = &mxf_h264_codec_uls[i].uid;
+            codec_ul = &mxf_h264_codec_uls[i].uid;
             sc->component_depth = 10; // AVC Intra is always 10 Bit
             if (sc->interlaced)
                 sc->field_dominance = 1; // top field first is mandatory for AVC Intra
@@ -2177,15 +2177,16 @@ static int mxf_parse_h264_frame(AVFormatContext *s, AVStream *st,
         } else if ((mxf_h264_codec_uls[i].profile == par->profile) &&
                    ((mxf_h264_codec_uls[i].long_gop < 0) ||
                    (mxf_h264_codec_uls[i].long_gop == long_gop))) {
-            sc->codec_ul = &mxf_h264_codec_uls[i].uid;
+            codec_ul = &mxf_h264_codec_uls[i].uid;
             uid_found = 1;
         }
     }
 
-    if (!uid_found) {
+    if (!codec_ul) {
         av_log(s, AV_LOG_ERROR, "h264 profile not supported\n");
         return 0;
     }
+    sc->codec_ul = codec_ul;
 
     return 1;
 }
@@ -2282,9 +2283,13 @@ static int mxf_parse_mpeg2_frame(AVFormatContext *s, AVStream *st,
             }
         }
     }
-    if (s->oformat != &ff_mxf_d10_muxer)
-        sc->codec_ul = mxf_get_mpeg2_codec_ul(st->codecpar);
-    return !!sc->codec_ul;
+    if (s->oformat != &ff_mxf_d10_muxer) {
+        const UID *codec_ul = mxf_get_mpeg2_codec_ul(st->codecpar);
+        if (!codec_ul)
+            return 0;
+        sc->codec_ul = codec_ul;
+    }
+    return 1;
 }
 
 static uint64_t mxf_parse_timestamp(time_t timestamp)
